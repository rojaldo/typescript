= Curso Completo de TypeScript
:toc:
:toc-title: Contenido
:doctype: book
:icons: font
:source-highlighter: highlight.js
:sectlinks:

== Introducción

Este curso cubre TypeScript desde los fundamentos hasta aplicaciones avanzadas de producción. Progresa desde conceptos básicos de tipos hasta patrones complejos de diseño y arquitectura.

== Temario del Curso

=== Módulo 1: Fundamentos de TypeScript

TypeScript es un lenguaje de programación construido sobre JavaScript que añade tipos estáticos. Este módulo introductorio establece las bases para comprender cómo TypeScript mejora la seguridad y calidad del código.

==== 1.1 ¿Qué es TypeScript y por qué lo necesitamos?

===== Definición y Propósito

TypeScript es un **superset tipado de JavaScript** que se compila a código JavaScript limpio. Añade un sistema de tipos opcional que es verificado en tiempo de compilación (no en tiempo de ejecución).

.Características Principales:
- Sistema de tipos estáticos opcional
- Detección temprana de errores
- Mejor autocompletado en IDEs
- Documentación a través de tipos
- Compatible 100% con JavaScript existente

===== Por qué usamos TypeScript

.Problemas que resuelve:
[source,javascript]
----
// Problema en JavaScript puro
function sumar(a, b) {
  return a + b;  // ¿Qué pasa con strings?
}

sumar(5, 10);          // 15 ✓
sumar("5", "10");      // "510" ✗ Concatena, no suma
sumar(5, "10");        // "510" ✗ Resultado inesperado
sumar(null, undefined); // NaN ✗ Imposible detectar esto sin tipos
----

.Solución con TypeScript:
[source,typescript]
----
function sumar(a: number, b: number): number {
  return a + b;
}

sumar(5, 10);          // 15 ✓
sumar("5", "10");      // ✗ Error en compilación
sumar(5, "10");        // ✗ Error en compilación
sumar(null, undefined); // ✗ Error en compilación

// El compilador previene errores ANTES de ejecutar
----

===== Beneficios Concretos

|===
| Aspecto | JavaScript | TypeScript

| Detección de errores
| Runtime (cuando ya es tarde)
| Compilación (antes de producción)

| Autocompletado
| Limitado
| Excelente (IDEs entienden los tipos)

| Refactoring
| Riesgoso (cambia y confía)
| Seguro (tipos guían el cambio)

| Documentación
| Comentarios manuales
| Tipos son auto-documentación

| Mantenimiento
| Difícil en proyectos grandes
| Más fácil con tipos
|===


==== 1.2 Instalación y Configuración Inicial

===== Instalación de TypeScript

.Opción 1: Instalar globalmente (no recomendado)
[source,bash]
----
npm install -g typescript
tsc --version
----

.Opción 2: Instalar en el proyecto (recomendado)
[source,bash]
----
mkdir mi-proyecto-ts
cd mi-proyecto-ts
npm init -y
npm install --save-dev typescript

# Verificar instalación
npx tsc --version
----

===== Crear archivo tsconfig.json

El archivo `tsconfig.json` configura cómo TypeScript compila tu código.

.Configuración mínima:
[source,bash]
----
npx tsc --init
----

Este comando crea `tsconfig.json` con opciones default.

.tsconfig.json básico:
[source,json]
----
{
  "compilerOptions": {
    "target": "ES2020",              // Versión JavaScript objetivo
    "module": "commonjs",             // Formato de módulos
    "outDir": "./dist",               // Carpeta de salida
    "rootDir": "./src",               // Carpeta de entrada
    "strict": true,                   // Verificación estricta
    "esModuleInterop": true,          // Interoperabilidad con módulos
    "skipLibCheck": true,             // Saltar verificación de libs
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src"],                 // Incluir archivos en src/
  "exclude": ["node_modules"]         // Excluir node_modules
}
----

===== Estructura de Carpetas Recomendada

[source,bash]
----
mi-proyecto-ts/
├── src/                    # Código fuente TypeScript
│   ├── index.ts
│   ├── utils.ts
│   └── types.ts
├── dist/                   # Código compilado (generado)
├── node_modules/
├── package.json
├── tsconfig.json
└── README.md
----

===== Scripts en package.json

.Agregar scripts útiles:
[source,json]
----
{
  "scripts": {
    "build": "tsc",              // Compilar
    "dev": "tsc --watch",        // Compilar en modo watch
    "start": "node dist/index.js" // Ejecutar compilado
  }
}
----

.Usar los scripts:
[source,bash]
----
npm run build   # Compila src/ → dist/
npm run dev     # Espera cambios y recompila
npm start       # Ejecuta el resultado compilado
----


==== 1.3 Primeros Pasos: Tipos Primitivos

===== Tu Primer Archivo TypeScript

.Crear src/index.ts:
[source,typescript]
----
// Variables con tipos
let nombre: string = "Juan";
let edad: number = 25;
let activo: boolean = true;

console.log(`Hola, soy ${nombre} y tengo ${edad} años`);
console.log(`¿Estoy activo? ${activo}`);
----

.Compilar y ejecutar:
[source,bash]
----
npm run build
npm start

# Output:
# Hola, soy Juan y tengo 25 años
# ¿Estoy activo? true
----

===== Los Cinco Tipos Primitivos

**1. string** - Texto
[source,typescript]
----
let mensaje: string = "Hola TypeScript";
let otroMensaje: string = 'También con comillas simples';
let plantilla: string = `Plantilla: ${mensaje}`;

console.log(mensaje);        // "Hola TypeScript"
console.log(plantilla);      // "Plantilla: Hola TypeScript"
----

**2. number** - Números (enteros y decimales)
[source,typescript]
----
let entero: number = 42;
let decimal: number = 3.14159;
let negativo: number = -100;
let infinito: number = Infinity;
let noEsNumero: number = NaN;

console.log(entero + decimal);  // 45.14159
----

**3. boolean** - Verdadero o Falso
[source,typescript]
----
let esVerdad: boolean = true;
let esfalso: boolean = false;

let esMayorDeEdad: boolean = 25 > 18;  // true
let puedeConducir: boolean = esMayorDeEdad && esVerdad;

if (puedeConducir) {
  console.log("Puedes conducir");
}
----

**4. null y undefined**
[source,typescript]
----
// null: "sin valor intencional"
let valor1: null = null;

// undefined: "sin valor asignado"
let valor2: undefined = undefined;

// Más comúnmente como parte de tipos opcionales
let posibleString: string | null = null;
let posibleNumero: number | undefined;

// Checar qué es qué
console.log(typeof null);      // "object" (rareza de JS)
console.log(typeof undefined); // "undefined"
----

**5. any** - "Cualquier Tipo" (usar con cuidado)
[source,typescript]
----
// any desactiva la verificación de tipos
let cualquierCosa: any = "texto";
cualquierCosa = 42;          // ✓ Permitido
cualquierCosa = true;        // ✓ Permitido
cualquierCosa = { x: 100 };  // ✓ Permitido

// Esto NO da error pero es peligroso:
console.log(cualquierCosa.metodoInexistente()); // ✗ Error en runtime
----

⚠️ **Evitar `any`**: Es mejor usar tipos específicos o `unknown` + type guards.

===== Type Inference (Inferencia de Tipos)

TypeScript puede **deducir tipos automáticamente**:

[source,typescript]
----
// TypeScript infiere el tipo
let numero = 42;              // inferido como: number
let texto = "Hola";           // inferido como: string
let booleano = true;          // inferido como: boolean

// Estos errores se detectan:
numero = "texto";             // ✗ Error: Type 'string' is not assignable to type 'number'
texto = 100;                  // ✗ Error: Type 'number' is not assignable to type 'string'
----

Es mejor ser **explícito** en código complejo:

[source,typescript]
----
// Explícito (preferido en equipos)
let resultado: number = sumar(5, 10);

// Implícito (OK para variables simples)
let temporal = 42;
----


==== 1.4 Del JavaScript a TypeScript

===== Migración Gradual

TypeScript es **compatible hacia atrás** con JavaScript. Puedes migrar gradualmente.

.Paso 1: Renombrar .js a .ts
[source,bash]
----
# Cambiar extensión
mv funciones.js funciones.ts
mv utils.js utils.ts
----

.Paso 2: El archivos .ts más básico sigue siendo JavaScript válido
[source,typescript]
----
// Este código ES VÁLIDO en TypeScript sin cambios
function sumar(a, b) {
  return a + b;
}

const resultado = sumar(5, 10);
console.log(resultado);
----

.Paso 3: Añadir tipos gradualmente
[source,typescript]
----
// Versión mejorada con tipos
function sumar(a: number, b: number): number {
  return a + b;
}

const resultado: number = sumar(5, 10);
console.log(resultado);
----

===== Diferencias Clave: JS vs TS

|===
| Aspecto | JavaScript | TypeScript

| Tipos
| Dinámicos (runtime)
| Estáticos (compilación)

| Sintaxis
| `function foo(x) {}`
| `function foo(x: number): number {}`

| Compilación
| N/A (se ejecuta directo)
| Compila a JavaScript

| Errores
| Descubiertos en runtime
| Descubiertos antes

| Archivo
| `.js`
| `.ts`

| Ejecución
| `node archivo.js`
| `tsc && node dist/archivo.js`
|===

===== Ejemplo Completo: Conversor de Temperatura

.JavaScript original (sin tipos):
[source,javascript]
----
// tipos.js - No hay forma de saber qué espera cada función
function celsiusAFahrenheit(celsius) {
  return (celsius * 9/5) + 32;
}

function fahrenheitACelsius(fahrenheit) {
  return (fahrenheit - 32) * 5/9;
}

console.log(celsiusAFahrenheit(0));      // 32 ✓
console.log(celsiusAFahrenheit("25"));   // "45" ✗ Bug silencioso
console.log(celsiusAFahrenheit(null));   // 32 ✗ Bug silencioso
----

.TypeScript equivalente (con tipos):
[source,typescript]
----
// tipos.ts - Tipos explícitos previenen errores
function celsiusAFahrenheit(celsius: number): number {
  return (celsius * 9/5) + 32;
}

function fahrenheitACelsius(fahrenheit: number): number {
  return (fahrenheit - 32) * 5/9;
}

console.log(celsiusAFahrenheit(0));      // 32 ✓
console.log(celsiusAFahrenheit("25"));   // ✗ Error en compilación
console.log(celsiusAFahrenheit(null));   // ✗ Error en compilación

// Uso correcto
const enFahrenheit: number = celsiusAFahrenheit(25);
console.log(enFahrenheit);  // 77
----

===== Compilación y Ejecución

.Ver el JavaScript generado:
[source,bash]
----
npm run build
cat dist/tipos.js
----

.Output (JavaScript limpio):
[source,javascript]
----
"use strict";
function celsiusAFahrenheit(celsius) {
  return (celsius * 9 / 5) + 32;
}
function fahrenheitACelsius(fahrenheit) {
  return (fahrenheit - 32) * 5 / 9;
}
console.log(celsiusAFahrenheit(0));
const enFahrenheit = celsiusAFahrenheit(25);
console.log(enFahrenheit);
----

**Nota**: Los tipos desaparecen en la compilación porque JavaScript no entiende de tipos. Solo se usan para validar durante el desarrollo.

===== Ejercicios Propuestos

.1. Crear funciones tipadas:
[source,typescript]
----
// Crear estas funciones con tipos
// 1. multiplicar(a: number, b: number): number
// 2. obtenerNombreCompleto(nombre: string, apellido: string): string
// 3. esAdulto(edad: number): boolean
// 4. cortarTexto(texto: string, longitud: number): string
----

.2. Identificar y corregir errores:
[source,typescript]
----
// Hay errores de tipos aquí, enumerarlos
let numero: number = "42";
let mensaje: string = 100;
function saludar(nombre: string) {
  return nombre + 5;
}
saludar(123);
----

.3. Inferencia de tipos:
[source,typescript]
----
// Sin especificar tipos, ¿qué tipo infiere TypeScript?
let valor1 = 42;
let valor2 = "texto";
let valor3 = true;
let valor4 = null;
let valor5 = undefined;
// Verificar con Ctrl+Hover en VSCode
----


=== Módulo 2: Sistema de Tipos Básico

Este módulo profundiza en el sistema de tipos de TypeScript. Comprenderás cómo combinar tipos, usar tipos especiales y manejar situaciones complejas de tipado.

==== 2.1 Tipos Primitivos Revisitados

Ya vimos los básicos en el Módulo 1. Ahora exploramos usos más avanzados.

===== string - Más allá de texto

[source,typescript]
----
// Strings simples
let nombre: string = "Juan";

// Template literals para composición
let saludo: string = `Hola, ${nombre}`;

// Strings multilínea
let poema: string = `
  Roses are red,
  Violets are blue,
  TypeScript types,
  Make code true.
`;

// Métodos de string disponibles
console.log(nombre.toUpperCase());     // "JUAN"
console.log(nombre.length);            // 4
console.log(nombre.includes("ua"));    // true
console.log(nombre.slice(0, 2));       // "Ju"
----

===== number - Todos los números son uno

[source,typescript]
----
// En JavaScript (y TypeScript), todos los números son float
let entero: number = 42;
let decimal: number = 3.14;
let negativo: number = -100;

// Valores especiales
let infinito: number = Infinity;
let menosInfinito: number = -Infinity;
let noEsNumero: number = NaN;

// Verificar tipos especiales
function esValido(n: number): boolean {
  return !isNaN(n) && isFinite(n);
}

console.log(esValido(42));         // true
console.log(esValido(NaN));        // false
console.log(esValido(Infinity));   // false

// Métodos de número
let x: number = 3.7;
console.log(Math.floor(x));        // 3
console.log(Math.ceil(x));         // 4
console.log(Math.round(x));        // 4
console.log(x.toFixed(1));         // "3.7"
----

===== boolean - Lógica pura

[source,typescript]
----
// Valores booleanos
let verdadero: boolean = true;
let falso: boolean = false;

// Resultados de comparaciones
let esIgual: boolean = 5 === 5;           // true
let esDiferente: boolean = 5 !== 5;       // false
let esMayor: boolean = 10 > 5;            // true

// Operadores lógicos
let esValido: boolean = true && false;    // false
let esUno: boolean = true || false;       // true
let esNegado: boolean = !true;            // false

// Uso en control de flujo
function procesarUsuario(esMayorDeEdad: boolean): string {
  if (esMayorDeEdad) {
    return "Acceso completo";
  }
  return "Acceso restringido";
}

console.log(procesarUsuario(true));       // "Acceso completo"
----


==== 2.2 Tipos Especiales

===== unknown - El tipo seguro

`unknown` es el tipo más seguro. Acepta cualquier valor, pero **requiere validación antes de usar**.

[source,typescript]
----
// unknown: seguro pero restrictivo
let valor: unknown = 42;          // ✓ Puede ser cualquier cosa
valor = "texto";                  // ✓ Puede cambiar de tipo
valor = { x: 100 };              // ✓ Cualquier valor está permitido

// Pero NO puedes usarlo sin verificar
console.log(valor.length);       // ✗ Error: Object is of type 'unknown'
console.log(valor + 10);         // ✗ Error: Object is of type 'unknown'

// Necesitas type guards
function procesarValor(valor: unknown) {
  // 1. Verificar tipo con typeof
  if (typeof valor === 'string') {
    console.log(valor.length);   // ✓ Seguro aquí
  }
  
  // 2. Verificar con instanceof
  if (valor instanceof Array) {
    console.log(valor.length);   // ✓ Seguro aquí
  }
  
  // 3. Verificar con type guard
  if (typeof valor === 'number') {
    console.log(valor + 10);     // ✓ Seguro aquí
  }
}

procesarValor("Hola");
procesarValor([1, 2, 3]);
procesarValor(42);
----

**unknown vs any**:
- `any`: "Ignora tipos, confía en mí" (peligroso)
- `unknown`: "Aceptaré cualquier cosa, pero verifica antes de usar" (seguro)

===== never - El tipo imposible

`never` representa un valor que nunca debería ocurrir.

[source,typescript]
----
// 1. Funciones que nunca retornan (lanzan error o loop infinito)
function lanzarError(mensaje: string): never {
  throw new Error(mensaje);
}

function loopInfinito(): never {
  while (true) {
    // nunca sale
  }
}

// Uso:
try {
  lanzarError("Algo salió mal");
} catch (error) {
  console.log("Error capturado");
}

// 2. Tipos nunca alcanzables (exhaustiveness checking)
type Accion = "crear" | "leer" | "actualizar" | "eliminar";

function manejarAccion(accion: Accion) {
  switch (accion) {
    case "crear":
      console.log("Creando...");
      break;
    case "leer":
      console.log("Leyendo...");
      break;
    case "actualizar":
      console.log("Actualizando...");
      break;
    case "eliminar":
      console.log("Eliminando...");
      break;
    default:
      // Si olvidamos un caso, TypeScript lo detecta
      const _exhaustive: never = accion;  // Error si falta case
      return _exhaustive;
  }
}
----

===== null y undefined - Presencia/Ausencia

[source,typescript]
----
// undefined: "Sin valor asignado"
let sinValor: undefined = undefined;
let noInicializado: number | undefined;

// null: "Sin valor intencional"
let vacio: null = null;
let puedeSerNull: string | null = null;

// Diferencia práctica
function obtenerUsuario(id: number): { nombre: string } | null {
  if (id > 0) {
    return { nombre: "Juan" };
  }
  return null;  // Explícitamente: no existe
}

let usuario = obtenerUsuario(1);
if (usuario !== null) {
  console.log(usuario.nombre);  // ✓ Seguro
}

// Optional chaining (?.)
let nombre = usuario?.nombre;   // undefined si usuario es null

// Nullish coalescing (??)
let nombrePorDefecto = usuario?.nombre ?? "Anónimo";
----


==== 2.3 Tipos Literales y Uniones

===== Tipos Literales

Un tipo literal es un **valor específico**, no un tipo general.

[source,typescript]
----
// Tipo literal: exactamente "activo"
type Estado = "activo";
let e1: Estado = "activo";     // ✓
// let e2: Estado = "inactivo"; // ✗ Error

// Tipo literal de número
type Prioridad = 1 | 2 | 3;
let p1: Prioridad = 1;         // ✓
let p2: Prioridad = 2;         // ✓
// let p3: Prioridad = 4;       // ✗ Error

// Tipo literal booleano
type Permitido = true;
let x: Permitido = true;       // ✓
// let y: Permitido = false;    // ✗ Error
----

===== Tipos de Unión (Union Types)

Un valor que **puede ser uno de varios tipos**.

[source,typescript]
----
// Una variable que puede ser string O number
type Identificador = string | number;

let id1: Identificador = "ABC123";    // ✓
let id2: Identificador = 12345;       // ✓
// let id3: Identificador = true;     // ✗ Error

// Con más de dos tipos
type Valor = string | number | boolean;
let v1: Valor = "texto";              // ✓
let v2: Valor = 42;                   // ✓
let v3: Valor = true;                 // ✓

// Función que acepta unión de tipos
function procesar(valor: string | number): void {
  if (typeof valor === 'string') {
    console.log(`String: ${valor.length}`);
  } else {
    console.log(`Número: ${valor + 10}`);
  }
}

procesar("Hola");   // "String: 5"
procesar(42);       // "Número: 52"
----

===== Discriminated Unions

Usar un campo para distinguir qué tipo es.

[source,typescript]
----
// Cada tipo tiene un 'type' diferente para identificarse
type Respuesta =
  | { tipo: 'exito'; datos: string }
  | { tipo: 'error'; mensaje: string }
  | { tipo: 'cargando' };

function manejarRespuesta(r: Respuesta): void {
  switch (r.tipo) {
    case 'exito':
      console.log("Datos:", r.datos);      // ✓ 'datos' existe aquí
      break;
    case 'error':
      console.log("Error:", r.mensaje);    // ✓ 'mensaje' existe aquí
      break;
    case 'cargando':
      console.log("Espera...");            // ✓ No tiene datos
      break;
  }
}

// Usar:
let resp1: Respuesta = { tipo: 'exito', datos: 'OK' };
let resp2: Respuesta = { tipo: 'error', mensaje: 'Falló' };
let resp3: Respuesta = { tipo: 'cargando' };

manejarRespuesta(resp1);
manejarRespuesta(resp2);
manejarRespuesta(resp3);
----

===== Combinación: Intersection Types

Combinar tipos para crear uno nuevo que tenga **todas las propiedades**.

[source,typescript]
----
type Persona = {
  nombre: string;
  edad: number;
};

type Empleado = {
  id: number;
  puesto: string;
};

// Intersection: tiene propiedades de ambos
type EmpleadoPersona = Persona & Empleado;

const juan: EmpleadoPersona = {
  nombre: "Juan",
  edad: 30,
  id: 101,
  puesto: "Ingeniero"
};

console.log(juan.nombre);   // "Juan"
console.log(juan.puesto);   // "Ingeniero"
----


==== 2.4 Type Inference y Type Annotations

===== Type Inference (Deducción Automática)

TypeScript **infiere tipos** automáticamente cuando es obvio.

[source,typescript]
----
// TypeScript infiere automáticamente
let numero = 42;              // infiere: number
let texto = "Hola";           // infiere: string
let booleano = true;          // infiere: boolean
let lista = [1, 2, 3];        // infiere: number[]
let objeto = { x: 10, y: 20 }; // infiere: { x: number; y: number }

// Verificar tipo inferido en VSCode: Ctrl+Click en la variable
// O pasar mouse encima para ver tooltip

// Inference en funciones
function suma(a: number, b: number) {
  return a + b;  // Infiere retorno: number
}

const resultado = suma(5, 10);  // Infiere: number
----

===== Type Annotations (Anotaciones Explícitas)

Especificar tipos manualmente para claridad o control.

[source,typescript]
----
// Explícito: mejor documentación
let nombre: string = "Juan";
let edad: number = 25;
let activo: boolean = true;

// En funciones
function multiplicar(a: number, b: number): number {
  return a * b;
}

// En variables complejas
let numeros: number[] = [1, 2, 3];
let tupla: [string, number] = ["hola", 42];

// En objetos
let usuario: { nombre: string; edad: number } = {
  nombre: "María",
  edad: 28
};
----

===== Cuándo Usar Cada Uno

|===
| Situación | Usar | Ejemplo

| Variables simples
| Inference
| `let x = 42;`

| Función publica/API
| Annotation
| `function foo(x: number): string`

| Tipos complejos
| Annotation
| `let user: { name: string; age: number }`

| Arrays
| Annotation sí no es obvio
| `let nums: number[] = [];`

| Union/especial
| Annotation
| `let id: string \| number`
|===

===== Errores Comunes de Inferencia

[source,typescript]
----
// Problema 1: Array vacío
let numeros = [];  // Infiere: any[] ✗
let numeros: number[] = [];  // Correcto ✓

// Problema 2: Unión no esperada
let valor = Math.random() > 0.5 ? "texto" : 42;
// Infiere: string | number
// Si esperas solo string, son errores

// Problema 3: Funciones sin tipo de retorno
function procesar(x: number) {
  if (x > 0) return "positivo";
  if (x < 0) return "negativo";
  // ¿Qué pasa si x === 0? No hay return
  // Debería especificar retorno
}

function procesarBien(x: number): string {
  if (x > 0) return "positivo";
  if (x < 0) return "negativo";
  return "cero";  // Explícito
}
----

===== Const Assertions

Hacer que TypeScript trate valores como **exactamente esos valores** (literal types).

[source,typescript]
----
// Sin as const
let color1 = "red";     // Infiere: string (podría ser cualquier string)

// Con as const
let color2 = "red" as const;  // Infiere: "red" (exactamente ese valor)

// Uso con arrays
let numeros1 = [1, 2, 3];     // Infiere: number[]
let numeros2 = [1, 2, 3] as const;  // Infiere: readonly [1, 2, 3]

// Uso con objetos
let obj1 = { x: 10, y: 20 };
// Infiere: { x: number; y: number }

let obj2 = { x: 10, y: 20 } as const;
// Infiere: { readonly x: 10; readonly y: 20 }

// Ejemplo práctico: colores disponibles
type ColoresPermitidos = "rojo" | "verde" | "azul";

const colores = ["rojo", "verde", "azul"] as const;
// TypeScript sabe que cada elemento es ColoresPermitidos exacto
----

===== Ejercicios Propuestos

.1. Identificar tipos inferidos:
[source,typescript]
----
// ¿Qué tipo infiere TypeScript para cada variable?
let x = 42;
let y = "hola";
let z = [1, 2, 3];
let w = { nombre: "Juan" };
let v = Math.random() > 0.5 ? "sí" : "no";
----

.2. Usar unknown y type guards:
[source,typescript]
----
function procesar(valor: unknown): void {
  // Crear 3 type guards diferentes
  // 1. Para string (usar .length)
  // 2. Para número (sumar 10)
  // 3. Para array (usar .map)
}
----

.3. Tipos de unión en función:
[source,typescript]
----
// Crear función que acepte string | number | boolean
// Y retorne descripción del tipo recibido
function describir(valor: ???): string {
  // "Es string", "Es número", "Es booleano"
}
----

.4. Discriminated union:
[source,typescript]
----
// Crear tipo para resultado de operación:
// Éxito: { status: 'ok'; valor: number }
// Error: { status: 'error'; codigo: number }
// Y una función que maneja ambos casos
----


=== Módulo 3: Tipos Complejos

Este módulo se enfoca en crear tipos más sofisticados para estructuras de datos complejas. Dominarás interfaces, type aliases, objetos anidados y los fundamentos de genéricos.

==== 3.1 Interfaces: Definición y Uso

Una **interfaz** define la forma/estructura de un objeto. Es un contrato que especifica qué propiedades y métodos debe tener.

===== Interfaz Básica

[source,typescript]
----
// Definir una interfaz
interface Usuario {
  nombre: string;
  edad: number;
  email: string;
}

// Usar la interfaz
const usuario1: Usuario = {
  nombre: "Juan",
  edad: 30,
  email: "juan@example.com"
};

// TypeScript verifica las propiedades
const usuario2: Usuario = {
  nombre: "María",
  edad: 25
  // ✗ Error: falta 'email'
};

// Las propiedades están tipadas
console.log(usuario1.nombre.toUpperCase());  // ✓ string
console.log(usuario1.edad + 5);              // ✓ number
----

===== Propiedades Opcionales

Algunas propiedades pueden ser opcionales con `?`.

[source,typescript]
----
interface Persona {
  nombre: string;
  edad: number;
  telefono?: string;          // Opcional
  direccion?: string;         // Opcional
}

const persona1: Persona = {
  nombre: "Ana",
  edad: 28
  // telefono y direccion pueden omitirse
};

const persona2: Persona = {
  nombre: "Carlos",
  edad: 35,
  telefono: "555-1234"
  // direccion sigue siendo opcional
};

// Acceso seguro a opcionales
if (persona1.telefono) {
  console.log(`Teléfono: ${persona1.telefono}`);
}
----

===== Propiedades Readonly

Marcar propiedades como solo lectura.

[source,typescript]
----
interface Producto {
  id: number;           // ID puede ser modificado
  readonly sku: string; // SKU no puede cambiar
  precio: number;
}

const producto: Producto = {
  id: 1,
  sku: "PROD-001",
  precio: 99.99
};

producto.id = 2;           // ✓ Permitido
producto.precio = 149.99;  // ✓ Permitido
producto.sku = "PROD-002"; // ✗ Error: sku es readonly
----

===== Métodos en Interfaces

Las interfaces pueden definir métodos.

[source,typescript]
----
interface Calculadora {
  sumar(a: number, b: number): number;
  restar(a: number, b: number): number;
  multiplicar(a: number, b: number): number;
}

// Implementar la interfaz
const miCalculadora: Calculadora = {
  sumar: (a, b) => a + b,
  restar: (a, b) => a - b,
  multiplicar: (a, b) => a * b
};

console.log(miCalculadora.sumar(10, 5));      // 15
console.log(miCalculadora.restar(10, 5));     // 5
console.log(miCalculadora.multiplicar(10, 5)); // 50
----

===== Extender Interfaces

Las interfaces pueden heredar propiedades de otras.

[source,typescript]
----
interface Animal {
  nombre: string;
  edad: number;
}

interfacePerro extends Animal {
  raza: string;
  traerPelota(): void;
}

const miPerro: Perro = {
  nombre: "Rex",
  edad: 3,
  raza: "Labrador",
  traerPelota: () => console.log("¡Trae la pelota!")
};

// Heredar de múltiples interfaces
interface Volador {
  volar(): void;
}

interface Nadador {
  nadar(): void;
}

interface Pato extends Volador, Nadador {
  graznar(): void;
}

const pato: Pato = {
  volar: () => console.log("Volando..."),
  nadar: () => console.log("Nadando..."),
  graznar: () => console.log("¡Cuak!")
};
----

===== Index Signatures

Cuando los nombres de las propiedades no se conocen de antemano.

[source,typescript]
----
// Interfaz con propiedades dinámicas
interface Diccionario {
  [key: string]: string;
}

const traduccion: Diccionario = {
  "hola": "hello",
  "adiós": "goodbye",
  "gracias": "thank you"
};

// Agregar nuevas propiedades dinámicamente
traduccion["buenos días"] = "good morning";

// Acceder
console.log(traduccion["hola"]);  // "hello"

// Ejemplo práctico: mapa de usuarios por ID
interface UsuariosMap {
  [id: number]: string;  // ID → nombre
}

const usuarios: UsuariosMap = {
  1: "Juan",
  2: "María",
  3: "Carlos"
};
----


==== 3.2 Type Aliases vs Interfaces

Ambas definen tipos, pero tienen diferencias importantes.

===== Sintaxis Básica

[source,typescript]
----
// Type Alias
type Persona = {
  nombre: string;
  edad: number;
};

// Interfaz (equivalente)
interface Persona {
  nombre: string;
  edad: number;
}

// Uso (idéntico)
const juan: Persona = { nombre: "Juan", edad: 30 };
----

===== Diferencias Clave

|===
| Aspecto | Type Alias | Interface

| Sintaxis
| `type X = { ... }`
| `interface X { ... }`

| Extend/Herencia
| Intersection `&`
| `extends`

| Declaración múltiple
| ✗ No permitido (error)
| ✓ Se fusiona automáticamente

| Uniones
| ✓ `type X = A \| B`
| ✗ No puede hacer uniones

| Primitivos
| ✓ `type ID = string \| number`
| ✗ Solo objetos

| Tuplas
| ✓ `type Par = [string, number]`
| ✗ No nativamente

| Métodos
| ✓ Se puede
| ✓ Se puede

| Performance
| Más rápido (compilación)
| Ligeramente más lento
|===

===== Type Aliases para Todo

Los type aliases son más flexibles.

[source,typescript]
----
// Type alias para primitivos
type ID = string | number;
type Usuario = { nome: string; id: ID };
type Respuesta = "ok" | "error";
type Numero = number;

// Funciona con todo
const id1: ID = "usr_123";
const id2: ID = 456;

const respuesta: Respuesta = "ok";

// Union types
type Resultado = { exito: true; datos: string } | { exito: false; error: string };

const r1: Resultado = { exito: true, datos: "éxito" };
const r2: Resultado = { exito: false, error: "falló" };
----

===== Interfaz para OOP

Las interfaces son mejores para definir contratos en clases.

[source,typescript]
----
// Interface como contrato
interface Empleado {
  id: number;
  nombre: string;
  calcularSalario(): number;
}

// Una clase implementa el contrato
class EmpleadoTiempoCompleto implements Empleado {
  id: number;
  nombre: string;
  horas: number = 40;

  constructor(id: number, nombre: string) {
    this.id = id;
    this.nombre = nombre;
  }

  calcularSalario(): number {
    return this.horas * 50;  // $50/hora
  }
}

class EmpleadoMedioTiempo implements Empleado {
  id: number;
  nombre: string;
  horas: number = 20;

  constructor(id: number, nombre: string) {
    this.id = id;
    this.nombre = nombre;
  }

  calcularSalario(): number {
    return this.horas * 60;  // $60/hora (menos horas, más paga)
  }
}

// Usar ambos como Empleado
function procesarPagos(empleados: Empleado[]): void {
  empleados.forEach(emp => {
    console.log(`${emp.nombre}: $${emp.calcularSalario()}`);
  });
}

const equipo: Empleado[] = [
  new EmpleadoTiempoCompleto(1, "Juan"),
  new EmpleadoMedioTiempo(2, "María")
];

procesarPagos(equipo);
----

===== Extensión/Herencia

[source,typescript]
----
// Type alias: usar &
type Animal = { nombre: string };
type Perro = Animal & { raza: string };

// Interfaz: usar extends
interface Animal {
  nombre: string;
}

interface Perro extends Animal {
  raza: string;
}

// Ambas funcionan igual para objetos
const perro: Perro = { nombre: "Rex", raza: "Labrador" };
----

===== Cuándo Usar Cada Uno

|===
| Situación | Usar

| Contrato para clases
| Interface

| Tipos compuestos/complejos
| Type alias

| Union types
| Type alias

| Extender desde múltiples fuentes
| Interface (mejor documentación)

| Primitivos o tuplas
| Type alias

| Público/API de librería
| Interface
|===


==== 3.3 Tipos de Objetos Complejos

===== Objetos Anidados

[source,typescript]
----
interface Direccion {
  calle: string;
  ciudad: string;
  codigoPostal: string;
}

interface Usuario {
  nombre: string;
  email: string;
  direccion: Direccion;  // Tipo anidado
}

const usuario: Usuario = {
  nombre: "Ana García",
  email: "ana@example.com",
  direccion: {
    calle: "Calle Principal 123",
    ciudad: "Madrid",
    codigoPostal: "28001"
  }
};

// Acceder a propiedades anidadas
console.log(usuario.direccion.ciudad);  // "Madrid"
----

===== Arrays Tipados

[source,typescript]
----
interface Producto {
  id: number;
  nombre: string;
  precio: number;
}

// Array de productos
const productos: Producto[] = [
  { id: 1, nombre: "Laptop", precio: 999.99 },
  { id: 2, nombre: "Mouse", precio: 29.99 },
  { id: 3, nombre: "Teclado", precio: 79.99 }
];

// Métodos seguros
productos.forEach(p => {
  console.log(`${p.nombre}: $${p.precio}`);
});

// Filtrar
const caros = productos.filter(p => p.precio > 50);

// Mapear
const nombres = productos.map(p => p.nombre);
----

===== Tuplas

Arreglos con tipos conocidos en posiciones conocidas.

[source,typescript]
----
// Tupla: [nombre, edad]
type PersonaTupla = [string, number];

let juan: PersonaTupla = ["Juan", 30];     // ✓
let maria: PersonaTupla = ["María", 25];   // ✓
let carlos: PersonaTupla = [35, "Carlos"]; // ✗ Error: tipos invertidos

// Acceder por índice (con tipos)
let nombre: string = juan[0];  // ✓ Sabe que es string
let edad: number = juan[1];    // ✓ Sabe que es number

// Tuplas con nombre (más legible)
type Respuesta = [status: number, mensaje: string, exito: boolean];

const resp: Respuesta = [200, "OK", true];
console.log(resp[0]);  // 200
console.log(resp[1]);  // "OK"

// Tupla con cantidad variable
type StringNumberBooleans = [string, number, ...boolean[]];

const a: StringNumberBooleans = ["hello", 1];
const b: StringNumberBooleans = ["hello", 1, true];
const c: StringNumberBooleans = ["hello", 1, true, false, true];
----

===== Tipos Recursivos

Un tipo que se referencia a sí mismo.

[source,typescript]
----
// Estructura en árbol
interface NodoArbol {
  valor: number;
  izquierda?: NodoArbol;  // Puede contener otro NodoArbol
  derecha?: NodoArbol;
}

const arbol: NodoArbol = {
  valor: 1,
  izquierda: {
    valor: 2,
    izquierda: { valor: 4 },
    derecha: { valor: 5 }
  },
  derecha: {
    valor: 3,
    derecha: { valor: 6 }
  }
};

// Función recursiva para procesar
function sumarArbol(nodo?: NodoArbol): number {
  if (!nodo) return 0;
  return nodo.valor + sumarArbol(nodo.izquierda) + sumarArbol(nodo.derecha);
}

console.log(sumarArbol(arbol));  // 1+2+4+5+3+6 = 21
----


==== 3.4 Tipos Genéricos Básicos

Los **genéricos** permiten crear tipos reutilizables que funcionan con cualquier tipo.

===== Genéricos Simples

[source,typescript]
----
// Función genérica: <T> es un "parámetro de tipo"
function devuelveValor<T>(valor: T): T {
  return valor;
}

// TypeScript infiere el tipo automáticamente
const num = devuelveValor(42);          // T = number
const str = devuelveValor("hola");      // T = string
const bool = devuelveValor(true);       // T = boolean

// O especificar explícitamente
const explicito = devuelveValor<number>(100);

// Función que funciona con arrays
function primerElemento<T>(arr: T[]): T | undefined {
  return arr[0];
}

const numeros = [1, 2, 3];
const primero = primerElemento(numeros);  // T = number

const palabras = ["hola", "mundo"];
const primeraPalabra = primerElemento(palabras);  // T = string
----

===== Genéricos en Interfaces

[source,typescript]
----
// Interfaz genérica
interface Contenedor<T> {
  valor: T;
  obtener(): T;
  establecer(valor: T): void;
}

// Implementación para string
const contenedorString: Contenedor<string> = {
  valor: "Hola",
  obtener: function() { return this.valor; },
  establecer: function(valor) { this.valor = valor; }
};

// Implementación para número
const contenedorNumero: Contenedor<number> = {
  valor: 42,
  obtener: function() { return this.valor; },
  establecer: function(valor) { this.valor = valor; }
};

console.log(contenedorString.obtener());  // "Hola"
console.log(contenedorNumero.obtener());  // 42
----

===== Genéricos en Type Aliases

[source,typescript]
----
// Type alias genérico
type Respuesta<T> = {
  exito: boolean;
  datos?: T;
  error?: string;
};

// Usar con diferentes tipos
type RespuestaUsuario = Respuesta<{ nombre: string; id: number }>;
type RespuestaString = Respuesta<string>;
type RespuestaNumero = Respuesta<number>;

const resp1: RespuestaUsuario = {
  exito: true,
  datos: { nombre: "Juan", id: 1 }
};

const resp2: RespuestaString = {
  exito: false,
  error: "No encontrado"
};

// Genérico para API response
type ApiResponse<T> = {
  status: number;
  payload: T;
  timestamp: Date;
};

const usuarioResponse: ApiResponse<{ nombre: string }> = {
  status: 200,
  payload: { nombre: "María" },
  timestamp: new Date()
};
----

===== Restricciones de Genéricos (Básico)

Limitar qué tipos pueden usarse.

[source,typescript]
----
// Solo permite tipos que tengan propiedad .length
function longitud<T extends { length: number }>(valor: T): number {
  return valor.length;
}

longitud("Hola");        // ✓ string tiene .length
longitud([1, 2, 3]);     // ✓ array tiene .length
longitud({ length: 5 }); // ✓ objeto con length
longitud(42);            // ✗ Error: number no tiene .length

// Restricción a tipos específicos
function obtenerPropiedad<T extends { nombre: string }>(obj: T): string {
  return obj.nombre;
}

obtenerPropiedad({ nombre: "Juan", edad: 30 });  // ✓
obtenerPropiedad({ nombre: "María" });           // ✓
obtenerPropiedad({ edad: 25 });                  // ✗ Error: falta nombre
----

===== Ejemplo Práctico: Lista Genérica

[source,typescript]
----
// Estructura reutilizable para cualquier tipo
interface ListaElementos<T> {
  elementos: T[];
  agregar(elemento: T): void;
  obtener(indice: number): T | undefined;
  obtenerTodos(): T[];
  cantidad(): number;
}

// Implementación
class Lista<T> implements ListaElementos<T> {
  elementos: T[] = [];

  agregar(elemento: T): void {
    this.elementos.push(elemento);
  }

  obtener(indice: number): T | undefined {
    return this.elementos[indice];
  }

  obtenerTodos(): T[] {
    return [...this.elementos];
  }

  cantidad(): number {
    return this.elementos.length;
  }
}

// Usar para números
const listaNumeros = new Lista<number>();
listaNumeros.agregar(10);
listaNumeros.agregar(20);
listaNumeros.agregar(30);

console.log(listaNumeros.obtener(1));    // 20
console.log(listaNumeros.cantidad());    // 3

// Usar para strings
const listaTextos = new Lista<string>();
listaTextos.agregar("Hola");
listaTextos.agregar("Mundo");

console.log(listaTextos.obtener(0));     // "Hola"
----

===== Ejercicios Propuestos

.1. Crear interfaz para producto con descuento:
[source,typescript]
----
// Crear interfaz Producto con propiedades:
// id, nombre, precio, descuentoPorcentaje (opcional)
// Y método para calcular precio final
----

.2. Comparar Type Alias vs Interfaz:
[source,typescript]
----
// Crear una definición de Usuario con type alias
// Crear la misma con interfaz
// Notar diferencias en como se extienden
----

.3. Tipo complejo anidado:
[source,typescript]
----
// Crear tipo para Empresa con:
// nombre, sector, empleados (array de Usuario)
// Cada Usuario tiene: nombre, cargo, contacto { email, telefono }
----

.4. Genérico para paginación:
[source,typescript]
----
// Crear tipo genérico Pagina<T> con:
// items: T[]
// pagina: number
// total: number
// Crear instancias para números y strings
----


=== Módulo 4: Funciones en TypeScript

Este módulo se enfoca en dominar el tipado de funciones. Aprenderás cómo tipar parámetros, valores de retorno, usar parámetros especiales y sobrecarga de funciones para escribir código robusto y predecible.

==== 4.1 Tipado de Parámetros y Retorno

===== Parámetros Tipados

Especificar el tipo de cada parámetro.

[source,typescript]
----
// Función básica con tipos
function saludar(nombre: string, edad: number): void {
  console.log(`Hola ${nombre}, tienes ${edad} años`);
}

saludar("Juan", 30);      // ✓ Correcto
saludar("María");         // ✗ Error: falta parámetro edad
saludar(25, "Pedro");     // ✗ Error: tipos invertidos

// Función que retorna valor
function sumar(a: number, b: number): number {
  return a + b;
}

const resultado: number = sumar(5, 10);  // 15

// Función con tipos complejos
interface Usuario {
  nombre: string;
  email: string;
}

function enviarEmail(usuario: Usuario, asunto: string): boolean {
  console.log(`Enviando email a ${usuario.email}`);
  return true;
}

const juan: Usuario = { nombre: "Juan", email: "juan@example.com" };
enviarEmail(juan, "Bienvenido");
----

===== Tipo de Retorno Void

Para funciones que no retornan nada.

[source,typescript]
----
// Función que no retorna valor (solo efecto secundario)
function mostrarMensaje(msg: string): void {
  console.log(msg);
  // No hay return (o return sin valor)
}

mostrarMensaje("Hola");  // ✓

// Esto causaría error:
function conError(msg: string): void {
  console.log(msg);
  return 42;  // ✗ Error: 42 is not assignable to type void
}
----

===== Retorno Implícito vs Explícito

[source,typescript]
----
// TypeScript infiere el retorno automáticamente
function multiplicar(a: number, b: number) {
  return a * b;  // Infiere: number
}

// Mejor ser explícito para funciones públicas
function dividir(a: number, b: number): number {
  if (b === 0) throw new Error("División por cero");
  return a / b;
}

// Retorno condicional (útil cuando hay múltiples caminos)
function obtenerEstado(edad: number): string {
  if (edad < 18) return "Menor";
  if (edad < 65) return "Adulto";
  return "Jubilado";
}
----

===== Funciones que Retornan Tipos Complejos

[source,typescript]
----
// Retornar interfaz
interface Resultado {
  exito: boolean;
  mensaje: string;
  datos?: any;
}

function procesarDatos(entrada: string): Resultado {
  if (!entrada) {
    return { exito: false, mensaje: "Entrada vacía" };
  }
  return {
    exito: true,
    mensaje: "Procesado",
    datos: entrada.toUpperCase()
  };
}

// Retornar union type
function obtenerValor(tipo: string): number | string | null {
  switch (tipo) {
    case "numero":
      return 42;
    case "texto":
      return "Hola";
    case "nada":
      return null;
    default:
      throw new Error("Tipo desconocido");
  }
}

// Retornar array
function obtenerNumerosPositivos(arr: number[]): number[] {
  return arr.filter(n => n > 0);
}

// Retornar función (higher-order function)
function crearMultiplicador(factor: number): (n: number) => number {
  return (n: number) => n * factor;
}

const por2 = crearMultiplicador(2);
console.log(por2(5));  // 10
----


==== 4.2 Parámetros Opcionales y por Defecto

===== Parámetros Opcionales

Usar `?` para parámetros que pueden omitirse.

[source,typescript]
----
// Parámetro opcional
function saludarPersonalizado(nombre: string, titulo?: string): string {
  if (titulo) {
    return `Hola ${titulo} ${nombre}`;
  }
  return `Hola ${nombre}`;
}

console.log(saludarPersonalizado("Juan"));           // "Hola Juan"
console.log(saludarPersonalizado("María", "Lic."));  // "Hola Lic. María"

// Múltiples opcionales
interface ConfiguracionAPI {
  host: string;
  puerto?: number;
  ssl?: boolean;
  timeout?: number;
}

function conectarAPI(config: ConfiguracionAPI): void {
  const puerto = config.puerto || 3000;
  const ssl = config.ssl || false;
  const timeout = config.timeout || 5000;
  
  console.log(`Conectando a ${config.host}:${puerto}`);
  console.log(`SSL: ${ssl}, Timeout: ${timeout}ms`);
}

conectarAPI({ host: "api.example.com" });
conectarAPI({ host: "api.example.com", puerto: 8080, ssl: true });
----

⚠️ **Importante**: Los parámetros opcionales deben venir al final, después de los obligatorios.

[source,typescript]
----
// ✓ Correcto
function foo(obligatorio: string, opcional?: number) {}

// ✗ Error: parámetro obligatorio después de opcional
function bar(opcional?: number, obligatorio: string) {}
----

===== Parámetros con Valor Defecto

Proporcionar un valor cuando no se pasa el parámetro.

[source,typescript]
----
// Valor por defecto
function saludar(nombre: string, saludo: string = "Hola") {
  return `${saludo} ${nombre}`;
}

console.log(saludar("Juan"));              // "Hola Juan"
console.log(saludar("María", "Buenos días")); // "Buenos días María"

// Parámetro por defecto puede ser valor dinámico
function construirURL(host: string, puerto: number = 80, https: boolean = false): string {
  const protocolo = https ? "https" : "http";
  return `${protocolo}://${host}:${puerto}`;
}

console.log(construirURL("localhost"));                    // "http://localhost:80"
console.log(construirURL("api.example.com", 443, true));  // "https://api.example.com:443"

// Valores por defecto complejos
interface Opciones {
  enabled?: boolean;
  retries?: number;
}

function procesarConOpciones(datos: string, opciones: Opciones = {}): void {
  const enabled = opciones.enabled ?? true;
  const retries = opciones.retries ?? 3;
  
  console.log(`Procesando "${datos}" - Enabled: ${enabled}, Retries: ${retries}`);
}

procesarConOpciones("test1");
procesarConOpciones("test2", { enabled: false, retries: 5 });
----

===== Diferencia: Opcional vs Por Defecto

|===
| Aspecto | Opcional (?) | Por Defecto (=)

| Si se omite
| `undefined`
| Valor especificado

| Tipado
| `string \| undefined`
| `string`

| Pasar undefined
| Permitido
| Reemplazado por defecto

| Documentación
| "Puede faltar"
| "Tiene valor por defecto"
|===


==== 4.3 Rest Parameters y Spread Operator

===== Rest Parameters

Aceptar número variable de parámetros.

[source,typescript]
----
// Rest parameter: ...numeros captura todo en array
function sumarTodos(...numeros: number[]): number {
  return numeros.reduce((suma, n) => suma + n, 0);
}

console.log(sumarTodos(1, 2, 3));           // 6
console.log(sumarTodos(10, 20, 30, 40));    // 100
console.log(sumarTodos());                  // 0 (array vacío)

// Rest parameter con otros parámetros
function imprimirDatos(prefijo: string, ...items: string[]): void {
  console.log(`${prefijo}:`);
  items.forEach(item => console.log(`  - ${item}`));
}

imprimirDatos("Frutas", "Manzana", "Banana", "Naranja");
// Output:
// Frutas:
//   - Manzana
//   - Banana
//   - Naranja

// Rest parameter con tipos complejos
interface Usuario {
  nombre: string;
}

function mostrarUsuarios(...usuarios: Usuario[]): void {
  usuarios.forEach(u => console.log(`Usuario: ${u.nombre}`));
}

mostrarUsuarios(
  { nombre: "Juan" },
  { nombre: "María" },
  { nombre: "Carlos" }
);

// Rest con tipos variados (usando overload o union)
function registrarEventos(evento: string, ...datos: any[]): void {
  console.log(`[${evento}]`, ...datos);
}

registrarEventos("ERROR", "Algo salió mal", { code: 500 });
----

⚠️ **Rest parámetro debe ser el último**.

[source,typescript]
----
// ✓ Correcto
function foo(primero: string, ...resto: number[]) {}

// ✗ Error: rest parámetro no es el último
function bar(...resto: string[], ultimo: number) {}
----

===== Spread Operator

Expandir un array en parámetros individuales.

[source,typescript]
----
// Spread en función call
function sumar(a: number, b: number, c: number): number {
  return a + b + c;
}

const numeros: [number, number, number] = [1, 2, 3];
console.log(sumar(...numeros));  // 6

// Spread en arrays
const grupo1: number[] = [1, 2, 3];
const grupo2: number[] = [4, 5, 6];
const combinado: number[] = [...grupo1, ...grupo2];  // [1,2,3,4,5,6]

// Spread en objetos
interface Persona {
  nombre: string;
  edad: number;
}

const personaBase: Persona = { nombre: "Juan", edad: 30 };
const personaCompleta = {
  ...personaBase,
  edad: 31,           // Sobrescribe edad
  ciudad: "Madrid"    // Agrega propiedad nueva
};
// { nombre: "Juan", edad: 31, ciudad: "Madrid" }

// Spread para copias seguras
const original = { x: 1, y: 2 };
const copia = { ...original };  // Nueva instancia, no referencia
copia.x = 999;
console.log(original.x);  // 1 (sin cambios)
console.log(copia.x);     // 999
----

===== Combinación: Rest + Spread

[source,typescript]
----
function procesarNumeros(primero: number, ...resto: number[]): number[] {
  return [primero * 2, ...resto.map(n => n * 2)];
}

const resultado = procesarNumeros(5, 10, 15);
console.log(resultado);  // [10, 20, 30]

// Función que transforma todos los parámetros
function convertirAMayusculas(...textos: string[]): string[] {
  return textos.map(t => t.toUpperCase());
}

const resultado2 = convertirAMayusculas("hola", "mundo", "typescript");
console.log(resultado2);  // ["HOLA", "MUNDO", "TYPESCRIPT"]

// Usar spread para pasar array como argumentos
const palabras = ["javascript", "typescript", "nodejs"];
console.log(...convertirAMayusculas(...palabras));
// JAVASCRIPT TYPESCRIPT NODEJS
----


==== 4.4 Sobrecarga de Funciones (Function Overloading)

Definir múltiples firmas para la misma función con diferentes parámetros.

===== Sintaxis Básica

[source,typescript]
----
// Firmas de sobrecarga (sin implementación)
function procesar(valor: string): string;
function procesar(valor: number): number;
function procesar(valor: boolean): boolean;

// Implementación (acepta cualquiera de los tipos anteriores)
function procesar(valor: string | number | boolean): string | number | boolean {
  if (typeof valor === 'string') {
    return valor.toUpperCase();
  }
  if (typeof valor === 'number') {
    return valor * 2;
  }
  return !valor;
}

console.log(procesar("hola"));    // "HOLA" (string)
console.log(procesar(5));         // 10 (number)
console.log(procesar(true));      // false (boolean)
----

===== Sobrecarga con Parámetros Variables

[source,typescript]
----
// Versión 1: solo string
function crear(nombre: string): string;

// Versión 2: string + edad
function crear(nombre: string, edad: number): { nombre: string; edad: number };

// Versión 3: string + edad + ciudad
function crear(nombre: string, edad: number, ciudad: string): 
  { nombre: string; edad: number; ciudad: string };

// Implementación
function crear(nombre: string, edad?: number, ciudad?: string): any {
  if (!edad && !ciudad) {
    return nombre;
  }
  if (edad && !ciudad) {
    return { nombre, edad };
  }
  return { nombre, edad, ciudad };
}

const r1 = crear("Juan");                              // "Juan"
const r2 = crear("María", 25);                         // { nombre: "María", edad: 25 }
const r3 = crear("Carlos", 30, "Madrid");              // { nombre: "Carlos", edad: 30, ciudad: "Madrid" }
----

===== Sobrecarga Real-World

[source,typescript]
----
// Desde una API o librería: múltiples formas de usar
interface FiltroOpciones {
  ascending?: boolean;
  limit?: number;
}

// Filtrar sin opciones
function filtrar(datos: number[]): number[];

// Filtrar con opciones
function filtrar(datos: number[], opciones: FiltroOpciones): number[];

// Filtrar con función de predicado
function filtrar(datos: number[], predicado: (n: number) => boolean): number[];

// Implementación
function filtrar(
  datos: number[],
  opcionesOpredicado?: FiltroOpciones | ((n: number) => boolean)
): number[] {
  let resultado = datos;
  
  // Si es función (predicado)
  if (typeof opcionesOpredicado === 'function') {
    resultado = resultado.filter(opcionesOpredicado);
  }
  // Si es objeto (opciones)
  else if (opcionesOpredicado) {
    if (opcionesOpredicado.limit) {
      resultado = resultado.slice(0, opcionesOpredicado.limit);
    }
    if (opcionesOpredicado.ascending === false) {
      resultado = resultado.sort((a, b) => b - a);
    }
  }
  
  return resultado;
}

// Uso múltiple
const numeros = [3, 1, 4, 1, 5, 9];

console.log(filtrar(numeros));                                    // [3, 1, 4, 1, 5, 9]
console.log(filtrar(numeros, { ascending: false, limit: 3 }));   // [9, 5, 4]
console.log(filtrar(numeros, n => n > 2));                       // [3, 4, 5, 9]
----

===== Sobrecarga con Genéricos

[source,typescript]
----
// Función genérica con sobrecarga
function obtenerPrimero<T>(arr: T[]): T;
function obtenerPrimero<T>(arr: T[], indice: number): T | undefined;

function obtenerPrimero<T>(arr: T[], indice: number = 0): T | undefined {
  return arr[indice];
}

const numeros = [1, 2, 3];
const primero: number = obtenerPrimero(numeros);      // Type safe
const segundo: number | undefined = obtenerPrimero(numeros, 1);

const palabras = ["a", "b", "c"];
const primera: string = obtenerPrimero(palabras);     // Type safe
----

===== Cambios Comunes en Sobrecarga

|===
| Caso | Firmas | Uso

| Parámetros variables
| Mismo tipo + cantidad variable
| Función con `...rest` o parámetros opcionales

| Tipos diferentes
| Tipos distintos para mismo parámetro
| Union types + type guards

| Retorno distinto
| Mismo parámetro → retorno diferente
| Discriminated unions

| Parámetros opcionales progresivos
| Progresivamente más parámetros
| Cada firma añade más parámetros
|===

===== Ejercicios Propuestos

.1. Función con tipado completo:
[source,typescript]
----
// Crear función buscarUsuario que:
// - Reciba id: number, campos?: string[]
// - Retorne Promise<Usuario | null>
// - Si no encuentra usuario, null
----

.2. Rest parameters:
[source,typescript]
----
// Crear función concatenar que:
// - Acepte múltiples strings
// - Los una con separador (por defecto " ")
// - Retorne string resultante
// Ej: concatenar("Hola", "mundo", "!") => "Hola mundo !"
----

.3. Función con sobrecarga:
[source,typescript]
----
// Crear función formatear con sobrecarga:
// formatear(número) => "1,234.56"
// formatear(fecha) => "24/02/2026"
// formatear(booleano) => "Sí" o "No"
----

.4. Spread operator:
[source,typescript]
----
// Crear función mezclar que:
// - Acepte dos arrays del mismo tipo
// - Los mezcle intercalando elementos
// - Ej: mezclar([1,2], [3,4]) => [1,3,2,4]
----


=== Módulo 5: POO en TypeScript - Clases y Herencia

La Programación Orientada a Objetos (POO) en TypeScript permite crear código bien estructurado, reutilizable y fácil de mantener. Este módulo cubre clases, propiedades, métodos y herencia con ejemplos prácticos.

==== 5.1 Definición y Uso de Clases

Una **clase** es un molde para crear objetos. Define propiedades y métodos que tendrán todas las instancias.

===== Clase Básica

[source,typescript]
----
// Definir una clase
class Persona {
  nombre: string;
  edad: number;

  constructor(nombre: string, edad: number) {
    this.nombre = nombre;
    this.edad = edad;
  }

  saludar(): void {
    console.log(`Hola, soy ${this.nombre} y tengo ${this.edad} años`);
  }
}

// Crear instancia (nuevo objeto)
const juan = new Persona("Juan", 30);
const maria = new Persona("María", 25);

// Usar propiedades y métodos
console.log(juan.nombre);   // "Juan"
console.log(maria.edad);    // 25
juan.saludar();             // "Hola, soy Juan y tengo 30 años"
----

===== Comparación: Clase vs Interfaz vs Type

|===
| Aspecto | Clase | Interfaz | Type

| Propósito
| Crear objetos + lógica
| Define contrato/forma
| Define forma + uniones

| Instancias
| `new Clase()`
| N/A (solo tipado)
| N/A (solo tipado)

| Métodos
| ✓ Con implementación
| ✓ Solo firmas
| ✓ Firmas

| Herencia
| `extends`
| `extends`
| `&` (intersection)

| Compilado
| Código JavaScript
| Se elimina en compilación
| Se elimina
|===

===== Estructura Completa

[source,typescript]
----
class Empleado {
  // Propiedades (campos)
  nombre: string;
  departamento: string;
  salario: number;

  // Constructor - se ejecuta al hacer new
  constructor(nombre: string, departamento: string, salario: number) {
    this.nombre = nombre;
    this.departamento = departamento;
    this.salario = salario;
  }

  // Métodos (funciones de la clase)
  obtenerInfo(): string {
    return `${this.nombre} de ${this.departamento}`;
  }

  modificarSalario(porcentaje: number): void {
    this.salario = this.salario * (1 + porcentaje / 100);
  }
}

// Uso
const empleado = new Empleado("Carlos", "IT", 3000);
console.log(empleado.obtenerInfo());     // "Carlos de IT"
empleado.modificarSalario(10);           // Aumenta 10%
console.log(empleado.salario);           // 3300
----


==== 5.2 Propiedades y Métodos

===== Propiedades Básicas

[source,typescript]
----
class Producto {
  nombre: string;
  precio: number;
  stock: number = 0;  // Valor por defecto

  constructor(nombre: string, precio: number) {
    this.nombre = nombre;
    this.precio = precio;
  }
}

const laptop = new Producto("Laptop", 999.99);
console.log(laptop.stock);  // 0 (valor por defecto)
laptop.stock = 5;
console.log(laptop.stock);  // 5
----

===== Propiedades Readonly

Propiedades que no pueden cambiar después de ser asignadas.

[source,typescript]
----
class Usuario {
  readonly id: number;
  nombre: string;

  constructor(id: number, nombre: string) {
    this.id = id;      // ✓ Se puede asignar en constructor
    this.nombre = nombre;
  }
}

const usuario = new Usuario(1, "Juan");
console.log(usuario.id);    // 1
usuario.nombre = "Carlos";  // ✓ OK
usuario.id = 999;           // ✗ Error: Cannot assign to readonly property 'id'
----

===== Métodos

[source,typescript]
----
class Calculadora {
  sumar(a: number, b: number): number {
    return a + b;
  }

  restar(a: number, b: number): number {
    return a - b;
  }

  multiplicar(a: number, b: number): number {
    return a * b;
  }

  dividir(a: number, b: number): number {
    if (b === 0) throw new Error("División por cero");
    return a / b;
  }
}

const calc = new Calculadora();
console.log(calc.sumar(10, 5));      // 15
console.log(calc.multiplicar(3, 4)); // 12
----

===== Métodos que Retornan this

Útil para encadenamiento (method chaining).

[source,typescript]
----
class Carrito {
  items: string[] = [];

  agregarItem(item: string): this {
    this.items.push(item);
    return this;  // Retorna la misma instancia
  }

  removerItem(item: string): this {
    this.items = this.items.filter(i => i !== item);
    return this;
  }

  obtenerTotal(): number {
    return this.items.length;
  }
}

// Encadenamiento (chaining)
const carrito = new Carrito();
carrito
  .agregarItem("Laptop")
  .agregarItem("Mouse")
  .agregarItem("Teclado")
  .removerItem("Mouse");

console.log(carrito.obtenerTotal());  // 2
console.log(carrito.items);           // ["Laptop", "Teclado"]
----

===== Métodos Estáticos

Pertenecen a la clase, no a instancias.

[source,typescript]
----
class Utilidades {
  // Método estático - se accede sin new
  static sumarTodos(...numeros: number[]): number {
    return numeros.reduce((a, b) => a + b, 0);
  }

  static generarID(): string {
    return Math.random().toString(36).substring(2, 9);
  }
}

// Usar sin crear instancia
console.log(Utilidades.sumarTodos(1, 2, 3, 4));  // 10
console.log(Utilidades.generarID());             // "3h4k8j2" (aleatorio)

// No se puede acceder desde instancia
const utils = new Utilidades();
utils.sumarTodos(1, 2);  // ✗ Error: no acceso
----

===== Propiedades Estáticas

[source,typescript]
----
class Contador {
  static total: number = 0;  // Compartido por todas instancias
  id: number;

  constructor() {
    Contador.total++;
    this.id = Contador.total;
  }
}

const c1 = new Contador();
const c2 = new Contador();
const c3 = new Contador();

console.log(c1.id);              // 1
console.log(c2.id);              // 2
console.log(Contador.total);     // 3 (acumula todas las instancias)
----


==== 5.3 Modificadores de Acceso

Controlan quién puede acceder a propiedades y métodos.

===== public (Público - Default)

Accesible desde cualquier lugar (dentro y fuera de la clase).

[source,typescript]
----
class Animal {
  public nombre: string;  // Explícito (default es public)
  sonido: string;         // Implícitamente public

  constructor(nombre: string, sonido: string) {
    this.nombre = nombre;
    this.sonido = sonido;
  }

  public hablar(): void {
    console.log(`${this.nombre} hace ${this.sonido}`);
  }
}

const perro = new Animal("Rex", "Guau");
console.log(perro.nombre);   // ✓ Acceso desde fuera
perro.hablar();              // ✓ Método accesible
----

===== private (Privado)

Solo accesible dentro de la clase.

[source,typescript]
----
class CuentaBancaria {
  titular: string;
  private saldo: number;  // Solo dentro de la clase

  constructor(titular: string, saldoInicial: number) {
    this.titular = titular;
    this.saldo = saldoInicial;
  }

  depositar(cantidad: number): void {
    this.saldo += cantidad;  // ✓ Acceso interno
    console.log(`Depositado ${cantidad}. Saldo: ${this.saldo}`);
  }

  private calcularInteres(): number {
    return this.saldo * 0.05;  // ✓ Método privado
  }

  obtenerSaldoConInteres(): number {
    return this.saldo + this.calcularInteres();
  }
}

const cuenta = new CuentaBancaria("Juan", 1000);
cuenta.depositar(500);              // ✓ OK
console.log(cuenta.saldo);          // ✗ Error: private
cuenta.calcularInteres();           // ✗ Error: private
console.log(cuenta.obtenerSaldoConInteres());  // ✓ OK (usa método público)
----

===== protected (Protegido)

Accesible dentro de la clase y clases que heredan.

[source,typescript]
----
class Animal {
  protected nombre: string;     // Accesible en subclases
  private energia: number;      // Solo en esta clase

  constructor(nombre: string) {
    this.nombre = nombre;
    this.energia = 100;
  }

  protected moverse(): void {
    this.energia -= 10;
    console.log(`${this.nombre} se mueve`);
  }
}

class Perro extends Animal {
  traerObjeto(): void {
    console.log(`${this.nombre} trae el objeto`);  // ✓ protected accesible
    this.moverse();                                 // ✓ protected method
  }

  mostrarEnergia(): void {
    console.log(this.energia);  // ✗ Error: private en clase padre
  }
}

const perro = new Perro("Rex");
perro.traerObjeto();           // ✓ public
console.log(perro.nombre);     // ✗ Error: protected no desde fuera
----

===== Comparativa de Modificadores

|===
| Nivel | public | protected | private

| Dentro de la clase
| ✓
| ✓
| ✓

| Clases heredadas
| ✓
| ✓
| ✗

| Fuera de la clase
| ✓
| ✗
| ✗

| Uso común
| Interfaz pública
| Compartir con subclases
| Detalles internos
|===


==== 5.4 Constructores y Getters/Setters

===== Constructor

Se ejecuta cuando se crea una instancia con `new`.

[source,typescript]
----
class Persona {
  nombre: string;
  edad: number;

  // Constructor (se ejecuta automáticamente)
  constructor(nombre: string, edad: number) {
    this.nombre = nombre;
    this.edad = edad;
    console.log(`Se creó la persona: ${nombre}`);
  }
}

const juan = new Persona("Juan", 30);  // Imprime: "Se creó la persona: Juan"

// Constructor sin parámetros
class Objeto {
  id: string;

  constructor() {
    this.id = Math.random().toString(36).substring(2, 9);
  }
}

const obj = new Objeto();
console.log(obj.id);  // ID aleatorio único
----

===== Sintaxis Abreviada del Constructor

Parameter properties - declara y asigna en una línea.

[source,typescript]
----
// Forma larga (tradicional)
class PersonaLarga {
  nombre: string;
  edad: number;
  email: string;

  constructor(nombre: string, edad: number, email: string) {
    this.nombre = nombre;
    this.edad = edad;
    this.email = email;
  }
}

// Forma corta (parameter properties)
class PersonaCorta {
  constructor(
    public nombre: string,
    public edad: number,
    public email: string
  ) {}
}

// Ambas funcionan igual
const p1 = new PersonaLarga("Juan", 30, "juan@example.com");
const p2 = new PersonaCorta("María", 25, "maria@example.com");

console.log(p1.nombre);  // "Juan"
console.log(p2.email);   // "maria@example.com"

// Con modificadores
class Usuario {
  constructor(
    public id: number,
    public nombre: string,
    protected email: string,
    private contraseña: string
  ) {}
}

const usuario = new Usuario(1, "Carlos", "carlos@example.com", "secret123");
console.log(usuario.nombre);        // ✓ public
console.log(usuario.email);         // ✗ protected
console.log(usuario.contraseña);    // ✗ private
----

===== Getters

Métodos que parecen propiedades pero ejecutan lógica.

[source,typescript]
----
class Rectangulo {
  private ancho: number;
  private alto: number;

  constructor(ancho: number, alto: number) {
    this.ancho = ancho;
    this.alto = alto;
  }

  // Getter - se accede sin ()
  get area(): number {
    return this.ancho * this.alto;
  }

  get perimetro(): number {
    return 2 * (this.ancho + this.alto);
  }

  // Parecen propiedades pero calculan
  get esCuadrado(): boolean {
    return this.ancho === this.alto;
  }
}

const rect = new Rectangulo(10, 5);
console.log(rect.area);        // 50 (no es método, sin parentesis)
console.log(rect.perimetro);   // 30
console.log(rect.esCuadrado);  // false

// Acceso a privados a través de getters
const cuadrado = new Rectangulo(5, 5);
console.log(cuadrado.esCuadrado);  // true
// console.log(cuadrado.ancho);     // ✗ Error: private
----

===== Setters

Métodos para establecer valores con validación.

[source,typescript]
----
class CuentaBancaria {
  private _saldo: number;  // Convención: _ para propiedades privadas

  constructor(saldoInicial: number) {
    this._saldo = saldoInicial;
  }

  // Getter
  get saldo(): number {
    return this._saldo;
  }

  // Setter con validación
  set saldo(cantidad: number) {
    if (cantidad < 0) {
      throw new Error("El saldo no puede ser negativo");
    }
    this._saldo = cantidad;
  }

  // Método para depositar (usa setter internamente)
  depositar(cantidad: number): void {
    this.saldo = this._saldo + cantidad;  // Valida a través del setter
  }
}

const cuenta = new CuentaBancaria(1000);
console.log(cuenta.saldo);    // 1000 (getter)
cuenta.saldo = 1500;          // ✓ setter con validación
cuenta.depositar(200);        // ✓ 1700
cuenta.saldo = -100;          // ✗ Error: El saldo no puede ser negativo
----

===== Getters y Setters Prácticos

[source,typescript]
----
class Producto {
  private _nombre: string;
  private _precio: number;
  private _stock: number = 0;

  constructor(nombre: string, precio: number) {
    this._nombre = nombre;
    this._precio = precio;
  }

  get nombre(): string {
    return this._nombre;
  }

  set nombre(nuevoNombre: string) {
    if (!nuevoNombre.trim()) {
      throw new Error("El nombre no puede estar vacío");
    }
    this._nombre = nuevoNombre;
  }

  get precio(): number {
    return this._precio;
  }

  set precio(nuevoPrecio: number) {
    if (nuevoPrecio < 0) {
      throw new Error("El precio no puede ser negativo");
    }
    this._precio = nuevoPrecio;
  }

  get stock(): number {
    return this._stock;
  }

  set stock(cantidad: number) {
    if (cantidad < 0) {
      throw new Error("El stock no puede ser negativo");
    }
    this._stock = cantidad;
  }

  get disponible(): boolean {
    return this._stock > 0;
  }
}

const laptop = new Producto("Laptop", 999.99);
laptop.stock = 5;
console.log(`${laptop.nombre} - $${laptop.precio} - ${laptop.disponible}`);  // Usa getters
laptop.precio = 899.99;  // Usa setter con validación
laptop.stock = -10;      // ✗ Error
----


==== 5.5 Herencia y Polimorfismo

===== Herencia Básica

Una clase puede heredar de otra usando `extends`.

[source,typescript]
----
// Clase base (padre)
class Animal {
  nombre: string;

  constructor(nombre: string) {
    this.nombre = nombre;
  }

  hablar(): void {
    console.log(`${this.nombre} hace un sonido`);
  }

  dormir(): void {
    console.log(`${this.nombre} está durmiendo`);
  }
}

// Clase derivada (hija)
class Perro extends Animal {
  raza: string;

  constructor(nombre: string, raza: string) {
    super(nombre);  // Llama al constructor del padre
    this.raza = raza;
  }

  // Sobrescribe el método del padre
  hablar(): void {
    console.log(`${this.nombre} ladra: ¡Guau guau!`);
  }

  traer(): void {
    console.log(`${this.nombre} trae la pelota`);
  }
}

const perro = new Perro("Rex", "Labrador");
perro.hablar();   // "Rex ladra: ¡Guau guau!" (método sobrescrito)
perro.dormir();   // "Rex está durmiendo" (heredado)
perro.traer();    // "Rex trae la pelota" (método nuevo)
console.log(perro.nombre);  // "Rex" (propiedad heredada)
console.log(perro.raza);    // "Labrador" (propiedad nueva)
----

===== super - Acceso a la Clase Padre

[source,typescript]
----
class Vehiculo {
  marca: string;
  modelo: string;

  constructor(marca: string, modelo: string) {
    this.marca = marca;
    this.modelo = modelo;
  }

  especificaciones(): string {
    return `${this.marca} ${this.modelo}`;
  }

  arrancar(): void {
    console.log("Vehículo iniciando...");
  }
}

class Auto extends Vehiculo {
  puertas: number;

  constructor(marca: string, modelo: string, puertas: number) {
    super(marca, modelo);  // Llama constructor del padre
    this.puertas = puertas;
  }

  // Amplía el método del padre
  arrancar(): void {
    super.arrancar();                    // Usa método del padre
    console.log("Auto listo para conducir");
  }

  especificaciones(): string {
    return `${super.especificaciones()}, ${this.puertas} puertas`;
  }
}

const auto = new Auto("Toyota", "Corolla", 4);
auto.arrancar();                        // Usa super.arrancar()
console.log(auto.especificaciones());   // Usa super.especificaciones()
----

===== Polimorfismo

Diferentes clases responden al mismo método de forma diferente.

[source,typescript]
----
class Animal {
  nombre: string;

  constructor(nombre: string) {
    this.nombre = nombre;
  }

  hacerSonido(): string {
    return "Sonido genérico";
  }
}

class Perro extends Animal {
  hacerSonido(): string {
    return "¡Guau!";
  }
}

class Gato extends Animal {
  hacerSonido(): string {
    return "¡Miau!";
  }
}

class Pajaro extends Animal {
  hacerSonido(): string {
    return "¡Pío pío!";
  }
}

// Polimorfismo: mismo método, diferentes implementaciones
function hacerAnimalBablear(animal: Animal): void {
  console.log(`${animal.nombre}: ${animal.hacerSonido()}`);
}

const animales: Animal[] = [
  new Perro("Rex"),
  new Gato("Whiskers"),
  new Pajaro("Tweety")
];

animales.forEach(a => hacerAnimalBablear(a));
// Output:
// Rex: ¡Guau!
// Whiskers: ¡Miau!
// Tweety: ¡Pío pío!

// El método llamado depende del tipo real de la instancia
----

===== Herencia Múltiple con Interfaces

TypeScript no permite herencia múltiple de clases, pero sí de interfaces.

[source,typescript]
----
// No es posible esto:
class Problematico extends Clase1, Clase2 {}  // ✗ Error

// Pero sí esto:
interface Audible {
  reproducir(): void;
}

interface Visual {
  mostrar(): void;
}

class Multimedia implements Audible, Visual {
  reproducir(): void {
    console.log("Reproduciendo audio...");
  }

  mostrar(): void {
    console.log("Mostrando video...");
  }
}

const media = new Multimedia();
media.reproducir();  // ✓
media.mostrar();     // ✓
----

===== instanceof - Verificar Tipo

[source,typescript]
----
class Shape {
  area(): number {
    return 0;
  }
}

class Circulo extends Shape {
  radio: number;

  constructor(radio: number) {
    super();
    this.radio = radio;
  }

  area(): number {
    return Math.PI * this.radio * this.radio;
  }
}

class Rectangulo extends Shape {
  ancho: number;
  alto: number;

  constructor(ancho: number, alto: number) {
    super();
    this.ancho = ancho;
    this.alto = alto;
  }

  area(): number {
    return this.ancho * this.alto;
  }
}

function procesarForma(forma: Shape): void {
  if (forma instanceof Circulo) {
    console.log(`Círculo con radio ${forma.radio}`);
  } else if (forma instanceof Rectangulo) {
    console.log(`Rectángulo ${forma.ancho}x${forma.alto}`);
  }
  console.log(`Área: ${forma.area()}`);
}

const circulo = new Circulo(5);
const rectangulo = new Rectangulo(10, 5);

procesarForma(circulo);     // Círculo con radio 5, Área: 78.53...
procesarForma(rectangulo);  // Rectángulo 10x5, Área: 50
----

===== Ejercicios Propuestos

.1. Crear clase con privados y getters:
[source,typescript]
----
// Crear clase Usuario con:
// - nombre (privado)
// - email (privado)
// - edad (privado)
// getter para ver nombre
// setter para cambiar email con validación (@)
----

.2. Herencia y polimorfismo:
[source,typescript]
----
// Crear clase Persona
// Crear clases Estudiante y Profesor que extiendan Persona
// Cada una implementa método diferente describir()
// Usar polimorfismo para usar ambas con mismo método
----

.3. Constructor y super:
[source,typescript]
----
// Crear clase Vehiculo con marca, modelo, año
// Crear clase Motocicleta que extienda Vehiculo
// Usa super() en constructor
// Agrega propiedad cilindrada
----

.4. Métodos estáticos:
[source,typescript]
----
// Crear clase Producto con método estático generarID()
// Cada instancia usa ese método para auto-generar su id
// Crear 3 productos y mostrar sus IDs únicos
----


=== Módulo 6: Interfaces y Tipos Abstractos

Este módulo se enfoca en crear abstracciones y contratos en TypeScript. Aprenderás clases abstractas, cómo implementar interfaces en clases y cómo diseñar código flexible y reutilizable.

==== 6.1 Clases Abstractas

Una **clase abstracta** es una clase que no puede instanciarse directamente. Se usa como base para otras clases.

===== Definición Básica

[source,typescript]
----
// Clase abstracta - no se puede hacer new
abstract class Animal {
  nombre: string;

  constructor(nombre: string) {
    this.nombre = nombre;
  }

  // Método normal (implementado)
  dormir(): void {
    console.log(`${this.nombre} está durmiendo`);
  }

  // Método abstracto (sin implementación)
  abstract hacerSonido(): void;
}

// ✗ Error: No se puede instanciar clase abstracta
// const animal = new Animal("Genérico");

// ✓ Clases derivadas SÍ se pueden instanciar
class Perro extends Animal {
  // Debe implementar el método abstracto
  hacerSonido(): void {
    console.log(`${this.nombre} ladra: Guau`);
  }
}

class Gato extends Animal {
  // Debe implementar el método abstracto
  hacerSonido(): void {
    console.log(`${this.nombre} maúlla: Miau`);
  }
}

const perro = new Perro("Rex");
const gato = new Gato("Whiskers");

perro.hacerSonido();  // "Rex ladra: Guau"
gato.hacerSonido();   // "Whiskers maúlla: Miau"
perro.dormir();       // "Rex está durmiendo" (heredado)
----

===== Cuándo Usar Clases Abstractas

- Cuando deseas forzar a las subclases a implementar ciertos métodos
- Para proporcionar funcionalidad común a múltiples clases
- Para establecer una interfaz común sin permitir instanciación

[source,typescript]
----
// Ejemplo: Sistema de pagos
abstract class MetodoPago {
  titular: string;
  protected saldo: number;

  constructor(titular: string, saldoInicial: number) {
    this.titular = titular;
    this.saldo = saldoInicial;
  }

  // Método concreto (igual para todos)
  obtenerSaldo(): number {
    return this.saldo;
  }

  // Método abstracto (cada uno lo implementa diferente)
  abstract procesar(cantidad: number): boolean;

  // Método abstracto (cada uno calcula diferente)
  abstract calcularComision(cantidad: number): number;
}

class TarjetaCredito extends MetodoPago {
  numeroTarjeta: string;

  constructor(titular: string, numeroTarjeta: string, saldo: number) {
    super(titular, saldo);
    this.numeroTarjeta = numeroTarjeta;
  }

  procesar(cantidad: number): boolean {
    if (this.saldo >= cantidad) {
      this.saldo -= cantidad;
      console.log(`Pago de $${cantidad} realizado con tarjeta`);
      return true;
    }
    return false;
  }

  calcularComision(cantidad: number): number {
    return cantidad * 0.02;  // 2% de comisión
  }
}

class Transferencia extends MetodoPago {
  banco: string;

  constructor(titular: string, banco: string, saldo: number) {
    super(titular, saldo);
    this.banco = banco;
  }

  procesar(cantidad: number): boolean {
    if (this.saldo >= cantidad) {
      this.saldo -= cantidad;
      console.log(`Transferencia de $${cantidad} realizada con ${this.banco}`);
      return true;
    }
    return false;
  }

  calcularComision(cantidad: number): number {
    return cantidad * 0.01;  // 1% de comisión
  }
}

// Usar polimorficamente
const tarjeta = new TarjetaCredito("Juan", "1234-5678-9012-3456", 5000);
const banco = new Transferencia("María", "Banco Central", 10000);

const metodos: MetodoPago[] = [tarjeta, banco];

metodos.forEach(metodo => {
  metodo.procesar(100);
  console.log(`Comisión: $${metodo.calcularComision(100)}`);
  console.log(`Saldo restante: $${metodo.obtenerSaldo()}\n`);
});
----


==== 6.2 Métodos Abstractos

Métodos que **no tienen implementación** en la clase abstracta. Las subclases **deben** implementarlos.

===== Sintaxis

[source,typescript]
----
abstract class Forma {
  // Método abstracto - sin cuerpo
  abstract obtenerArea(): number;

  // Otro método abstracto
  abstract obtenerPerimetro(): number;

  // Método concreto
  describir(): string {
    return `Área: ${this.obtenerArea()}, Perímetro: ${this.obtenerPerimetro()}`;
  }
}

class Rectangulo extends Forma {
  ancho: number;
  alto: number;

  constructor(ancho: number, alto: number) {
    super();
    this.ancho = ancho;
    this.alto = alto;
  }

  // ✓ Debe implementar obtenerArea
  obtenerArea(): number {
    return this.ancho * this.alto;
  }

  // ✓ Debe implementar obtenerPerimetro
  obtenerPerimetro(): number {
    return 2 * (this.ancho + this.alto);
  }
}

class Circulo extends Forma {
  radio: number;

  constructor(radio: number) {
    super();
    this.radio = radio;
  }

  obtenerArea(): number {
    return Math.PI * this.radio * this.radio;
  }

  obtenerPerimetro(): number {
    return 2 * Math.PI * this.radio;
  }
}

// ✗ Error: falta implementar métodos abstractos
class TrianguloIncompleto extends Forma {
  // No implementa obtenerArea ni obtenerPerimetro
}

// ✓ Usar subclases
const rect = new Rectangulo(5, 3);
const circulo = new Circulo(4);

console.log(rect.describir());    // "Área: 15, Perímetro: 16"
console.log(circulo.describir()); // "Área: 50.26..., Perímetro: 25.13..."
----

===== Propiedades Abstractas

[source,typescript]
----
abstract class Trabajador {
  // Propiedad abstracta - las subclases deben definirla
  abstract salario: number;

  nombre: string;

  constructor(nombre: string) {
    this.nombre = nombre;
  }

  abstract calcularBono(): number;

  saludar(): void {
    console.log(`Hola, soy ${this.nombre}`);
  }
}

class Ingeniero extends Trabajador {
  salario: number;  // ✓ Debe definir la propiedad abstracta

  constructor(nombre: string, salario: number) {
    super(nombre);
    this.salario = salario;
  }

  calcularBono(): number {
    return this.salario * 0.20;  // 20% bono
  }
}

class Gerente extends Trabajador {
  salario: number;
  departamento: string;

  constructor(nombre: string, salario: number, departamento: string) {
    super(nombre);
    this.salario = salario;
    this.departamento = departamento;
  }

  calcularBono(): number {
    return this.salario * 0.30;  // 30% bono
  }
}

const ing = new Ingeniero("Carlos", 3000);
const ger = new Gerente("Ana", 5000, "IT");

console.log(`${ing.nombre}: Bono $${ing.calcularBono()}`);  // "Carlos: Bono 600"
console.log(`${ger.nombre}: Bono $${ger.calcularBono()}`);  // "Ana: Bono 1500"
----


==== 6.3 Implementar Interfaces en Clases

Una clase implementa una interfaz para garantizar que tiene ciertas propiedades y métodos.

===== Interfaz Simple

[source,typescript]
----
// Definir interfaz
interface Vehículo {
  marca: string;
  modelo: string;
  arrancar(): void;
  detener(): void;
}

// Clase implementa la interfaz
class Auto implements Vehículo {
  marca: string;
  modelo: string;

  constructor(marca: string, modelo: string) {
    this.marca = marca;
    this.modelo = modelo;
  }

  arrancar(): void {
    console.log(`${this.marca} ${this.modelo} está arrancando`);
  }

  detener(): void {
    console.log(`${this.marca} ${this.modelo} se detuvo`);
  }
}

const auto = new Auto("Toyota", "Corolla");
auto.arrancar();  // "Toyota Corolla está arrancando"
auto.detener();   // "Toyota Corolla se detuvo"

// ✗ Error: falta implementar método detener
class MotoIncompleta implements Vehículo {
  marca: string;
  modelo: string;

  constructor(marca: string, modelo: string) {
    this.marca = marca;
    this.modelo = modelo;
  }

  arrancar(): void {
    console.log("Moto arrancando");
  }
  // Falta detener()
}
----

===== Interfaz Extendida

[source,typescript]
----
interface Serializable {
  toJSON(): string;
  fromJSON(json: string): void;
}

interface Persona {
  nombre: string;
  edad: number;
  saludar(): void;
}

// Clase implementa múltiples interfaces
class Usuario implements Persona, Serializable {
  nombre: string;
  edad: number;

  constructor(nombre: string, edad: number) {
    this.nombre = nombre;
    this.edad = edad;
  }

  saludar(): void {
    console.log(`Hola, soy ${this.nombre}`);
  }

  toJSON(): string {
    return JSON.stringify({ nombre: this.nombre, edad: this.edad });
  }

  fromJSON(json: string): void {
    const data = JSON.parse(json);
    this.nombre = data.nombre;
    this.edad = data.edad;
  }
}

const usuario = new Usuario("Juan", 30);
usuario.saludar();                          // "Hola, soy Juan"
console.log(usuario.toJSON());              // '{"nombre":"Juan","edad":30}'

const usuario2 = new Usuario("", 0);
usuario2.fromJSON('{"nombre":"María","edad":25}');
console.log(usuario2.nombre);               // "María"
----

===== Interfaz vs Clase Abstracta

|===
| Aspecto | Interfaz | Clase Abstracta

| Puede tener implementación
| ✗ No (solo firmas)
| ✓ Sí (métodos concretos)

| Propiedades
| ✓ Sí (solo firmas)
| ✓ Sí (con valores)

| Constructor
| ✗ No
| ✓ Sí

| Modificadores de acceso
| ✗ No (siempre público)
| ✓ Sí (public, private, protected)

| Implementación múltiple
| ✓ Una clase puede implementar varias
| ✗ Solo extends una clase

| Herencia
| `implements`
| `extends`

| Cuándo usar
| Definir contrato/forma
| Compartir código + obligar implementación
|===

===== Ejemplo Práctico

[source,typescript]
----
// Interfaz para almacenamiento
interface Repositorio<T> {
  obtener(id: number): T | null;
  obtenerTodos(): T[];
  guardar(item: T): void;
  eliminar(id: number): void;
}

interface Usuario {
  id: number;
  nombre: string;
  email: string;
}

// Implementar repositorio genérico
class RepositorioUsuarios implements Repositorio<Usuario> {
  private usuarios: Map<number, Usuario> = new Map();
  private proximoId = 1;

  obtener(id: number): Usuario | null {
    return this.usuarios.get(id) || null;
  }

  obtenerTodos(): Usuario[] {
    return Array.from(this.usuarios.values());
  }

  guardar(usuario: Usuario): void {
    if (!usuario.id) {
      usuario.id = this.proximoId++;
    }
    this.usuarios.set(usuario.id, usuario);
  }

  eliminar(id: number): void {
    this.usuarios.delete(id);
  }
}

// Usar
const repo = new RepositorioUsuarios();

repo.guardar({ id: 0, nombre: "Juan", email: "juan@example.com" });
repo.guardar({ id: 0, nombre: "María", email: "maria@example.com" });

console.log(repo.obtenerTodos());           // Array de usuarios
console.log(repo.obtener(1));               // Usuario específico
----


==== 6.4 Múltiples Interfaces

Una clase puede implementar **varias interfaces** a la vez.

===== Múltiples Implementaciones

[source,typescript]
----
interface Comestible {
  comer(): void;
}

interface Bebible {
  beber(): void;
}

interface Transportable {
  transportar(): void;
}

// Una clase implementa múltiples interfaces
class Producto implements Comestible, Bebible, Transportable {
  nombre: string;

  constructor(nombre: string) {
    this.nombre = nombre;
  }

  comer(): void {
    console.log(`Comiendo ${this.nombre}`);
  }

  beber(): void {
    console.log(`Bebiendo ${this.nombre}`);
  }

  transportar(): void {
    console.log(`Transportando ${this.nombre}`);
  }
}

const producto = new Producto("Jugo de Naranja");
producto.comer();       // "Comiendo Jugo de Naranja"
producto.beber();       // "Bebiendo Jugo de Naranja"
producto.transportar(); // "Transportando Jugo de Naranja"
----

===== Interfaces Extensas

[source,typescript]
----
interface Animal {
  nombre: string;
  edad: number;
}

interface Animal {
  hacerSonido(): void;
}

interface Animal {
  moverse(): void;
}

// Se combinan automáticamente (declaration merging)
class Perro implements Animal {
  nombre: string;
  edad: number;

  constructor(nombre: string, edad: number) {
    this.nombre = nombre;
    this.edad = edad;
  }

  hacerSonido(): void {
    console.log("¡Guau!");
  }

  moverse(): void {
    console.log("Corriendo...");
  }
}

const perro = new Perro("Rex", 3);
console.log(perro.nombre);    // "Rex"
perro.hacerSonido();          // "¡Guau!"
perro.moverse();              // "Corriendo..."
----

===== Composición de Interfaces

[source,typescript]
----
interface Identificable {
  id: number;
}

interface Nombrable {
  nombre: string;
}

interface Validable {
  validar(): boolean;
}

// Composición: crear interfaz con múltiples
interface Usuario extends Identificable, Nombrable, Validable {
  email: string;
}

class UsuarioImpl implements Usuario {
  id: number;
  nombre: string;
  email: string;

  constructor(id: number, nombre: string, email: string) {
    this.id = id;
    this.nombre = nombre;
    this.email = email;
  }

  validar(): boolean {
    return this.email.includes("@") && this.nombre.length > 0;
  }
}

const usuario = new UsuarioImpl(1, "Juan", "juan@example.com");
console.log(usuario.id);         // 1
console.log(usuario.nombre);     // "Juan"
console.log(usuario.validar());  // true
----

===== Ejemplo Real: Sistema de Notificaciones

[source,typescript]
----
interface Notificable {
  notificar(mensaje: string): void;
}

interface Logueable {
  registrar(evento: string): void;
}

// Diferentes canales de notificación
class EmailNotificador implements Notificable, Logueable {
  registrar(evento: string): void {
    console.log(`[EMAIL] ${evento}`);
  }

  notificar(mensaje: string): void {
    console.log(`Enviando email: ${mensaje}`);
  }
}

class SMSNotificador implements Notificable, Logueable {
  registrar(evento: string): void {
    console.log(`[SMS] ${evento}`);
  }

  notificar(mensaje: string): void {
    console.log(`Enviando SMS: ${mensaje}`);
  }
}

class SlackNotificador implements Notificable, Logueable {
  registrar(evento: string): void {
    console.log(`[SLACK] ${evento}`);
  }

  notificar(mensaje: string): void {
    console.log(`Enviando a Slack: ${mensaje}`);
  }
}

// Sistema que usa cualquier notificador
class SistemaAlertas {
  private notificadores: Notificable[] = [];
  private logueadores: Logueable[] = [];

  agregarNotificador(n: Notificable): void {
    this.notificadores.push(n);
  }

  agregarLogueador(l: Logueable): void {
    this.logueadores.push(l);
  }

  alertar(mensaje: string): void {
    // Registrar evento
    this.logueadores.forEach(l => l.registrar(`Alerta: ${mensaje}`));

    // Notificar por todos los canales
    this.notificadores.forEach(n => n.notificar(mensaje));
  }
}

// Uso
const sistema = new SistemaAlertas();
sistema.agregarNotificador(new EmailNotificador());
sistema.agregarNotificador(new SMSNotificador());
sistema.agregarNotificador(new SlackNotificador());

sistema.agregarLogueador(new EmailNotificador());
sistema.agregarLogueador(new SlackNotificador());

sistema.alertar("Error crítico en el servidor");
// [EMAIL] Alerta: Error crítico en el servidor
// [SLACK] Alerta: Error crítico en el servidor
// Enviando email: Error crítico en el servidor
// Enviando SMS: Error crítico en el servidor
// Enviando a Slack: Error crítico en el servidor
----

===== Ejercicios Propuestos

.1. Clase abstracta para operaciones:
[source,typescript]
----
// Crear clase abstracta Operacion con:
// - método abstracto ejecutar(): number
// - método calcularTiempo(): void (concreto)
// Crear clases Suma, Resta, Multiplicación
----

.2. Implementar múltiples interfaces:
[source,typescript]
----
// Interfaces: Grabable, Reproducible, Descargable
// Clase ArchivoDeMúsica implementa todas
// Cada método tiene comportamiento diferente
----

.3. Sistema de pagos con interfaces:
[source,typescript]
----
// Interface Pagador con método procesar()
// Clases: TarjetaCredito, PayPal, Criptomoneda
// Cada una implementa diferente
----

.4. Repositorio genérico:
[source,typescript]
----
// Interface Repositorio<T> con CRUD básico
// Clase Repositorio en memoria que la implemente
// Probar con Usuario y Producto
----


=== Módulo 7: Genéricos Avanzados

Los genéricos permiten escribir código reutilizable que funciona con cualquier tipo. Este módulo cubre técnicas avanzadas para dominar los genéricos en TypeScript.

==== 7.1 Genéricos en Funciones y Clases

===== Genéricos en Funciones

[source,typescript]
----
// Función genérica básica
function identidad<T>(valor: T): T {
  return valor;
}

// TypeScript infiere el tipo automáticamente
const num = identidad(42);          // T = number
const str = identidad("hola");      // T = string
const bool = identidad(true);       // T = boolean

// O especificar explícitamente
const explícito = identidad<string>("TypeScript");

// Función con múltiples parámetros genéricos
function intercambiar<T, U>(a: T, b: U): [U, T] {
  return [b, a];
}

const resultado = intercambiar("Hola", 42);
// resultado = [42, "Hola"]

// Función genérica con array
function primerElemento<T>(arr: T[]): T | undefined {
  return arr[0];
}

console.log(primerElemento([1, 2, 3]));           // 1 (T = number)
console.log(primerElemento(["a", "b", "c"]));    // "a" (T = string)
console.log(primerElemento([]));                 // undefined
----

===== Genéricos en Clases

[source,typescript]
----
// Clase genérica
class Contenedor<T> {
  private valor: T;

  constructor(valor: T) {
    this.valor = valor;
  }

  obtener(): T {
    return this.valor;
  }

  establecer(nuevoValor: T): void {
    this.valor = nuevoValor;
  }
}

// Usar con diferentes tipos
const contenedorNumero = new Contenedor<number>(42);
console.log(contenedorNumero.obtener());  // 42

const contenedorString = new Contenedor<string>("Hola");
console.log(contenedorString.obtener());  // "Hola"

// Inferencia automática
const contenedorBool = new Contenedor(true);  // T infer como boolean
----

===== Genéricos en Métodos de Clase

[source,typescript]
----
class Utilidades {
  // Método genérico
  static revertir<T>(arr: T[]): T[] {
    return arr.reverse();
  }

  static filtrar<T>(arr: T[], predicado: (item: T) => boolean): T[] {
    return arr.filter(predicado);
  }

  static mapear<T, U>(arr: T[], mapeo: (item: T) => U): U[] {
    return arr.map(mapeo);
  }
}

// Uso
const numeros = [1, 2, 3, 4, 5];
console.log(Utilidades.revertir(numeros));                        // [5,4,3,2,1]
console.log(Utilidades.filtrar(numeros, n => n > 2));            // [3,4,5]
console.log(Utilidades.mapear(numeros, n => n * 2));             // [2,4,6,8,10]
----

===== Pares Clave-Valor Genéricos

[source,typescript]
----
interface Par<K, V> {
  clave: K;
  valor: V;
}

class Diccionario<K, V> {
  private datos: Map<K, V> = new Map();

  establecer(clave: K, valor: V): void {
    this.datos.set(clave, valor);
  }

  obtener(clave: K): V | undefined {
    return this.datos.get(clave);
  }

  obtenerTodos(): Par<K, V>[] {
    return Array.from(this.datos).map(([k, v]) => ({ clave: k, valor: v }));
  }
}

// Usar con string → número
const edades = new Diccionario<string, number>();
edades.establecer("Juan", 30);
edades.establecer("María", 25);
console.log(edades.obtener("Juan"));          // 30
console.log(edades.obtenerTodos());           // [{ clave: "Juan", valor: 30 }, ...]

// Usar con número → objeto
interface Usuario {
  nombre: string;
  email: string;
}

const usuarios = new Diccionario<number, Usuario>();
usuarios.establecer(1, { nombre: "Juan", email: "juan@example.com" });
console.log(usuarios.obtener(1)?.nombre);    // "Juan"
----


==== 7.2 Restricciones de Genéricos (Constraints)

Limitar qué tipos pueden usarse como parámetros genéricos.

===== extends - Restricción Básica

[source,typescript]
----
// Solo permitir tipos que tengan propiedad length
function obtenerLongitud<T extends { length: number }>(valor: T): number {
  return valor.length;
}

console.log(obtenerLongitud("Hola"));      // 4 (string tiene length)
console.log(obtenerLongitud([1, 2, 3]));  // 3 (array tiene length)
console.log(obtenerLongitud({ length: 5 })); // 5 (objeto con length)
console.log(obtenerLongitud(42));         // ✗ Error: number no tiene length

// Restricción a tipo específico
function obtenerPropiedad<T extends { nombre: string }>(obj: T): string {
  return obj.nombre;
}

obtenerPropiedad({ nombre: "Juan", edad: 30 });    // ✓
obtenerPropiedad({ nombre: "María" });             // ✓
obtenerPropiedad({ edad: 25 });                    // ✗ Error: falta nombre
----

===== extends con Type

[source,typescript]
----
// Restringir a un tipo específico
function procesarNumero<T extends number>(valor: T): T {
  return valor;
}

procesarNumero(42);      // ✓
procesarNumero(3.14);    // ✓
procesarNumero("42");    // ✗ Error: string no extiende number

// Restringir a union de tipos
function procesarPrimera<T extends string | number | boolean>(valor: T): T {
  return valor;
}

procesarPrimera("texto");    // ✓
procesarPrimera(42);         // ✓
procesarPrimera(true);       // ✓
procesarPrimera({});         // ✗ Error

// Restringir a array
function obtenerPrimero<T extends any[]>(arr: T): T[0] | undefined {
  return arr[0];
}

obtenerPrimero([1, 2, 3]);          // 1
obtenerPrimero(["a", "b"]);         // "a"
obtenerPrimero({});                 // ✗ Error: no es array
----

===== extends con Genéricos

[source,typescript]
----
// T debe ser array de algo
function procesarArray<T extends any[]>(arr: T): number {
  return arr.length;
}

procesarArray([1, 2, 3]);     // ✓
procesarArray(["a", "b"]);    // ✓
procesarArray("hola");        // ✗ Error: no es array

// T debe descender de clase/interfaz
class Animal {
  nombre: string;

  constructor(nombre: string) {
    this.nombre = nombre;
  }
}

class Perro extends Animal {
  traer(): void {
    console.log(`${this.nombre} trae la pelota`);
  }
}

function crearInstancia<T extends Animal>(Clase: new (...args: any[]) => T, nombre: string): T {
  return new Clase(nombre);
}

const animal = crearInstancia(Animal, "Genérico");
const perro = crearInstancia(Perro, "Rex");
perro.traer();  // "Rex trae la pelota"
----

===== keyof - Restricción a Propiedades

[source,typescript]
----
// T debe ser un objeto, K debe ser clave de T
function obtenerPropiedad<T, K extends keyof T>(obj: T, clave: K): T[K] {
  return obj[clave];
}

const persona = { nombre: "Juan", edad: 30, ciudad: "Madrid" };

console.log(obtenerPropiedad(persona, "nombre"));   // "Juan"
console.log(obtenerPropiedad(persona, "edad"));     // 30
console.log(obtenerPropiedad(persona, "email"));    // ✗ Error: no existe email

// Modificar propiedad
function establecerPropiedad<T, K extends keyof T>(obj: T, clave: K, valor: T[K]): void {
  obj[clave] = valor;
}

establecerPropiedad(persona, "nombre", "Carlos");      // ✓
establecerPropiedad(persona, "edad", 35);              // ✓
establecerPropiedad(persona, "edad", "treinta");       // ✗ Error: tipo incorrecto
----

===== Restricciones Múltiples

[source,typescript]
----
// Combinación de restricciones
interface Identificable {
  id: number;
}

interface Nombrable {
  nombre: string;
}

function procesar<T extends Identificable & Nombrable>(obj: T): string {
  return `${obj.id}: ${obj.nombre}`;
}

procesar({ id: 1, nombre: "Juan" });         // ✓
procesar({ id: 1 });                         // ✗ Error: falta nombre
procesar({ nombre: "Juan" });                // ✗ Error: falta id

// Genérico restringido por otro genérico
function fusionar<T extends object, U extends object>(obj1: T, obj2: U): T & U {
  return { ...obj1, ...obj2 };
}

const persona = { nombre: "Juan", edad: 30 };
const contacto = { email: "juan@example.com", telefono: "555-1234" };
const resultado = fusionar(persona, contacto);
console.log(resultado);  // { nombre, edad, email, telefono }
----


==== 7.3 Genéricos con Interfaces

===== Interfaz Genérica

[source,typescript]
----
// Interfaz genérica básica
interface Respuesta<T> {
  exito: boolean;
  datos?: T;
  error?: string;
}

// Usar con diferentes tipos
type RespuestaUsuario = Respuesta<{ id: number; nombre: string }>;
type RespuestaNumero = Respuesta<number>;
type RespuestaString = Respuesta<string>;

const resp1: RespuestaUsuario = {
  exito: true,
  datos: { id: 1, nombre: "Juan" }
};

const resp2: RespuestaNumero = {
  exito: false,
  error: "No se pudo obtener el número"
};
----

===== Interfaz con Herencia Genérica

[source,typescript]
----
interface Entidad<T> {
  id: T;
  creado: Date;
}

interface Usuario extends Entidad<number> {
  nombre: string;
  email: string;
}

interface Sesion extends Entidad<string> {
  token: string;
  usuarioId: number;
}

const usuario: Usuario = {
  id: 1,                                  // number (de Entidad<number>)
  nombre: "Juan",
  email: "juan@example.com",
  creado: new Date()
};

const sesion: Sesion = {
  id: "abc123",                           // string (de Entidad<string>)
  token: "xyz789",
  usuarioId: 1,
  creado: new Date()
};
----

===== CRUD Genérico

[source,typescript]
----
interface Repositorio<T> {
  obtener(id: number): Promise<T | null>;
  obtenerTodos(): Promise<T[]>;
  guardar(item: T): Promise<T>;
  actualizar(id: number, item: Partial<T>): Promise<T | null>;
  eliminar(id: number): Promise<boolean>;
}

// Implementación en memoria
class RepositorioEnMemoria<T extends { id?: number }> implements Repositorio<T> {
  private items: T[] = [];
  private proximoId = 1;

  async obtener(id: number): Promise<T | null> {
    return this.items.find(item => item.id === id) || null;
  }

  async obtenerTodos(): Promise<T[]> {
    return [...this.items];
  }

  async guardar(item: T): Promise<T> {
    if (!item.id) {
      item.id = this.proximoId++;
    }
    this.items.push(item);
    return item;
  }

  async actualizar(id: number, cambios: Partial<T>): Promise<T | null> {
    const index = this.items.findIndex(item => item.id === id);
    if (index === -1) return null;
    this.items[index] = { ...this.items[index], ...cambios };
    return this.items[index];
  }

  async eliminar(id: number): Promise<boolean> {
    const index = this.items.findIndex(item => item.id === id);
    if (index === -1) return false;
    this.items.splice(index, 1);
    return true;
  }
}

// Usar con Usuario
interface Usuario {
  id?: number;
  nombre: string;
  email: string;
}

const repoUsuarios = new RepositorioEnMemoria<Usuario>();

(async () => {
  await repoUsuarios.guardar({ nombre: "Juan", email: "juan@example.com" });
  await repoUsuarios.guardar({ nombre: "María", email: "maria@example.com" });

  const todos = await repoUsuarios.obtenerTodos();
  console.log(todos);  // Array de usuarios

  await repoUsuarios.actualizar(1, { email: "juannuevo@example.com" });
  const actualizado = await repoUsuarios.obtener(1);
  console.log(actualizado);  // Usuario actualizado
})();

// Reutilizar con Producto
interface Producto {
  id?: number;
  nombre: string;
  precio: number;
}

const repoProductos = new RepositorioEnMemoria<Producto>();
// Misma lógica, diferente tipo
----


==== 7.4 Tipos Condicionales y Mapped Types

===== Tipos Condicionales

Un tipo que es diferente dependiendo de una condición.

[source,typescript]
----
// Sintaxis: T extends U ? X : Y
type EsString<T> = T extends string ? true : false;

type A = EsString<"hola">;      // true
type B = EsString<42>;          // false
type C = EsString<string>;      // true

// Uso práctico: obtener el tipo de elemento de un array
type ElementoArray<T> = T extends Array<infer E> ? E : T;

type NumArray = ElementoArray<number[]>;           // número
type StrArray = ElementoArray<string[]>;           // string
type NoArray = ElementoArray<number>;              // number (no es array)

// Tipar retorno de función
type RetornoFuncion<F> = F extends (...args: any[]) => infer R ? R : never;

type Retorno1 = RetornoFuncion<() => string>;                  // string
type Retorno2 = RetornoFuncion<(x: number) => boolean>;        // boolean
type Retorno3 = RetornoFuncion<string>;                        // never
----

===== infer - Inferencia en Condicionales

[source,typescript]
----
// Extraer tipo de Promise
type Desempacar<T> = T extends Promise<infer U> ? U : T;

type A = Desempacar<Promise<string>>;        // string
type B = Desempacar<Promise<number>>;        // number
type C = Desempacar<string>;                 // string (no es Promise)

// Extraer tipos de tupla
type Primero<T> = T extends [infer P, ...any[]] ? P : never;
type Resto<T> = T extends [any, ...infer R] ? R : never;

type TuplaPrueba = [string, number, boolean];
type P = Primero<TuplaPrueba>;      // string
type R = Resto<TuplaPrueba>;        // [number, boolean]

// Obtener argumentos de función
type Argumentos<F> = F extends (...args: infer A) => any ? A : never;

type Args = Argumentos<(a: string, b: number) => void>;  // [string, number]
----

===== Mapped Types

Crear nuevos tipos transformando propiedades existentes.

[source,typescript]
----
// Hacer todas las propiedades readonly
type Readonly<T> = {
  readonly [K in keyof T]: T[K];
};

interface Usuario {
  nombre: string;
  edad: number;
}

type UsuarioReadonly = Readonly<Usuario>;
// { readonly nombre: string; readonly edad: number }

// Hacer todas las propiedades opcionales
type Opcional<T> = {
  [K in keyof T]?: T[K];
};

type UsuarioOpcional = Opcional<Usuario>;
// { nombre?: string; edad?: number }

// Hacer todas las propiedades getters
type Getters<T> = {
  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
};

type UsuarioGetters = Getters<Usuario>;
// { getNombre: () => string; getEdad: () => number }

// Crear tipo de funciones para cada propiedad
type Setters<T> = {
  [K in keyof T as `set${Capitalize<string & K>}`]: (valor: T[K]) => void;
};

type UsuarioSetters = Setters<Usuario>;
// { setNombre: (valor: string) => void; setEdad: (valor: number) => void }
----

===== Mapped Types Práctico

[source,typescript]
----
// Convertir interfaz a diccionario de validadores
interface FormularioUsuario {
  nombre: string;
  email: string;
  edad: number;
}

type Validadores<T> = {
  [K in keyof T]: (valor: T[K]) => boolean;
};

const validadoresUsuario: Validadores<FormularioUsuario> = {
  nombre: (v) => v.length > 0,
  email: (v) => v.includes("@"),
  edad: (v) => v >= 18
};

// Convertir a tipos númericos
type Numbeado<T> = {
  [K in keyof T]: number;
};

type UsuarioNumeros = Numbeado<FormularioUsuario>;
// { nombre: number; email: number; edad: number }

// Convertir propiedades a getters (clase)
class Usuario {
  constructor(
    private nombre: string,
    private email: string,
    private edad: number
  ) {}
}

// Mapear a tipos de promesas
type Promesas<T> = {
  [K in keyof T]: Promise<T[K]>;
};

type UsuarioPromesas = Promesas<FormularioUsuario>;
// { nombre: Promise<string>; email: Promise<string>; edad: Promise<number> }
----

===== Template Literal Types

[source,typescript]
----
// Crear tipos basados en strings
type Evento = "click" | "hover" | "focus";

type ManejoEvento<E extends string> = `on${Capitalize<E>}`;

type Manejador = ManejoEvento<Evento>;
// "onClick" | "onHover" | "onFocus"

// Combinar strings
type Union1 = "a" | "b";
type Union2 = "x" | "y";

type Combinada = `${Union1}${Union2}`;
// "ax" | "ay" | "bx" | "by"

// Crear tipos de rutas
type Metodo = "GET" | "POST" | "PUT" | "DELETE";
type Ruta = "/usuarios" | "/productos";

type Endpoint = `${Metodo} ${Ruta}`;
// "GET /usuarios" | "GET /productos" | "POST /usuarios" | ...
----

===== Ejercicios Propuestos

.1. Función genérica para transformar:
[source,typescript]
----
// Crear función transformar<T, U> que:
// - Acepte array de T
// - Acepte función transformadora (T => U)
// - Retorne array de U
// Probar con números a strings
----

.2. Restricción con keyof:
[source,typescript]
----
// Crear función obtenerValores<T> que:
// - Acepte objeto de tipo T
// - Acepte array de claves (keyof T)
// - Retorne array con valores correspondientes
----

.3. Tipo condicional útil:
[source,typescript]
----
// Crear tipo HacerArray<T> que:
// - Si T es array, retorna T
// - Si no, retorna T[] (envuelto en array)
// Probar con number, string[], boolean
----

.4. Mapped type para clase:
[source,typescript]
----
// Crear tipo Getters<T> que genera getters
// para todas las propiedades de T
// Crear tipo Setters<T> que genera setters
----


=== Módulo 8: Tipos Utilitarios y Avanzados

TypeScript proporciona tipos utilitarios poderosos para transformar y manipular tipos existentes. Este módulo cubre herramientas avanzadas para escribir código más flexible, seguro y reutilizable.

==== 8.1 Tipos Utilitarios: Partial, Required, Readonly, etc.

Los tipos utilitarios son tipos genéricos que hacen transformaciones en otros tipos.

===== Partial<T>

Hace todas las propiedades **opcionales**.

[source,typescript]
----
interface Usuario {
  id: number;
  nombre: string;
  email: string;
  edad: number;
}

// Partial<Usuario> hace todas las propiedades opcionales
type UsuarioOpcional = Partial<Usuario>;

const usuarioIncompleto: UsuarioOpcional = {
  nombre: "Juan"
  // No es necesario proporcionar id, email, edad
};

// Útil para actualizaciones parciales
function actualizarUsuario(id: number, cambios: Partial<Usuario>): void {
  console.log(`Actualizando usuario ${id} con:`, cambios);
}

actualizarUsuario(1, { nombre: "Carlos", edad: 31 });  // ✓ Solo algunos campos
actualizarUsuario(1, { email: "nuevo@example.com" });  // ✓ Solo email
----

===== Required<T>

Hace todas las propiedades **obligatorias**.

[source,typescript]
----
interface Persona {
  nombre?: string;
  edad?: number;
  email?: string;
}

// Required<Persona> hace todas obligatorias
type PersonaCompleta = Required<Persona>;

const persona: PersonaCompleta = {
  nombre: "María",
  edad: 28,
  email: "maria@example.com"
  // Todas las propiedades son obligatorias ahora
};

// Error: falta 'nombre'
const incompleta: PersonaCompleta = {
  edad: 25,
  email: "test@example.com"
};
----

===== Readonly<T>

Hace todas las propiedades **solo lectura**.

[source,typescript]
----
interface Configuracion {
  host: string;
  puerto: number;
  ssl: boolean;
}

// Readonly<Configuracion> - no se pueden cambiar
type ConfiguracionFija = Readonly<Configuracion>;

const config: ConfiguracionFija = {
  host: "localhost",
  puerto: 3000,
  ssl: true
};

console.log(config.host);  // ✓ Puede leer
config.host = "example.com";  // ✗ Error: Cannot assign to readonly property 'host'
config.puerto = 8080;      // ✗ Error

// Útil para garantizar inmutabilidad
function obtenerConfiguracion(): ConfiguracionFija {
  return { host: "api.example.com", puerto: 443, ssl: true };
}

const cfg = obtenerConfiguracion();
cfg.puerto = 9000;  // ✗ Error
----

===== Record<K, T>

Crea un objeto con claves de tipo K y valores de tipo T.

[source,typescript]
----
// Record<"a" | "b" | "c", number>
type Puntuaciones = Record<"matemáticas" | "lenguaje" | "ciencias", number>;

const calificaciones: Puntuaciones = {
  matemáticas: 95,
  lenguaje: 87,
  ciencias: 92
};

// Record es perfecto para maps
type StatusProduccion = Record<"en_stock" | "descontinuado" | "pre_orden", boolean>;

const estados: StatusProduccion = {
  en_stock: true,
  descontinuado: false,
  pre_orden: true
};

// Con enums
enum Rol {
  Admin = "admin",
  Usuario = "usuario",
  Moderador = "moderador"
}

type Permisos = Record<Rol, string[]>;

const permisosPorRol: Permisos = {
  [Rol.Admin]: ["crear", "leer", "actualizar", "eliminar"],
  [Rol.Usuario]: ["leer"],
  [Rol.Moderador]: ["crear", "leer", "eliminar"]
};
----

===== Pick<T, K>

Selecciona solo **ciertos campos** de un tipo.

[source,typescript]
----
interface Empleado {
  id: number;
  nombre: string;
  email: string;
  departamento: string;
  salario: number;
  fechaContratacion: Date;
}

// Pick solo id, nombre, email
type EmpleadoPublico = Pick<Empleado, "id" | "nombre" | "email">;

const publicData: EmpleadoPublico = {
  id: 1,
  nombre: "Juan",
  email: "juan@example.com"
  // salario y departamento no pueden incluirse
};

// Útil para tipos específicos de APIs
type LoginCredentials = Pick<Empleado, "email">;
// Solo necesita email para login

type EmpleadoConSalario = Pick<Empleado, "nombre" | "departamento" | "salario">;
// Para reportes de nómina
----

===== Omit<T, K>

Lo opuesto a Pick: **excluye campos**.

[source,typescript]
----
interface Producto {
  id: number;
  nombre: string;
  descripcion: string;
  precio: number;
  stock: number;
  proveedor: string;
}

// Omit excluye id
type ProductoInput = Omit<Producto, "id">;

function crearProducto(producto: ProductoInput): void {
  console.log(`Creando producto: ${producto.nombre}`);
  // ID se genera automáticamente, no se espera en input
}

crearProducto({
  nombre: "Laptop",
  descripcion: "Laptop poderosa",
  precio: 999.99,
  stock: 5,
  proveedor: "Dell"
});

// Excluir múltiples campos
type ProductoBasico = Omit<Producto, "id" | "proveedor" | "descripcion">;

const basico: ProductoBasico = {
  nombre: "Mouse",
  precio: 25,
  stock: 100
};
----

===== Exclude<T, U>

Excluye ciertos **tipos** de una unión.

[source,typescript]
----
type Estado = "cargando" | "éxito" | "error" | "inactivo";

// Exclude solo deja los tipos que no son "cargando" ni "inactivo"
type EstadoActivo = Exclude<Estado, "cargando" | "inactivo">;
// Resulta en: "éxito" | "error"

const estado: EstadoActivo = "éxito";  // ✓
// const estado: EstadoActivo = "cargando";  // ✗ Error

// Útil para valores discriminantes
type Numero = number;
type String = string;
type Booleano = boolean;

type TiposComunes = Numero | String | Booleano | null | undefined;
type TiposValidos = Exclude<TiposComunes, null | undefined>;
// Resulta en: number | string | boolean
----

===== Extract<T, U>

Lo opuesto a Exclude: **extrae** solo ciertos tipos.

[source,typescript]
----
type Modales = "alert" | "confirm" | "toast" | "dropdown" | "modal";

// Extract solo los que coinciden
type PopupModales = Extract<Modales, "alert" | "confirm" | "modal">;
// Resulta en: "alert" | "confirm" | "modal"

const tipo: PopupModales = "alert";  // ✓
// const tipo: PopupModales = "toast";  // ✗ Error

// Útil para subtipos
type Eventos = "click" | "mousedown" | "mouseup" | "focus" | "blur" | "change";

type EventosRaton = Extract<Eventos, "click" | "mousedown" | "mouseup">;
// Resulta en: "click" | "mousedown" | "mouseup"
----

===== NonNullable<T>

Remueve `null` y `undefined` de un tipo union.

[source,typescript]
----
type Valor = string | number | boolean | null | undefined;

// NonNullable<Valor> elimina null y undefined
type ValorValido = NonNullable<Valor>;
// Resulta en: string | number | boolean

const v1: ValorValido = "texto";  // ✓
const v2: ValorValido = 42;       // ✓
const v3: ValorValido = null;     // ✗ Error

// Útil después de null checks
function procesarDato(dato: string | null): void {
  if (dato !== null) {
    // Aquí TypeScript sabe que dato es NonNullable
    const limpio: NonNullable<typeof dato> = dato;
    console.log(limpio.toUpperCase());
  }
}
----


==== 8.2 Record, Pick, Omit Types - Casos Prácticos

===== Ejemplo: Sistema de Permisos

[source,typescript]
----
interface Usuario {
  id: number;
  nombre: string;
  email: string;
  rol: "admin" | "usuario" | "moderador";
  activo: boolean;
}

// Tipos específicos usando Pick/Omit
type UsuarioPublico = Pick<Usuario, "id" | "nombre">;
type UsuarioConEmail = Pick<Usuario, "nombre" | "email">;
type UsuarioParaActualizar = Omit<Usuario, "id">;
type DatosDelRol = Pick<Usuario, "rol" | "activo">;

// Usar en funciones
function mostrarPerfil(usuario: UsuarioPublico): void {
  console.log(`${usuario.id}: ${usuario.nombre}`);
}

function enviarEmail(usuario: UsuarioConEmail): void {
  console.log(`Email a ${usuario.email}`);
}

function actualizarUsuario(id: number, cambios: Partial<UsuarioParaActualizar>): void {
  console.log(`Actualizando usuario ${id}`, cambios);
}

function verificarAcceso(datos: DatosDelRol): boolean {
  return datos.activo && datos.rol === "admin";
}
----

===== Ejemplo: Estados de Aplicación

[source,typescript]
----
interface Estado {
  usuarios: { id: number; nombre: string }[];
  productos: { id: number; precio: number }[];
  pedidos: { id: number; total: number }[];
  usuario_actual: { id: number; nombre: string } | null;
  cargando: boolean;
  error: string | null;
}

// Tipos específicos
type EstadoUI = Pick<Estado, "cargando" | "error" | "usuario_actual">;
type EstadoDatos = Omit<Estado, "cargando" | "error">;
type CacheProductos = Pick<Estado, "productos">;

// Funciones especializadas
function renderizarUI(estado: EstadoUI): void {
  if (estado.cargando) console.log("Cargando...");
  if (estado.error) console.log(`Error: ${estado.error}`);
  if (estado.usuario_actual) {
    console.log(`Hola ${estado.usuario_actual.nombre}`);
  }
}

function almacenarDatos(estado: EstadoDatos): void {
  // Guarda datos pero no UI transiente
  console.log("Almacenando datos...");
}
----


==== 8.3 Tipos Condicionales y Mapped Types

===== Tipos Condicionales

Sintaxis similar a ternarios pero para tipos.

[source,typescript]
----
// Tipo condicional básico
type EsString<T> = T extends string ? true : false;

type A = EsString<"hola">;         // true
type B = EsString<number>;         // false
type C = EsString<string>;         // true

// Usualmente más útil:
type Aplanador<T> = T extends Array<infer U> ? U : T;

type A = Aplanador<string[]>;      // string
type B = Aplanador<number>;        // number
type C = Aplanador<string>;        // string

// Con tipos complejos
type ObtenerTipo<T> = 
  T extends string ? "string" :
  T extends number ? "number" :
  T extends boolean ? "boolean" :
  "otro";

type R1 = ObtenerTipo<"hola">;     // "string"
type R2 = ObtenerTipo<42>;         // "number"
type R3 = ObtenerTipo<true>;       // "boolean"
type R4 = ObtenerTipo<null>;       // "otro"
----

===== Mapped Types

Itera sobre propiedades y transforma cada una.

[source,typescript]
----
interface Usuario {
  id: number;
  nombre: string;
  email: string;
  edad: number;
}

// Mapped type: convierte cada valor a getter
type Getters<T> = {
  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
};

type UsuarioGetters = Getters<Usuario>;
// Resulta en:
// {
//   getId: () => number;
//   getNombre: () => string;
//   getEmail: () => string;
//   getEdad: () => number;
// }

// Mapped type: make all properties nullable
type Nullable<T> = {
  [K in keyof T]: T[K] | null;
};

type UsuarioNuleable = Nullable<Usuario>;
// Resulta en:
// {
//   id: number | null;
//   nombre: string | null;
//   email: string | null;
//   edad: number | null;
// }

// Mapped type: read-only version
type Readonlyizado<T> = {
  readonly [K in keyof T]: T[K];
};

const usuarioRO: Readonlyizado<Usuario> = {
  id: 1,
  nombre: "Juan",
  email: "juan@example.com",
  edad: 30
};

usuarioRO.nombre = "María";  // ✗ Error: readonly
----

===== Combinación: Condicionales + Mapped

[source,typescript]
----
// Tipo que convierte propiedades en getters solo para strings
type GettersStr<T> = {
  [K in keyof T as T[K] extends string ? `get${Capitalize<string & K>}` : never]: 
    T[K] extends string ? () => T[K] : never;
};

interface Producto {
  id: number;
  nombre: string;
  descripcion: string;
  precio: number;
}

type ProductoGettersStr = GettersStr<Producto>;
// Resulta en:
// {
//   getNombre: () => string;
//   getDescripcion: () => string;
// }

// Solo propiedades string generan getters
const getters: ProductoGettersStr = {
  getNombre: () => "Laptop",
  getDescripcion: () => "Una laptop"
};
----

===== Ejemplo Práctico: Validadores

[source,typescript]
----
interface FormularioRegistro {
  nombre: string;
  email: string;
  edad: number;
  contraseña: string;
}

// Tipo que crea validadores para cada campo
type Validadores<T> = {
  [K in keyof T]: (valor: T[K]) => boolean;
};

const validadores: Validadores<FormularioRegistro> = {
  nombre: (v) => v.length > 0,
  email: (v) => v.includes("@"),
  edad: (v) => v >= 18,
  contraseña: (v) => v.length >= 8
};

// Usar validadores
function validarFormulario(datos: FormularioRegistro): boolean {
  for (const [campo, validador] of Object.entries(validadores)) {
    if (!validador(datos[campo as keyof FormularioRegistro])) {
      console.log(`Error en ${campo}`);
      return false;
    }
  }
  return true;
}

const formulario: FormularioRegistro = {
  nombre: "Juan",
  email: "juan@example.com",
  edad: 25,
  contraseña: "password123"
};

console.log(validarFormulario(formulario));  // true
----


==== 8.4 Decoradores y Metadata

Los **decoradores** son funciones que modifican clases, métodos o propiedades.

===== Habilitar Decoradores

Primero, habilita en `tsconfig.json`:

[source,json]
----
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  }
}
----

===== Decoradores de Clase

[source,typescript]
----
// Decorador simple
function Sellado<T extends { new(...args: any[]): {} }>(constructor: T) {
  Object.seal(constructor);
  Object.seal(constructor.prototype);
}

@Sellado
class Persona {
  nombre: string;

  constructor(nombre: string) {
    this.nombre = nombre;
  }
}

const p = new Persona("Juan");
p.nombre = "María";  // ✓ Puede cambiar existing property
p.edad = 30;         // ✗ Error: Cannot add new property (sealed)

// Decorador que añade propiedades
function Timestamped<T extends { new(...args: any[]): {} }>(constructor: T) {
  return class extends constructor {
    createdAt = new Date();
    updatedAt = new Date();
  };
}

@Timestamped
class Documento {
  titulo: string;

  constructor(titulo: string) {
    this.titulo = titulo;
  }
}

const doc = new Documento("Mi documento");
console.log(doc.createdAt);  // Date actual
----

===== Decoradores de Métodos

[source,typescript]
----
// Decorador que registra llamadas
function Log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = function (...args: any[]) {
    console.log(`Llamando ${propertyKey} con args:`, args);
    const resultado = originalMethod.apply(this, args);
    console.log(`${propertyKey} retornó:`, resultado);
    return resultado;
  };

  return descriptor;
}

class Calculadora {
  @Log
  sumar(a: number, b: number): number {
    return a + b;
  }
}

const calc = new Calculadora();
calc.sumar(5, 3);
// Output:
// Llamando sumar con args: [ 5, 3 ]
// sumar retornó: 8

// Decorador que valida
function Validar(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = function (...args: any[]) {
    if (args.some(arg => arg === null || arg === undefined)) {
      throw new Error(`${propertyKey}: argumentos no pueden ser null`);
    }
    return originalMethod.apply(this, args);
  };

  return descriptor;
}

class BaseDatos {
  @Validar
  guardar(id: number, datos: any): void {
    console.log(`Guardando ${id}:`, datos);
  }
}

const db = new BaseDatos();
db.guardar(1, { nombre: "Test" });   // ✓
db.guardar(null, { nombre: "Test" }); // ✗ Error
----

===== Decoradores de Propiedades

[source,typescript]
----
// Decorador que rastrea cambios
function Track(target: any, propertyKey: string) {
  let value = target[propertyKey];

  const getter = () => {
    console.log(`Leyendo ${propertyKey}: ${value}`);
    return value;
  };

  const setter = (newValue: any) => {
    console.log(`Escribiendo ${propertyKey}: ${value} → ${newValue}`);
    value = newValue;
  };

  Object.defineProperty(target, propertyKey, {
    get: getter,
    set: setter,
    enumerable: true,
    configurable: true
  });
}

class Cuenta {
  @Track
  saldo: number = 1000;
}

const cuenta = new Cuenta();
console.log(cuenta.saldo);    // Leyendo saldo: 1000
cuenta.saldo = 1500;          // Escribiendo saldo: 1000 → 1500
----

===== Decoradores Personalizados

[source,typescript]
----
// Factory de decorador con opciones
function Documenter(especificacion: string) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    descriptor.value._documentacion = especificacion;
    return descriptor;
  };
}

class API {
  @Documenter("Obtiene un usuari por su ID")
  obtenerUsuario(id: number) {
    return { id, nombre: "Juan" };
  }

  @Documenter("Crea un nuevo usuario")
  crearUsuario(datos: any) {
    return { id: 1, ...datos };
  }
}

const api = new API();
console.log(api.obtenerUsuario._documentacion);
// "Obtiene un usuario por su ID"

// Decorador para medir tiempo
function MedirTiempo(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = async function (...args: any[]) {
    const inicio = performance.now();
    const resultado = await originalMethod.apply(this, args);
    const duracion = performance.now() - inicio;
    console.log(`${propertyKey} tardó ${duracion.toFixed(2)}ms`);
    return resultado;
  };

  return descriptor;
}

class Servicio {
  @MedirTiempo
  async consultarAPI(): Promise<void> {
    await new Promise(resolve => setTimeout(resolve, 100));
  }
}

const servicio = new Servicio();
await servicio.consultarAPI();  // "consultarAPI tardó 100.xxms"
----

===== Ejercicios Propuestos

.1. Tipos utilitarios en práctica:
[source,typescript]
----
// Crear interfaz Película con:
// id, título, director, año, presupuesto, ingresos
// Pick para formulario creación (sin id, sin ingresos)
// Omit para respuesta pública (sin presupuesto)
// Partial para actualizaciones
----

.2. Mapped types personalizados:
[source,typescript]
----
// Crear mapped type que genere propiedades de validación
// Para Usuario { nombre: string, edad: number }
// Resulte en { nombreValido: boolean, edadValida: boolean }
----

.3. Tipos condicionales:
[source,typescript]
----
// Crear tipo que determine si algo es array
// Si es array, extrae el tipo del elemento
// Si no, retorna el tipo mismo
----

.4. Decorador personalizado:
[source,typescript]
----
// Crear decorador @Cache que cachee resultado de método
// Segunda llamada retorna valor en cache
// Implementar para método que simula consulta lenta
----


=== Módulo 9: Módulos y Namespaces

Los módulos son la forma moderna de organizar código en proyectos grandes. TypeScript amplía el sistema de módulos de JavaScript con características de tipo.

==== 9.1 Módulos: import/export

Un **módulo** es un archivo que contiene código reutilizable. Las palabras clave `export` e `import` permiten compartir código entre módulos.

===== Export de declaraciones

[source,typescript]
----
// usuario.ts
export interface Usuario {
  id: number;
  nombre: string;
  email: string;
}

export class UsuarioServicio {
  private usuarios: Usuario[] = [];

  agregar(usuario: Usuario): void {
    this.usuarios.push(usuario);
  }

  obtener(id: number): Usuario | undefined {
    return this.usuarios.find(u => u.id === id);
  }

  obtenerTodos(): Usuario[] {
    return [...this.usuarios];
  }
}

// Constantes exportadas
export const LONGITUD_MINIMA_NOMBRE = 2;
export const LONGITUD_MAXIMA_NOMBRE = 100;

// Tipos exportados
export type DatosUsuario = Omit<Usuario, "id">;
----

===== Import de módulos

[source,typescript]
----
// app.ts
import { Usuario, UsuarioServicio, LONGITUD_MINIMA_NOMBRE } from "./usuario";

const servicio = new UsuarioServicio();

const nuevoUsuario: Usuario = {
  id: 1,
  nombre: "Juan",
  email: "juan@example.com"
};

servicio.agregar(nuevoUsuario);

const usuario = servicio.obtener(1);
console.log(usuario?.nombre);  // "Juan"
----

===== Imports selectivos y namespace imports

[source,typescript]
----
// Import selectivo - solo lo que necesitas
import { Usuario, LONGITUD_MINIMA_NOMBRE } from "./usuario";

// Namespace import - todo bajo un nombre
import * as usuarioModule from "./usuario";

const servicio = new usuarioModule.UsuarioServicio();
const minimo = usuarioModule.LONGITUD_MINIMA_NOMBRE;

// Aliasing
import { Usuario as User, UsuarioServicio as UserService } from "./usuario";

const service = new UserService();
const user: User = {
  id: 1,
  nombre: "María",
  email: "maria@example.com"
};
----

===== Re-export

Redirige exportaciones de otros módulos.

[source,typescript]
----
// tipos.ts
export interface Usuario {
  id: number;
  nombre: string;
}

export interface Producto {
  id: number;
  nombre: string;
  precio: number;
}

// index.ts (barril)
// Re-exporta todos los tipos en un lugar central
export * from "./tipos";
export * from "./usuario";
export * from "./producto";

// En la aplicación
import { Usuario, Producto, UsuarioServicio } from "./index";
// Mucho más limpio que importar de múltiples archivos
----


==== 9.2 Exportaciones Nombradas y por Defecto

===== Export Nombrado

[source,typescript]
----
// autores.ts
export interface Autor {
  nombre: string;
  email: string;
}

export const obtenerAutores = (): Autor[] => [
  { nombre: "Juan", email: "juan@example.com" },
  { nombre: "María", email: "maria@example.com" }
];

export class RepositorioAutores {
  private autores: Autor[] = [];

  registrar(autor: Autor): void {
    this.autores.push(autor);
  }
}

// Importar con nombres
import { Autor, obtenerAutores, RepositorioAutores } from "./autores";
----

===== Export por Defecto

Cada módulo puede tener **un** export por defecto.

[source,typescript]
----
// logger.ts
export interface LogConfig {
  nivel: "info" | "warn" | "error";
}

class Logger {
  private config: LogConfig;

  constructor(config: LogConfig) {
    this.config = config;
  }

  log(mensaje: string): void {
    const timestamp = new Date().toISOString();
    console.log(`[${timestamp}] ${mensaje}`);
  }

  error(error: Error): void {
    console.error(`Error: ${error.message}`);
  }
}

export default Logger;

// Importar default export
import Logger from "./logger";

const logger = new Logger({ nivel: "info" });
logger.log("Aplicación iniciada");
----

===== Mixtura de imports por defecto y nombrados

[source,typescript]
----
// base-datos.ts
export interface ConfigDB {
  host: string;
  puerto: number;
}

class BaseDatos {
  private config: ConfigDB;

  constructor(config: ConfigDB) {
    this.config = config;
  }

  conectar(): void {
    console.log(`Conectando a ${this.config.host}:${this.config.puerto}`);
  }
}

export default BaseDatos;

// app.ts
import BaseDatos, { ConfigDB } from "./base-datos";

const config: ConfigDB = {
  host: "localhost",
  puerto: 5432
};

const db = new BaseDatos(config);
db.conectar();
----

===== Renombrando exports

[source,typescript]
----
// utilidades.ts
export const sumar = (a: number, b: number): number => a + b;
export const restar = (a: number, b: number): number => a - b;
export const multiplicar = (a: number, b: number): number => a * b;

// Renombrar al importar
import { 
  sumar as add, 
  restar as subtract, 
  multiplicar as multiply 
} from "./utilidades";

console.log(add(5, 3));      // 8
console.log(subtract(10, 4)); // 6
console.log(multiply(2, 3));  // 6
----


==== 9.3 Resolución de Módulos

TypeScript busca módulos siguiendo reglas específicas.

===== Module Resolution: Node vs Classic

[source,json]
----
// tsconfig.json - Node (recomendado)
{
  "compilerOptions": {
    "moduleResolution": "node",
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true
  }
}
----

===== Rutas de búsqueda y baseUrl

[source,json]
----
// tsconfig.json
{
  "compilerOptions": {
    "moduleResolution": "node",
    "baseUrl": "src",
    "paths": {
      "@utilidades/*": ["utils/*"],
      "@modelos/*": ["models/*"],
      "@servicios/*": ["services/*"]
    }
  }
}
----

[source,typescript]
----
// Estructura:
// src/
//   utils/
//     math.ts
//   models/
//     usuario.ts
//   services/
//     autenticacion.ts

// Sin paths:
import { sumar } from "../../utils/math";
import { Usuario } from "../../models/usuario";

// Con paths (mucho más limpio):
import { sumar } from "@utilidades/math";
import { Usuario } from "@modelos/usuario";
import { autenticar } from "@servicios/autenticacion";
----

===== Resolución de módulos en Node

[source,typescript]
----
// Búsqueda de módulo "xyz":

// 1. Si es ruta relativa (./xyz, ../xyz)
//    Busca archivo exacto o .ts/.js

// 2. Si es sin ruta (xyz)
//    Busca en node_modules/xyz
//    Consulta package.json de xyz

// Ejemplo: importar paquete externo
import express from "express";
// Busca:
// node_modules/express/index.js (o .ts)
// O el archivo especificado en package.json de express

// Ejemplo: módulo local
import { utils } from "./utils";
// Busca:
// 1. ./utils.ts
// 2. ./utils.js
// 3. ./utils/index.ts
// 4. ./utils/index.js
----

===== Extensiones y omisión

[source,typescript]
----
// Las extensiones son opcionales:
import { Usuario } from "./usuario";     // Funciona
import { Usuario } from "./usuario.ts";  // También funciona

// Para carpetas, busca index:
import { help } from "./utils";
// Busca:
// utils/index.ts
// utils/index.js

// Si tienes:
// utils/
//   index.ts
//   helpers.ts

// Estos son equivalentes:
import { help } from "./utils";          // ✓
import { help } from "./utils/index";    // ✓
----


==== 9.4 Declaración de Tipos con .d.ts

Los archivos `.d.ts` contienen solo **declaraciones de tipos**, sin implementación.

===== Crear archivo .d.ts

[source,typescript]
----
// usuario.d.ts
// Solo tipos, sin implementación

export interface Usuario {
  id: number;
  nombre: string;
  email: string;
  activo: boolean;
}

export interface UsuarioInput {
  nombre: string;
  email: string;
}

export class UsuarioServicio {
  agregar(usuario: UsuarioInput): Usuario;
  obtener(id: number): Usuario | undefined;
  obtenerTodos(): Usuario[];
  actualizar(id: number, datos: Partial<Usuario>): void;
}

export function validarEmail(email: string): boolean;
export function hashPassword(password: string): string;

export const LONGITUD_MINIMA_PASSWORD: number;
----

===== Usar archivo .d.ts con implementación JavaScript

Ideal para acoplar TypeScript a código JavaScript existente.

[source,typescript]
----
// usuario.js (javascript puro)
class UsuarioServicio {
  constructor() {
    this.usuarios = [];
  }

  agregar(usuario) {
    this.usuarios.push(usuario);
    return { id: this.usuarios.length, ...usuario };
  }

  obtener(id) {
    return this.usuarios.find(u => u.id === id);
  }

  obtenerTodos() {
    return [...this.usuarios];
  }
}

function validarEmail(email) {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

module.exports = { UsuarioServicio, validarEmail };

// usuario.d.ts (TypeScript declara los tipos)
export interface Usuario {
  id: number;
  nombre: string;
  email: string;
}

export class UsuarioServicio {
  agregar(usuario: Usuario): Usuario;
  obtener(id: number): Usuario | undefined;
  obtenerTodos(): Usuario[];
}

export function validarEmail(email: string): boolean;

// app.ts (TypeScript usa los tipos del .d.ts)
import { UsuarioServicio, validarEmail } from "./usuario";

const servicio = new UsuarioServicio();
const esValido = validarEmail("test@example.com");

servicio.agregar({
  id: 1,
  nombre: "Juan",
  email: "juan@example.com"
});
----

===== Ejemplo práctico: Tipificar librería JavaScript

[source,typescript]
----
// math-lib.js (librería sin tipos)
function sumar(a, b) {
  return a + b;
}

function restar(a, b) {
  return a - b;
}

function promedio(...numeros) {
  return numeros.reduce((a, b) => a + b, 0) / numeros.length;
}

module.exports = { sumar, restar, promedio };

// math-lib.d.ts (tipos para la librería)
export function sumar(a: number, b: number): number;
export function restar(a: number, b: number): number;
export function promedio(...numeros: number[]): number;

// app.ts
import { sumar, restar, promedio } from "./math-lib";

const resultado = sumar(5, 3);           // ✓ Tipo number
const resta = restar(10, 4);             // ✓ Tipo number
const avg = promedio(1, 2, 3, 4, 5);    // ✓ Tipo number

// Error detectado por TypeScript
const error = sumar("5", 3);  // ✗ Error: Argument of type 'string' is not assignable
----

===== Generating .d.ts automáticamente

TypeScript puede generar archivos `.d.ts` desde código TypeScript.

[source,json]
----
// tsconfig.json
{
  "compilerOptions": {
    "declaration": true,
    "declarationDir": "types",
    "emitDeclarationOnly": false,
    "outDir": "dist"
  }
}
----

[source,typescript]
----
// servicio.ts
export interface Config {
  timeout: number;
}

export class Servicio {
  private config: Config;

  constructor(config: Config) {
    this.config = config;
  }

  procesar(): void {
    console.log(`Procesando con timeout ${this.config.timeout}`);
  }
}

// Al compilar con declaration: true, genera:
// types/servicio.d.ts
// {
//   export interface Config {
//     timeout: number;
//   }
//   export class Servicio {
//     constructor(config: Config);
//     procesar(): void;
//   }
// }
----

===== Triple-slash directives para referencias

[source,typescript]
----
// types/global.d.ts
export interface Window {
  miVariable: string;
  miFuncion(): void;
}

// app.ts
/// <reference path="./types/global.d.ts" />

// Ahora TypeScript conoce los tipos definidos
declare global {
  interface Window {
    miAPI: {
      obtener(): Promise<any>;
    };
  }
}

window.miAPI.obtener();  // ✓ TypeScript lo conoce
----

===== Organizar tipos en un proyecto

[source,typescript]
----
// types/index.d.ts (barril para tipos)
export * from "./usuario";
export * from "./producto";
export * from "./pedido";

// types/usuario.d.ts
export interface Usuario {
  id: number;
  nombre: string;
}

// types/producto.d.ts
export interface Producto {
  id: number;
  nombre: string;
  precio: number;
}

// app.ts
import { Usuario, Producto } from "./types";

const usuario: Usuario = { id: 1, nombre: "Juan" };
const producto: Producto = { id: 1, nombre: "Laptop", precio: 999 };
----


==== Ejemplo Integrado: Sistema Modular Completo

Estructura de proyecto:

[source,text]
----
src/
  types/
    index.d.ts
    usuario.d.ts
    producto.d.ts
  models/
    usuario.ts
    producto.ts
  services/
    autenticacion.ts
    carrito.ts
  utils/
    validacion.ts
    conversor.ts
  index.ts
----

[source,typescript]
----
// src/types/usuario.d.ts
export interface Usuario {
  id: number;
  nombre: string;
  email: string;
  activo: boolean;
}

export interface LoginCredentials {
  email: string;
  contraseña: string;
}

// src/types/producto.d.ts
export interface Producto {
  id: number;
  nombre: string;
  precio: number;
  stock: number;
}

// src/types/index.d.ts (barril)
export * from "./usuario";
export * from "./producto";

// src/models/usuario.ts
import { Usuario, LoginCredentials } from "../types";

export class UsuarioModelo {
  static async obtener(id: number): Promise<Usuario> {
    // Simulación de obtención de DB
    return {
      id,
      nombre: "Juan",
      email: "juan@example.com",
      activo: true
    };
  }

  static async autenticar(creds: LoginCredentials): Promise<Usuario> {
    // Lógica de autenticación
    return {
      id: 1,
      nombre: "Juan",
      email: creds.email,
      activo: true
    };
  }
}

// src/services/autenticacion.ts
import { Usuario, LoginCredentials } from "../types";
import { UsuarioModelo } from "../models/usuario";

export class ServicioAutenticacion {
  async login(credenciales: LoginCredentials): Promise<Usuario> {
    const usuario = await UsuarioModelo.autenticar(credenciales);
    console.log(`Usuario ${usuario.nombre} autenticado`);
    return usuario;
  }

  async logout(usuario: Usuario): Promise<void> {
    console.log(`Cerrando sesión de ${usuario.nombre}`);
  }
}

// src/index.ts (punto de entrada)
export * from "./types";
export { UsuarioModelo } from "./models/usuario";
export { ServicioAutenticacion } from "./services/autenticacion";

// En otra aplicación
// app.ts
import { 
  Usuario, 
  LoginCredentials, 
  UsuarioModelo,
  ServicioAutenticacion 
} from "./src";

const credenciales: LoginCredentials = {
  email: "juan@example.com",
  contraseña: "password123"
};

const auth = new ServicioAutenticacion();
const usuario = await auth.login(credenciales);
console.log(`Bienvenido ${usuario.nombre}`);
----


==== Ejercicios Propuestos

.1. Módulos básicos:
[source,typescript]
----
// Crear módulo calculadora.ts con:
// - Funciones: sumar, restar, multiplicar, dividir
// - Export nombrado para cada función
// - Crear app.ts que importe y use todas las funciones
----

.2. Export por defecto:
[source,typescript]
----
// Crear clase Persona con:
// - propiedades: nombre, edad, email
// - método: presentarse()
// - Export por defecto la clase
// - Import con nombre diferente en otro archivo
----

.3. Tipos con .d.ts:
[source,typescript]
----
// Criar librería math.js en JavaScript puro
// Crear math.d.ts con tipos
// Usar en TypeScript con verificación de tipos
----

.4. Organización de módulos:
[source,typescript]
----
// Crear estructura de proyecto:
// src/
//   models/
//   services/
//   types/
//   utils/
// Con relaciones entre módulos (imports cruzados)
// Usar paths en tsconfig.json para simplificar imports
----


=== Módulo 10: Programación Asincrónica

Las operaciones asincrónicas (entrada/salida, redes, temporizadores) son fundamentales en JavaScript. TypeScript proporciona tipos para escribir código asincrónico seguro.

==== 10.1 Promises y Tipado

Una **Promise** representa una operación que se completará en el futuro con un valor o error.

===== Promise básica

[source,typescript]
----
// Promise<T> - se resuelve con valor de tipo T
const promesa: Promise<string> = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Operación completada");
  }, 1000);
});

promesa.then(resultado => {
  console.log(resultado);  // "Operación completada"
});

// Promise que rechaza
const promesaRechazada: Promise<never> = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(new Error("Algo salió mal"));
  }, 1000);
});

promesaRechazada.catch(error => {
  console.error(error.message);  // "Algo salió mal"
});
----

===== Encadenar promises con then

[source,typescript]
----
interface Usuario {
  id: number;
  nombre: string;
}

function obtenerUsuario(id: number): Promise<Usuario> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id, nombre: "Juan" });
    }, 500);
  });
}

function obtenerAmigos(usuarioId: number): Promise<Usuario[]> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        { id: 2, nombre: "María" },
        { id: 3, nombre: "Carlos" }
      ]);
    }, 500);
  });
}

// Encadenar promises
obtenerUsuario(1)
  .then(usuario => {
    console.log("Usuario:", usuario.nombre);
    return obtenerAmigos(usuario.id);
  })
  .then(amigos => {
    console.log("Amigos:", amigos.map(a => a.nombre));
  })
  .catch(error => {
    console.error("Error:", error);
  });
----

===== Resolver múltiples promises

[source,typescript]
----
interface Datos {
  usuarios: Usuario[];
  productos: { id: number; nombre: string }[];
  estadisticas: { total: number };
}

const p1 = new Promise<Usuario[]>(resolve => {
  setTimeout(() => resolve([{ id: 1, nombre: "Juan" }]), 500);
});

const p2 = new Promise<{ id: number; nombre: string }[]>(resolve => {
  setTimeout(() => resolve([{ id: 1, nombre: "Laptop" }]), 500);
});

const p3 = new Promise<{ total: number }>(resolve => {
  setTimeout(() => resolve({ total: 100 }), 500);
});

// Promise.all - espera todas las promises
Promise
  .all([p1, p2, p3])
  .then(([usuarios, productos, stats]) => {
    const datos: Datos = {
      usuarios,
      productos,
      estadisticas: stats
    };
    console.log(datos);
  });

// Promise.race - retorna la primera que se complete
Promise.race([p1, p2, p3])
  .then(resultado => {
    console.log("Primera completada:", resultado);
  });

// Promise.allSettled - espera todas, incluso si fallan
Promise.allSettled([p1, p2, p3])
  .then(resultados => {
    resultados.forEach((resultado, index) => {
      if (resultado.status === "fulfilled") {
        console.log(`Promise ${index} completada:`, resultado.value);
      } else {
        console.log(`Promise ${index} rechazada:`, resultado.reason);
      }
    });
  });
----

===== Crear promesas de tipos complejos

[source,typescript]
----
interface Respuesta<T> {
  datos: T;
  estado: "éxito" | "error";
  mensaje: string;
}

function obtenerDatos<T>(ruta: string): Promise<Respuesta<T>> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() > 0.5) {
        resolve({
          datos: {} as T,
          estado: "éxito",
          mensaje: "Datos obtenidos"
        });
      } else {
        reject(new Error("Error en la solicitud"));
      }
    }, 1000);
  });
}

// Usar con tipos genéricos
obtenerDatos<Usuario>("/api/usuarios")
  .then(respuesta => {
    console.log(respuesta.datos);  // Tipo: Usuario
  });

obtenerDatos<string[]>("/api/etiquetas")
  .then(respuesta => {
    console.log(respuesta.datos);  // Tipo: string[]
  });
----


==== 10.2 async/await en TypeScript

**async/await** simplifica el código asincrónico, permitiendo escribir código que parece síncrono.

===== Función async básica

[source,typescript]
----
// Una función async siempre retorna Promise
async function saludar(): Promise<string> {
  return "Hola";
}

// Equivalente a:
function saludar2(): Promise<string> {
  return Promise.resolve("Hola");
}

// Llamar una función async
const resultado = await saludar();
console.log(resultado);  // "Hola"
----

===== await dentro de funciones async

[source,typescript]
----
interface Usuario {
  id: number;
  nombre: string;
}

function obtenerUsuario(id: number): Promise<Usuario> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id, nombre: "Juan" });
    }, 500);
  });
}

function obtenerAmigos(usuarioId: number): Promise<Usuario[]> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        { id: 2, nombre: "María" },
        { id: 3, nombre: "Carlos" }
      ]);
    }, 500);
  });
}

// Con await - mucho más legible que .then()
async function obtenerInfoUsuario(id: number): Promise<void> {
  const usuario = await obtenerUsuario(id);
  console.log(`Usuario: ${usuario.nombre}`);

  const amigos = await obtenerAmigos(usuario.id);
  console.log(`Amigos: ${amigos.map(a => a.nombre).join(", ")}`);
}

// Llamar
await obtenerInfoUsuario(1);
----

===== async/await con tipos explícitos

[source,typescript]
----
interface BaseDatos {
  conectar(): Promise<void>;
  consulta(sql: string): Promise<any[]>;
  desconectar(): Promise<void>;
}

async function consultarDatos(): Promise<Usuario[]> {
  const db: BaseDatos = {
    conectar: async () => console.log("Conectando..."),
    consulta: async (sql) => [{ id: 1, nombre: "Juan" }],
    desconectar: async () => console.log("Desconectando...")
  };

  await db.conectar();
  const usuarios: Usuario[] = await db.consulta("SELECT * FROM usuarios");
  await db.desconectar();

  return usuarios;
}

// Tipo de retorno debe coincidir
const usuarios: Promise<Usuario[]> = consultarDatos();
----

===== Operaciones paralelas con async/await

[source,typescript]
----
async function obtenerDatosCompletos(): Promise<{
  usuarios: Usuario[];
  amigos: Usuario[];
}> {
  // Secuencial (lento):
  const usuarios = await obtenerUsuario(1);
  const amigos = await obtenerAmigos(usuarios.id);

  // Paralelo (rápido):
  const [usuario, amigosList] = await Promise.all([
    obtenerUsuario(1),
    obtenerAmigos(1)
  ]);

  return {
    usuarios: [usuario],
    amigos: amigosList
  };
}

// Race - primera que se complete
async function obtenerPrimero(): Promise<Usuario> {
  const resultado = await Promise.race([
    obtenerUsuario(1),
    obtenerUsuario(2),
    obtenerUsuario(3)
  ]);
  return resultado;
}
----

===== Tipado de callbacks en async

[source,typescript]
----
type CallbackFuncion<T> = (error: Error | null, resultado?: T) => void;

async function conCallback<T>(
  tarea: Promise<T>,
  callback: CallbackFuncion<T>
): Promise<void> {
  try {
    const resultado = await tarea;
    callback(null, resultado);
  } catch (error) {
    callback(error instanceof Error ? error : new Error(String(error)));
  }
}

// Usar
conCallback(
  obtenerUsuario(1),
  (error, usuario) => {
    if (error) {
      console.error("Error:", error.message);
    } else {
      console.log("Usuario:", usuario?.nombre);
    }
  }
);
----


==== 10.3 Manejo de Errores Asincrónico

===== try/catch en funciones async

[source,typescript]
----
async function obtenerDatosSeguro(): Promise<Usuario | null> {
  try {
    const usuario = await obtenerUsuario(1);
    console.log("Usuario obtenido:", usuario.nombre);
    return usuario;
  } catch (error) {
    // error es de tipo unknown
    if (error instanceof Error) {
      console.error("Error:", error.message);
    } else {
      console.error("Error desconocido:", error);
    }
    return null;
  }
}

await obtenerDatosSeguro();
----

===== Discriminar tipos de error

[source,typescript]
----
interface ErrorRespuesta {
  codigo: string;
  mensaje: string;
}

interface ErrorRed {
  tipo: "RED";
  razon: string;
}

interface ErrorBD {
  tipo: "BD";
  sql: string;
  mensaje: string;
}

type ErrorPersonalizado = ErrorRespuesta | ErrorRed | ErrorBD;

async function consultarBD(): Promise<Usuario[]> {
  try {
    // Simular consulta
    const usuarios = await obtenerUsuario(1);
    return [usuarios];
  } catch (error) {
    if (error instanceof TypeError) {
      // Error de tipo
      const err: ErrorRed = {
        tipo: "RED",
        razon: error.message
      };
      throw err;
    } else if (error instanceof SyntaxError) {
      // Error de parsing
      throw new Error("Respuesta inválida");
    } else {
      throw error;
    }
  }
}

async function manejarErrores(): Promise<void> {
  try {
    await consultarBD();
  } catch (error) {
    const err = error as ErrorPersonalizado;
    if ("tipo" in err && err.tipo === "RED") {
      console.error("Error de red:", (err as ErrorRed).razon);
    } else if ("codigo" in err) {
      console.error("Error de respuesta:", (err as ErrorRespuesta).mensaje);
    }
  }
}
----

===== finally en promises

[source,typescript]
----
async function operacionConLimpieza(): Promise<void> {
  let conexion: any = null;

  try {
    conexion = await conectarBD();
    const usuarios = await consultarUsuarios(conexion);
    console.log("Usuarios:", usuarios);
  } catch (error) {
    console.error("Error:", error);
  } finally {
    if (conexion) {
      await desconectar(conexion);
      console.log("Conexión cerrada");
    }
  }
}

// Simulación de funciones
async function conectarBD(): Promise<any> {
  return { id: "conexion-1" };
}

async function consultarUsuarios(conn: any): Promise<Usuario[]> {
  return [{ id: 1, nombre: "Juan" }];
}

async function desconectar(conn: any): Promise<void> {
  console.log("Desconectando...");
}
----

===== Crear errores personalizados

[source,typescript]
----
class ErrorAPI extends Error {
  constructor(
    public statusCode: number,
    mensaje: string
  ) {
    super(mensaje);
    this.name = "ErrorAPI";
    Object.setPrototypeOf(this, ErrorAPI.prototype);
  }
}

class ErrorValidacion extends Error {
  constructor(
    public campo: string,
    public valor: any
  ) {
    super(`Validación fallida para ${campo}`);
    this.name = "ErrorValidacion";
    Object.setPrototypeOf(this, ErrorValidacion.prototype);
  }
}

async function validarYGuardar(usuario: Partial<Usuario>): Promise<Usuario> {
  if (!usuario.nombre) {
    throw new ErrorValidacion("nombre", usuario.nombre);
  }

  try {
    // Simular solicitud API
    if (Math.random() > 0.5) {
      throw new ErrorAPI(500, "Error del servidor");
    }
    return { id: 1, ...usuario as Usuario };
  } catch (error) {
    if (error instanceof ErrorAPI) {
      console.error(`API Error (${error.statusCode}): ${error.message}`);
    } else if (error instanceof ErrorValidacion) {
      console.error(`Validación Error (${error.campo}): ${error.message}`);
    }
    throw error;
  }
}

// Usar
try {
  await validarYGuardar({ nombre: "Juan" });
} catch (error) {
  // Manejar error
}
----

===== Utilidades para manejo de errores

[source,typescript]
----
// Función helper para ejecutar y retornar resultado o error
async function ejecutar<T>(
  promesa: Promise<T>
): Promise<[T, null] | [null, Error]> {
  try {
    const resultado = await promesa;
    return [resultado, null];
  } catch (error) {
    return [null, error instanceof Error ? error : new Error(String(error))];
  }
}

// Usar sin try/catch
const [usuario, error] = await ejecutar(obtenerUsuario(1));

if (error) {
  console.error("Error:", error.message);
} else {
  console.log("Usuario:", usuario?.nombre);
}

// Reintentos con exponential backoff
async function reintentarConExponential<T>(
  tarea: () => Promise<T>,
  maxIntentos: number = 3,
  delayInicial: number = 1000
): Promise<T> {
  let ultimoError: Error | undefined;

  for (let intento = 0; intento < maxIntentos; intento++) {
    try {
      return await tarea();
    } catch (error) {
      ultimoError = error instanceof Error ? error : new Error(String(error));
      const delay = delayInicial * Math.pow(2, intento);
      console.log(`Intento ${intento + 1} falló, reintentando en ${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }

  throw ultimoError;
}

// Usar
const usuarioConReintentos = await reintentarConExponential(
  () => obtenerUsuario(1),
  3,
  500
);
----


==== 10.4 Tipos para Callbacks y Eventos

===== EventEmitter con tipos

[source,typescript]
----
type EventoListener<T> = (datos: T) => void | Promise<void>;

interface Eventos {
  "usuario-registrado": { id: number; nombre: string };
  "usuario-eliminado": { id: number };
  "error": { mensaje: string; codigo: number };
}

class EmisoreEvento<T extends Record<string, any>> {
  private listeners: Map<string, EventoListener<any>[]> = new Map();

  on<K extends keyof T>(evento: K, listener: EventoListener<T[K]>): void {
    if (!this.listeners.has(String(evento))) {
      this.listeners.set(String(evento), []);
    }
    this.listeners.get(String(evento))!.push(listener);
  }

  async emit<K extends keyof T>(evento: K, datos: T[K]): Promise<void> {
    const listeners = this.listeners.get(String(evento)) || [];
    for (const listener of listeners) {
      await listener(datos);
    }
  }

  off<K extends keyof T>(evento: K, listener: EventoListener<T[K]>): void {
    const listeners = this.listeners.get(String(evento)) || [];
    const index = listeners.indexOf(listener);
    if (index > -1) {
      listeners.splice(index, 1);
    }
  }
}

// Usar
const emisor = new EmisoreEvento<Eventos>();

emisor.on("usuario-registrado", (usuario) => {
  console.log(`Nuevo usuario: ${usuario.nombre}`);
});

emisor.on("error", (error) => {
  console.error(`Error ${error.codigo}: ${error.mensaje}`);
});

await emisor.emit("usuario-registrado", { id: 1, nombre: "Juan" });
await emisor.emit("error", { mensaje: "Algo salió mal", codigo: 500 });
----

===== Callbacks tipados

[source,typescript]
----
type CallbackExito<T> = (resultado: T) => void;
type CallbackError = (error: Error) => void;

function procesar<T>(
  tarea: Promise<T>,
  onSuccess: CallbackExito<T>,
  onError: CallbackError
): void {
  tarea
    .then(resultado => onSuccess(resultado))
    .catch(error => onError(error instanceof Error ? error : new Error(String(error))));
}

// Usar
procesar(
  obtenerUsuario(1),
  (usuario) => {
    console.log("Éxito:", usuario.nombre);
  },
  (error) => {
    console.error("Error:", error.message);
  }
);

// Callbacks con tipado de contexto this
interface Contexto {
  nombre: string;
}

function conContexto(
  contexto: Contexto,
  callback: (this: Contexto, resultado: string) => void
): void {
  callback.call(contexto, "Resultado");
}

conContexto(
  { nombre: "Mi contexto" },
  function (resultado) {
    console.log(`${this.nombre}: ${resultado}`);
  }
);
----

===== Timing y timeouts

[source,typescript]
----
async function conTimeout<T>(
  promesa: Promise<T>,
  ms: number
): Promise<T> {
  return Promise.race([
    promesa,
    new Promise<T>((_, reject) =>
      setTimeout(
        () => reject(new Error(`Timeout después de ${ms}ms`)),
        ms
      )
    )
  ]);
}

// Usar
try {
  const resultado = await conTimeout(obtenerUsuario(1), 5000);
  console.log(resultado);
} catch (error) {
  console.error("Timeout o error:", (error as Error).message);
}

// Delay helper
async function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function conDelay(): Promise<void> {
  console.log("Esperando...");
  await delay(2000);
  console.log("Listo!");
}

// Debounce con tipos
function debounce<T extends any[], R>(
  func: (...args: T) => Promise<R>,
  ms: number
): (...args: T) => Promise<R> {
  let timeoutId: NodeJS.Timeout;
  let ultimoResultado: R;

  return (...args: T) => {
    clearTimeout(timeoutId);
    
    return new Promise((resolve) => {
      timeoutId = setTimeout(async () => {
        ultimoResultado = await func(...args);
        resolve(ultimoResultado);
      }, ms);
    });
  };
}

// Usar
const buscar = debounce(async (termino: string) => {
  return await obtenerUsuario(parseInt(termino));
}, 500);

await buscar("1");
----


==== Ejemplo Integrado: Gestor de Solicitudes HTTP Tipado

[source,typescript]
----
interface Respuesta<T> {
  datos?: T;
  error?: string;
  estado: number;
}

interface ConfiguracionHTTP {
  baseURL: string;
  timeout: number;
  reintentos: number;
}

class ClienteHTTP {
  constructor(private config: ConfiguracionHTTP) {}

  async get<T>(ruta: string): Promise<T> {
    return this.solicitud<T>("GET", ruta);
  }

  async post<T>(ruta: string, datos: any): Promise<T> {
    return this.solicitud<T>("POST", ruta, datos);
  }

  private async solicitud<T>(
    metodo: "GET" | "POST",
    ruta: string,
    datos?: any
  ): Promise<T> {
    const url = `${this.config.baseURL}${ruta}`;

    for (let intento = 0; intento < this.config.reintentos; intento++) {
      try {
        const respuesta = await conTimeout(
          this.hacerSolicitud<T>(metodo, url, datos),
          this.config.timeout
        );
        return respuesta;
      } catch (error) {
        if (intento === this.config.reintentos - 1) {
          throw error;
        }
        await delay(1000 * (intento + 1));
      }
    }

    throw new Error("Solicitud fallida después de reintentos");
  }

  private async hacerSolicitud<T>(
    metodo: string,
    url: string,
    datos?: any
  ): Promise<T> {
    // Simular solicitud HTTP
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (Math.random() > 0.3) {
          resolve({ id: 1, nombre: "Juan" } as T);
        } else {
          reject(new Error("Error de red"));
        }
      }, 500);
    });
  }
}

// Usar
const cliente = new ClienteHTTP({
  baseURL: "https://api.example.com",
  timeout: 5000,
  reintentos: 3
});

try {
  const usuario = await cliente.get<Usuario>("/usuarios/1");
  console.log("Usuario:", usuario.nombre);
} catch (error) {
  console.error("Error:", (error as Error).message);
}
----


==== Ejercicios Propuestos

.1. Promise typing:
[source,typescript]
----
// Crear función que retorne Promise<Usuario[]>
// Usar Promise.all para obtener múltiples usuarios en paralelo
// Manejar errores con .catch()
----

.2. async/await:
[source,typescript]
----
// Reescribir el ejercicio anterior con async/await
// Usar await para obtener usuarios secuencialmente
// Convertir a paralelo con Promise.all()
----

.3. Manejo de errores:
[source,typescript]
----
// Crear clase ErrorPersonalizado extendiendo Error
// Crear función async que lance este error
// try/catch con discriminación de tipos de error
----

.4. EventEmitter:
[source,typescript]
----
// Crear clase RepositorioUsuarios que emita eventos:
// - usuario-creado
// - usuario-eliminado
// - error
// Suscribirse a los eventos y manejarlos
----


=== Módulo 11: Iteradores y Generadores

Los iteradores y generadores permiten recorrer secuencias de datos de forma flexible. TypeScript proporciona tipos para trabajar con estos conceptos.

==== 11.1 Iterables e Iteradores

Un **iterable** es un objeto que puede ser iterado. Un **iterador** es el objeto que controla la iteración.

===== Protocolos de iteración

[source,typescript]
----
// El protocolo Iterable requiere Symbol.iterator
interface Iterable<T> {
  [Symbol.iterator](): Iterator<T>;
}

// El protocolo Iterator requiere next()
interface Iterator<T> {
  next(): IteratorResult<T>;
}

interface IteratorResult<T> {
  value?: T;
  done: boolean;
}

// Ejemplo: Array es iterable
const numeros = [1, 2, 3];

// Obtener el iterador
const iterador = numeros[Symbol.iterator]();

// Usar el iterador
console.log(iterador.next());  // { value: 1, done: false }
console.log(iterador.next());  // { value: 2, done: false }
console.log(iterador.next());  // { value: 3, done: false }
console.log(iterador.next());  // { value: undefined, done: true }
----

===== Crear clase iterable

[source,typescript]
----
class Rango implements Iterable<number> {
  constructor(
    private inicio: number,
    private fin: number,
    private paso: number = 1
  ) {}

  // Implementar el protocolo Iterable
  [Symbol.iterator](): Iterator<number> {
    let actual = this.inicio;

    return {
      next: (): IteratorResult<number> => {
        if (actual <= this.fin) {
          const value = actual;
          actual += this.paso;
          return { value, done: false };
        } else {
          return { done: true };
        }
      }
    };
  }
}

// Usar
const rango = new Rango(1, 5);

for (const num of rango) {
  console.log(num);  // 1, 2, 3, 4, 5
}

const array = [...rango];  // [1, 2, 3, 4, 5]
----

===== Iteradores personalizados con tipos complejos

[source,typescript]
----
interface Item<T> {
  valor: T;
  siguiente?: Item<T>;
}

class ListaEnlazada<T> implements Iterable<T> {
  private cabeza?: Item<T>;
  private cola?: Item<T>;

  agregar(valor: T): void {
    const nuevoItem: Item<T> = { valor };

    if (!this.cabeza) {
      this.cabeza = nuevoItem;
      this.cola = nuevoItem;
    } else {
      this.cola!.siguiente = nuevoItem;
      this.cola = nuevoItem;
    }
  }

  [Symbol.iterator](): Iterator<T> {
    let actual = this.cabeza;

    return {
      next: (): IteratorResult<T> => {
        if (actual) {
          const value = actual.valor;
          actual = actual.siguiente;
          return { value, done: false };
        } else {
          return { done: true };
        }
      }
    };
  }
}

// Usar
const lista = new ListaEnlazada<string>();
lista.agregar("A");
lista.agregar("B");
lista.agregar("C");

for (const item of lista) {
  console.log(item);  // A, B, C
}
----

===== Iteradores reversos

[source,typescript]
----
interface IterableReverso<T> extends Iterable<T> {
  [Symbol.iterator](): Iterator<T>;
  [Symbol.reverse]: () => Iterator<T>;  // Propiedad custom
}

class ArrayReverso<T> implements IterableReverso<T> {
  constructor(private datos: T[]) {}

  [Symbol.iterator](): Iterator<T> {
    let index = 0;

    return {
      next: (): IteratorResult<T> => {
        if (index < this.datos.length) {
          return { value: this.datos[index++], done: false };
        }
        return { done: true };
      }
    };
  }

  // Método custom para reverso
  *reverso(): Generator<T> {
    for (let i = this.datos.length - 1; i >= 0; i--) {
      yield this.datos[i];
    }
  }
}

// Usar
const arr = new ArrayReverso([1, 2, 3, 4, 5]);

console.log([...arr]);              // [1, 2, 3, 4, 5]
console.log([...arr.reverso()]);   // [5, 4, 3, 2, 1]
----


==== 11.2 Generadores y Funciones Generadoras

Un **generador** es una función especial que puede pausar su ejecución y reanudarla.

===== Función generadora básica

[source,typescript]
----
// Sintaxis: function*
function* contar(): Generator<number> {
  yield 1;
  yield 2;
  yield 3;
}

// Usar
for (const num of contar()) {
  console.log(num);  // 1, 2, 3
}

const generador = contar();
console.log(generador.next());  // { value: 1, done: false }
console.log(generador.next());  // { value: 2, done: false }
console.log(generador.next());  // { value: 3, done: false }
console.log(generador.next());  // { value: undefined, done: true }
----

===== Generador con parámetros

[source,typescript]
----
function* rango(inicio: number, fin: number): Generator<number> {
  for (let i = inicio; i <= fin; i++) {
    yield i;
  }
}

function* repetir<T>(valor: T, veces: number): Generator<T> {
  for (let i = 0; i < veces; i++) {
    yield valor;
  }
}

// Usar
const numeros = [...rango(1, 5)];  // [1, 2, 3, 4, 5]

const repetidos = [...repetir("A", 3)];  // ["A", "A", "A"]

for (const n of rango(10, 15)) {
  console.log(n);  // 10, 11, 12, 13, 14, 15
}
----

===== yield y delegación

[source,typescript]
----
function* delegacion1(): Generator<number> {
  yield 1;
  yield 2;
}

function* delegacion2(): Generator<number> {
  yield 3;
  yield 4;
}

function* combinado(): Generator<number> {
  // yield* delega a otro generador
  yield* delegacion1();
  yield* delegacion2();
}

// Usar
for (const n of combinado()) {
  console.log(n);  // 1, 2, 3, 4
}

// Ejemplo más práctico: Árbol
interface Nodo {
  valor: number;
  izquierda?: Nodo;
  derecha?: Nodo;
}

function* recorridoArbol(nodo: Nodo): Generator<number> {
  yield nodo.valor;
  if (nodo.izquierda) {
    yield* recorridoArbol(nodo.izquierda);
  }
  if (nodo.derecha) {
    yield* recorridoArbol(nodo.derecha);
  }
}

const arbol: Nodo = {
  valor: 1,
  izquierda: { valor: 2, izquierda: { valor: 4 } },
  derecha: { valor: 3, derecha: { valor: 5 } }
};

console.log([...recorridoArbol(arbol)]);  // [1, 2, 4, 3, 5]
----

===== Generador bidireccional

[source,typescript]
----
function* bidireccion(): Generator<number, void, number> {
  // yield puede recibir valores via .next(valor)
  let valor = yield 1;
  console.log("Recibido:", valor);

  valor = yield valor * 2;
  console.log("Recibido:", valor);

  yield valor * 3;
}

const gen = bidireccion();

console.log(gen.next());        // { value: 1, done: false }
console.log(gen.next(10));      // { value: 20, done: false }
                               // "Recibido: 10"
console.log(gen.next(5));       // { value: 15, done: false }
                               // "Recibido: 5"
console.log(gen.next());        // { value: undefined, done: true }
----

===== Generadores infinitos

[source,typescript]
----
function* infinito(): Generator<number> {
  let contador = 0;
  while (true) {
    yield contador++;
  }
}

function* fibonaci(): Generator<number> {
  let a = 0, b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

// Usar con límite
let contador = 0;
for (const num of infinito()) {
  if (contador++ >= 5) break;
  console.log(num);  // 0, 1, 2, 3, 4
}

// Primeros 10 números de Fibonacci
const fib = [...(function*() {
  let i = 0;
  for (const n of fibonaci()) {
    if (i++ >= 10) break;
    yield n;
  }
}())];

console.log(fib);  // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
----

===== Generador con tipos complejos

[source,typescript]
----
interface Usuario {
  id: number;
  nombre: string;
  rol: "admin" | "usuario";
}

function* usuarios(): Generator<Usuario> {
  const data: Usuario[] = [
    { id: 1, nombre: "Juan", rol: "admin" },
    { id: 2, nombre: "María", rol: "usuario" },
    { id: 3, nombre: "Carlos", rol: "admin" }
  ];

  for (const usuario of data) {
    yield usuario;
  }
}

function* filtrar<T>(
  gen: Iterable<T>,
  predicado: (item: T) => boolean
): Generator<T> {
  for (const item of gen) {
    if (predicado(item)) {
      yield item;
    }
  }
}

// Usar
const admins = [...filtrar(usuarios(), u => u.rol === "admin")];
console.log(admins);
// [
//   { id: 1, nombre: "Juan", rol: "admin" },
//   { id: 3, nombre: "Carlos", rol: "admin" }
// ]
----


==== 11.3 Async Iterators y Generadores Asincrónico

Permiten iterar sobre secuencias que requieren operaciones asincrónicas.

===== Iterable asincrónico

[source,typescript]
----
// AsyncIterable<T> tiene Symbol.asyncIterator
interface AsyncIterable<T> {
  [Symbol.asyncIterator](): AsyncIterator<T>;
}

// AsyncIterator<T> retorna Promises
interface AsyncIterator<T> {
  next(): Promise<IteratorResult<T>>;
}

class DescargadorDatos<T> implements AsyncIterable<T> {
  constructor(
    private datos: T[],
    private delay: number = 1000
  ) {}

  [Symbol.asyncIterator](): AsyncIterator<T> {
    let index = 0;

    return {
      next: async (): Promise<IteratorResult<T>> => {
        await new Promise(resolve => setTimeout(resolve, this.delay));

        if (index < this.datos.length) {
          return { value: this.datos[index++], done: false };
        }
        return { done: true };
      }
    };
  }
}

// Usar
const descargador = new DescargadorDatos([1, 2, 3]);

for await (const valor of descargador) {
  console.log("Recibido:", valor);
}
----

===== Generador asincrónico

[source,typescript]
----
async function* contar(): AsyncGenerator<number> {
  for (let i = 1; i <= 3; i++) {
    await new Promise(resolve => setTimeout(resolve, 1000));
    yield i;
  }
}

// Usar
for await (const num of contar()) {
  console.log(num);  // 1, 2, 3 (con espera entre cada uno)
}

// Ejemplo práctico: Obtener datos por páginas
async function* obtenerUsuariosPorPagina(
  paginas: number,
  porPagina: number = 10
): AsyncGenerator<{ id: number; nombre: string }> {
  for (let p = 1; p <= paginas; p++) {
    // Simular solicitud HTTP
    await new Promise(resolve => setTimeout(resolve, 500));

    for (let i = 1; i <= porPagina; i++) {
      const id = (p - 1) * porPagina + i;
      yield { id, nombre: `Usuario ${id}` };
    }
  }
}

// Usar
for await (const usuario of obtenerUsuariosPorPagina(2)) {
  console.log(usuario);  // Usuario 1-20 con delay entre páginas
}
----

===== Procesar streams con async generators

[source,typescript]
----
interface EventoSistema {
  tipo: "login" | "logout" | "error";
  usuario: string;
  timestamp: Date;
}

async function* procesarEventos(
  arroyoEventos: AsyncIterable<EventoSistema>
): AsyncGenerator<EventoSistema> {
  for await (const evento of arroyoEventos) {
    // Filtrar y procesar
    if (evento.tipo !== "error") {
      yield evento;
    }
  }
}

async function* enriquecerEventos(
  eventos: AsyncIterable<EventoSistema>
): AsyncGenerator<EventoSistema & { procesado: boolean }> {
  for await (const evento of eventos) {
    yield { ...evento, procesado: true };
  }
}

// Encadenar procesamiento
async function procesarArroyoCompleto() {
  const eventosOriginales = new EventosAPI();

  for await (const evento of enriquecerEventos(
    procesarEventos(eventosOriginales)
  )) {
    console.log("Evento procesado:", evento);
  }
}

// Simulación de EventosAPI
class EventosAPI implements AsyncIterable<EventoSistema> {
  async *[Symbol.asyncIterator](): AsyncGenerator<EventoSistema> {
    const eventos: EventoSistema[] = [
      { tipo: "login", usuario: "Juan", timestamp: new Date() },
      { tipo: "logout", usuario: "María", timestamp: new Date() },
      { tipo: "error", usuario: "Sistema", timestamp: new Date() }
    ];

    for (const evento of eventos) {
      await new Promise(resolve => setTimeout(resolve, 100));
      yield evento;
    }
  }
}
----

===== Async generator bidireccional

[source,typescript]
----
async function* consultas(): AsyncGenerator<string, void, string> {
  console.log("Iniciado");

  let respuesta = yield "¿Cuál es tu nombre?";
  console.log("Obtuviste:", respuesta);

  respuesta = yield "¿Cuál es tu edad?";
  console.log("Obtuviste:", respuesta);
}

// Usar
const gen = consultas();

(async () => {
  console.log(await gen.next());          // ¿Cuál es tu nombre?
  console.log(await gen.next("Juan"));    // ¿Cuál es tu edad?
  console.log(await gen.next("30"));      // done
})();
----


==== 11.4 for...of y for...in

===== Diferencia entre for...of y for...in

[source,typescript]
----
const objeto = { a: 1, b: 2, c: 3 };
const array = ["x", "y", "z"];

// for...in itera sobre las claves/índices
for (const clave in objeto) {
  console.log(clave);  // "a", "b", "c"
}

for (const indice in array) {
  console.log(indice);  // "0", "1", "2" (como strings)
}

// for...of itera sobre los valores (usa Symbol.iterator)
for (const valor of array) {
  console.log(valor);  // "x", "y", "z"
}

// No funciona en objetos normales
for (const valor of objeto) {  // ✗ Error: not iterable
  console.log(valor);
}
----

===== for...of con iterables personalizados

[source,typescript]
----
class ColeccionPosiciones implements Iterable<number> {
  private posiciones: number[] = [];

  agregar(pos: number): void {
    this.posiciones.push(pos);
  }

  [Symbol.iterator](): Iterator<number> {
    let index = 0;

    return {
      next: (): IteratorResult<number> => {
        if (index < this.posiciones.length) {
          return { value: this.posiciones[index++], done: false };
        }
        return { done: true };
      }
    };
  }
}

// Usar
const coleccion = new ColeccionPosiciones();
coleccion.agregar(10);
coleccion.agregar(20);
coleccion.agregar(30);

for (const pos of coleccion) {
  console.log(pos);  // 10, 20, 30
}
----

===== for await...of

[source,typescript]
----
async function* contar(): AsyncGenerator<number> {
  for (let i = 1; i <= 3; i++) {
    await new Promise(resolve => setTimeout(resolve, 500));
    yield i;
  }
}

// for await...of espera cada promise
async function procesar(): Promise<void> {
  for await (const num of contar()) {
    console.log(num);  // 1, 2, 3 (con delay)
  }
}

procesar();
----

===== Mapeo y filtrado con iterables

[source,typescript]
----
function* map<T, U>(
  iterable: Iterable<T>,
  fn: (item: T) => U
): Generator<U> {
  for (const item of iterable) {
    yield fn(item);
  }
}

function* filtro<T>(
  iterable: Iterable<T>,
  predicado: (item: T) => boolean
): Generator<T> {
  for (const item of iterable) {
    if (predicado(item)) {
      yield item;
    }
  }
}

// Usar
const numeros = [1, 2, 3, 4, 5];

const pares = [...filtro(numeros, n => n % 2 === 0)];
console.log(pares);  // [2, 4]

const dobles = [...map(pares, n => n * 2)];
console.log(dobles);  // [4, 8]

// Encadenar
const resultado = [
  ...map(
    filtro(numeros, n => n % 2 === 0),
    n => n * 2
  )
];
console.log(resultado);  // [4, 8]
----

===== Helpers para manipulación

[source,typescript]
----
class Pipeline<T> {
  constructor(private datos: Iterable<T>) {}

  filtrar(predicado: (item: T) => boolean): Pipeline<T> {
    this.datos = filtro(this.datos, predicado);
    return this;
  }

  mapear<U>(fn: (item: T) => U): Pipeline<U> {
    return new Pipeline(map(this.datos, fn));
  }

  recopilar(): T[] {
    return [...this.datos];
  }
}

// Usar
const resultado = new Pipeline([1, 2, 3, 4, 5])
  .filtrar(n => n > 2)
  .mapear(n => n * 2)
  .recopilar();

console.log(resultado);  // [6, 8, 10]
----


==== Ejemplo Integrado: Sistema de Paginación Asincrónico

[source,typescript]
----
interface Usuario {
  id: number;
  nombre: string;
  email: string;
}

interface Pagina<T> {
  items: T[];
  total: number;
  pagina: number;
  porPagina: number;
}

class RepositorioPaginado implements AsyncIterable<Usuario> {
  private baseURL = "https://api.example.com";

  constructor(
    private porPagina: number = 10,
    private usuariosIndividuales: Usuario[] = [
      { id: 1, nombre: "Juan", email: "juan@example.com" },
      { id: 2, nombre: "María", email: "maria@example.com" },
      { id: 3, nombre: "Carlos", email: "carlos@example.com" },
      { id: 4, nombre: "Ana", email: "ana@example.com" },
      { id: 5, nombre: "Pedro", email: "pedro@example.com" }
    ]
  ) {}

  async *[Symbol.asyncIterator](): AsyncGenerator<Usuario> {
    let pagina = 1;

    while (true) {
      const datos = await this.obtenerPagina(pagina);

      if (datos.items.length === 0) break;

      for (const usuario of datos.items) {
        yield usuario;
      }

      pagina++;
    }
  }

  private async obtenerPagina(pagina: number): Promise<Pagina<Usuario>> {
    // Simular delay de red
    await new Promise(resolve => setTimeout(resolve, 300));

    const inicio = (pagina - 1) * this.porPagina;
    const fin = inicio + this.porPagina;

    return {
      items: this.usuariosIndividuales.slice(inicio, fin),
      total: this.usuariosIndividuales.length,
      pagina,
      porPagina: this.porPagina
    };
  }
}

// Usar
async function procesarTodosLosUsuarios(): Promise<void> {
  const repositorio = new RepositorioPaginado(2);

  let contador = 0;
  for await (const usuario of repositorio) {
    contador++;
    console.log(`[${contador}] ${usuario.nombre} (${usuario.email})`);
  }

  console.log(`Total procesados: ${contador}`);
}

// Ejecutar
procesarTodosLosUsuarios();
----


==== Ejercicios Propuestos

.1. Iterador personalizado:
[source,typescript]
----
// Crear clase Tabla que implementa Iterable
// Tabla tiene filas y columnas
// Iterar sobre todas las celdas en orden
----

.2. Generador recursivo:
[source,typescript]
----
// Crear generador que recorra carpetas y archivos
// Usar yield* para delegación
// Filtrar por extensión de archivo
----

.3. Async generator con reintentos:
[source,typescript]
----
// Async generator que obtiene datos de API
// Si falla, reintentar con exponential backoff
// Emit resultados conforme se obtienen
----

.4. Pipeline de transformación:
[source,typescript]
----
// Crear sistema de pipeline con:
// - filtro()
// - mapa()
// - reducir()
// - recopilar()
// Usar for...of para recorrer datos
----


=== Módulo 12: Patrones de Diseño en TypeScript

Los patrones de diseño son soluciones reutilizables a problemas comunes en arquitectura de software. TypeScript facilita su implementación con tipos.

==== 12.1 Patrones Creacionales

Controlan la creación de objetos.

===== Singleton

Garantiza una única instancia de una clase en toda la aplicación.

[source,typescript]
----
class BaseDatos {
  private static instancia: BaseDatos;
  private conexionId: string;

  private constructor() {
    this.conexionId = Math.random().toString();
  }

  static obtenerInstancia(): BaseDatos {
    if (!BaseDatos.instancia) {
      BaseDatos.instancia = new BaseDatos();
    }
    return BaseDatos.instancia;
  }

  conectar(): void {
    console.log(`Conectado con ID: ${this.conexionId}`);
  }
}

// Usar
const db1 = BaseDatos.obtenerInstancia();
const db2 = BaseDatos.obtenerInstancia();

db1.conectar();  // Conectado con ID: 0.xxx
db2.conectar();  // Conectado con ID: 0.xxx (mismo)

console.log(db1 === db2);  // true
----

===== Factory Method

Crea objetos sin especificar sus clases exactas.

[source,typescript]
----
interface Animal {
  sonido(): void;
  moverse(): void;
}

class Perro implements Animal {
  sonido(): void {
    console.log("¡Guau!");
  }
  moverse(): void {
    console.log("Corriendo con 4 patas");
  }
}

class Pajaro implements Animal {
  sonido(): void {
    console.log("¡Pío!");
  }
  moverse(): void {
    console.log("Volando");
  }
}

class Pez implements Animal {
  sonido(): void {
    console.log("...");
  }
  moverse(): void {
    console.log("Nadando");
  }
}

// Factory
class FabricaAnimales {
  static crearAnimal(tipo: "perro" | "pajaro" | "pez"): Animal {
    switch (tipo) {
      case "perro":
        return new Perro();
      case "pajaro":
        return new Pajaro();
      case "pez":
        return new Pez();
    }
  }
}

// Usar
const perro = FabricaAnimales.crearAnimal("perro");
perro.sonido();    // ¡Guau!
perro.moverse();   // Corriendo con 4 patas

const pajaro = FabricaAnimales.crearAnimal("pajaro");
pajaro.sonido();   // ¡Pío!
----

===== Abstract Factory

Crea familias de objetos relacionados.

[source,typescript]
----
interface Boton {
  renderizar(): string;
}

interface CajaTexto {
  renderizar(): string;
}

interface FabricaUI {
  crearBoton(): Boton;
  crearCajaTexto(): CajaTexto;
}

// Implementación Light
class BotonLight implements Boton {
  renderizar(): string {
    return "Botón Blanco";
  }
}

class CajaTextoLight implements CajaTexto {
  renderizar(): string {
    return "Entrada de texto clara";
  }
}

class FabricaLightUI implements FabricaUI {
  crearBoton(): Boton {
    return new BotonLight();
  }
  crearCajaTexto(): CajaTexto {
    return new CajaTextoLight();
  }
}

// Implementación Dark
class BotonDark implements Boton {
  renderizar(): string {
    return "Botón Oscuro";
  }
}

class CajaTextoDark implements CajaTexto {
  renderizar(): string {
    return "Entrada de texto oscura";
  }
}

class FabricaDarkUI implements FabricaUI {
  crearBoton(): Boton {
    return new BotonDark();
  }
  crearCajaTexto(): CajaTexto {
    return new CajaTextoDark();
  }
}

// Usar
function renderizarUI(fabrica: FabricaUI): void {
  const boton = fabrica.crearBoton();
  const caja = fabrica.crearCajaTexto();

  console.log(boton.renderizar());  // Botón Blanco o Botón Oscuro
  console.log(caja.renderizar());   // Entrada de texto clara o oscura
}

renderizarUI(new FabricaLightUI());  // Tema claro
renderizarUI(new FabricaDarkUI());   // Tema oscuro
----

===== Builder

Construye objetos complejos paso a paso.

[source,typescript]
----
interface ConfiguracionServidor {
  host: string;
  puerto: number;
  ssl: boolean;
  timeout: number;
  reintentos: number;
}

class ConstructorServidor {
  private config: Partial<ConfiguracionServidor> = {};

  host(valor: string): this {
    this.config.host = valor;
    return this;
  }

  puerto(valor: number): this {
    this.config.puerto = valor;
    return this;
  }

  ssl(valor: boolean): this {
    this.config.ssl = valor;
    return this;
  }

  timeout(valor: number): this {
    this.config.timeout = valor;
    return this;
  }

  reintentos(valor: number): this {
    this.config.reintentos = valor;
    return this;
  }

  construir(): ConfiguracionServidor {
    return {
      host: this.config.host || "localhost",
      puerto: this.config.puerto || 3000,
      ssl: this.config.ssl ?? false,
      timeout: this.config.timeout || 5000,
      reintentos: this.config.reintentos || 3
    };
  }
}

// Usar
const config = new ConstructorServidor()
  .host("api.example.com")
  .puerto(443)
  .ssl(true)
  .timeout(10000)
  .construir();

console.log(config);
// {
//   host: "api.example.com",
//   puerto: 443,
//   ssl: true,
//   timeout: 10000,
//   reintentos: 3
// }
----

===== Prototype

Crea objetos clonando un prototipo existente.

[source,typescript]
----
interface Cloneable<T> {
  clonar(): T;
}

class Documento implements Cloneable<Documento> {
  constructor(
    public titulo: string,
    public contenido: string,
    public autor: string
  ) {}

  clonar(): Documento {
    // Clon superficial
    return new Documento(this.titulo, this.contenido, this.autor);
  }

  modificar(nuevoTitulo: string, nuevoContenido: string): void {
    this.titulo = nuevoTitulo;
    this.contenido = nuevoContenido;
  }
}

// Usar
const docOriginal = new Documento(
  "Mi Documento",
  "Contenido original",
  "Juan"
);

const docClon = docOriginal.clonar();
docClon.modificar("Documento Clonado", "Contenido modificado");

console.log(docOriginal.titulo);  // "Mi Documento"
console.log(docClon.titulo);      // "Documento Clonado"
----


==== 12.2 Patrones Estructurales

Componen objetos en estructuras más grandes.

===== Adapter

Convierte la interfaz de una clase en otra esperada.

[source,typescript]
----
// Interfaz antigua
interface Impresora {
  imprimir(texto: string): void;
}

class ImpresoraLegacy {
  imprimir(documento: string): void {
    console.log(`IMPRIMIENDO: ${documento}`);
  }
}

// Interfaz nueva
interface DispositivoModerno {
  enviarDatos(datos: string): void;
}

// Adapter
class AdaptadorImpresora implements DispositivoModerno {
  constructor(private impresora: ImpresoraLegacy) {}

  enviarDatos(datos: string): void {
    this.impresora.imprimir(datos);
  }
}

// Usar
const impresoraVieja = new ImpresoraLegacy();
const adaptada: DispositivoModerno = new AdaptadorImpresora(impresoraVieja);

adaptada.enviarDatos("Mi documento");  // IMPRIMIENDO: Mi documento
----

===== Decorator

Añade funcionalidad a objetos dinámicamente.

[source,typescript]
----
interface Componente {
  operacion(): string;
}

class ComponenteBasico implements Componente {
  operacion(): string {
    return "Componente básico ";
  }
}

abstract class DecoradorComponente implements Componente {
  constructor(protected componente: Componente) {}

  operacion(): string {
    return this.componente.operacion();
  }
}

class DecoradorA extends DecoradorComponente {
  operacion(): string {
    return super.operacion() + "+ Operación A ";
  }
}

class DecoradorB extends DecoradorComponente {
  operacion(): string {
    return super.operacion() + "+ Operación B ";
  }
}

// Usar
let componente: Componente = new ComponenteBasico();
console.log(componente.operacion());  // "Componente básico "

componente = new DecoradorA(componente);
console.log(componente.operacion());  // "Componente básico  + Operación A "

componente = new DecoradorB(componente);
console.log(componente.operacion());  // "Componente básico  + Operación A  + Operación B "
----

===== Facade

Proporciona interfaz unificada a subsistemas complejos.

[source,typescript]
----
// Subsistemas complejos
class SistemaAutenticacion {
  autenticar(usuario: string, contraseña: string): boolean {
    return usuario === "admin" && contraseña === "123";
  }
}

class SistemaAutorizacion {
  tienePermiso(usuario: string, recurso: string): boolean {
    return usuario === "admin";
  }
}

class SistemaAuditoria {
  registrar(evento: string): void {
    console.log(`[Auditoria] ${evento}`);
  }
}

// Facade
class FachadaSeguridad {
  private autenticacion = new SistemaAutenticacion();
  private autorizacion = new SistemaAutorizacion();
  private auditoria = new SistemaAuditoria();

  accederRecurso(usuario: string, contraseña: string, recurso: string): boolean {
    this.auditoria.registrar(`Intento de acceso: ${usuario}`);

    if (!this.autenticacion.autenticar(usuario, contraseña)) {
      this.auditoria.registrar(`Autenticación fallida: ${usuario}`);
      return false;
    }

    if (!this.autorizacion.tienePermiso(usuario, recurso)) {
      this.auditoria.registrar(`Permiso denegado: ${usuario} -> ${recurso}`);
      return false;
    }

    this.auditoria.registrar(`Acceso permitido: ${usuario} -> ${recurso}`);
    return true;
  }
}

// Usar
const fachada = new FachadaSeguridad();

fachada.accederRecurso("admin", "123", "datos");    // Accedido
fachada.accederRecurso("usuario", "456", "datos");  // Denegado
----

===== Proxy

Controla el acceso a otro objeto.

[source,typescript]
----
interface Servicio {
  procesar(datos: string): void;
}

class ServicioReal implements Servicio {
  procesar(datos: string): void {
    console.log(`Procesando: ${datos}`);
  }
}

class ProxyServicio implements Servicio {
  private servicio: ServicioReal | null = null;

  procesar(datos: string): void {
    if (!this.servicio) {
      console.log("Inicializando servicio...");
      this.servicio = new ServicioReal();
    }

    console.log("Verifying access...");
    this.servicio.procesar(datos);
  }
}

// Usar - lazy initialization
const proxy: Servicio = new ProxyServicio();
// No se crea el servicio real hasta que se llama procesar
proxy.procesar("datos importantes");  // Inicializa y procesa
----

===== Composite

Compone objetos en estructuras de árbol.

[source,typescript]
----
interface ElementoUI {
  renderizar(): string;
  agregarHijo?(elemento: ElementoUI): void;
}

class Boton implements ElementoUI {
  constructor(private etiqueta: string) {}

  renderizar(): string {
    return `<button>${this.etiqueta}</button>`;
  }
}

class Panel implements ElementoUI {
  private hijos: ElementoUI[] = [];

  agregarHijo(elemento: ElementoUI): void {
    this.hijos.push(elemento);
  }

  renderizar(): string {
    const contenidoHijos = this.hijos
      .map(h => h.renderizar())
      .join("\n");
    return `<div>\n${contenidoHijos}\n</div>`;
  }
}

// Usar
const panel = new Panel();
panel.agregarHijo(new Boton("Guardar"));
panel.agregarHijo(new Boton("Cancelar"));

const panelOpciones = new Panel();
panelOpciones.agregarHijo(new Boton("Opción 1"));
panelOpciones.agregarHijo(new Boton("Opción 2"));

panel.agregarHijo(panelOpciones);

console.log(panel.renderizar());
// <div>
// <button>Guardar</button>
// <button>Cancelar</button>
// <div>
// <button>Opción 1</button>
// <button>Opción 2</button>
// </div>
// </div>
----


==== 12.3 Patrones de Comportamiento

Definen comunicación entre objetos.

===== Observer

Notifica múltiples observadores de cambios.

[source,typescript]
----
interface Observador<T> {
  actualizar(datos: T): void;
}

interface Sujeto<T> {
  suscribir(observador: Observador<T>): void;
  desuscribir(observador: Observador<T>): void;
  notificar(datos: T): void;
}

class TemperaturaMonitor implements Sujeto<number> {
  private observadores: Observador<number>[] = [];
  private temperatura: number = 20;

  suscribir(observador: Observador<number>): void {
    this.observadores.push(observador);
  }

  desuscribir(observador: Observador<number>): void {
    const index = this.observadores.indexOf(observador);
    if (index > -1) {
      this.observadores.splice(index, 1);
    }
  }

  notificar(datos: number): void {
    this.observadores.forEach(obs => obs.actualizar(datos));
  }

  setTemperatura(valor: number): void {
    this.temperatura = valor;
    this.notificar(valor);
  }
}

class Alarma implements Observador<number> {
  actualizar(temperatura: number): void {
    if (temperatura > 30) {
      console.log("¡ALERTA! Temperatura muy alta");
    }
  }
}

class Termostato implements Observador<number> {
  actualizar(temperatura: number): void {
    if (temperatura < 18) {
      console.log("Activando calefacción");
    }
  }
}

// Usar
const monitor = new TemperaturaMonitor();
const alarma = new Alarma();
const termostato = new Termostato();

monitor.suscribir(alarma);
monitor.suscribir(termostato);

monitor.setTemperatura(35);  // ¡ALERTA! Temperatura muy alta
monitor.setTemperatura(15);  // Activando calefacción
----

===== Strategy

Define familia de algoritmos intercambiables.

[source,typescript]
----
interface EstrategiaOrdenamiento {
  ordenar(array: number[]): number[];
}

class OrdenamientoBurbuja implements EstrategiaOrdenamiento {
  ordenar(array: number[]): number[] {
    const copia = [...array];
    for (let i = 0; i < copia.length; i++) {
      for (let j = i + 1; j < copia.length; j++) {
        if (copia[i] > copia[j]) {
          [copia[i], copia[j]] = [copia[j], copia[i]];
        }
      }
    }
    return copia;
  }
}

class OrdenamientoRapido implements EstrategiaOrdenamiento {
  ordenar(array: number[]): number[] {
    if (array.length <= 1) return array;
    const pivote = array[0];
    const menores = array.slice(1).filter(x => x < pivote);
    const mayores = array.slice(1).filter(x => x >= pivote);
    return [
      ...this.ordenar(menores),
      pivote,
      ...this.ordenar(mayores)
    ];
  }
}

class Ordenador {
  constructor(private estrategia: EstrategiaOrdenamiento) {}

  setEstrategia(estrategia: EstrategiaOrdenamiento): void {
    this.estrategia = estrategia;
  }

  ejecutar(array: number[]): number[] {
    return this.estrategia.ordenar(array);
  }
}

// Usar
const array = [5, 2, 8, 1, 9];

const ordenador = new Ordenador(new OrdenamientoBurbuja());
console.log(ordenador.ejecutar(array));  // [1, 2, 5, 8, 9]

ordenador.setEstrategia(new OrdenamientoRapido());
console.log(ordenador.ejecutar(array));  // [1, 2, 5, 8, 9]
----

===== State

Permite objetos cambiar comportamiento según estado interno.

[source,typescript]
----
interface EstadoSemaforoInterface {
  siguiente(): void;
  color(): string;
}

class EstadoRojo implements EstadoSemaforoInterface {
  siguiente(): void {
    console.log("Cambiando de rojo a verde");
  }
  color(): string {
    return "Rojo";
  }
}

class EstadoVerde implements EstadoSemaforoInterface {
  siguiente(): void {
    console.log("Cambiando de verde a ámbar");
  }
  color(): string {
    return "Verde";
  }
}

class EstadoAmbar implements EstadoSemaforoInterface {
  siguiente(): void {
    console.log("Cambiando de ámbar a rojo");
  }
  color(): string {
    return "Ámbar";
  }
}

class Semaforo {
  private estado: EstadoSemaforoInterface = new EstadoRojo();

  cambiar(): void {
    this.estado.siguiente();

    if (this.estado instanceof EstadoRojo) {
      this.estado = new EstadoVerde();
    } else if (this.estado instanceof EstadoVerde) {
      this.estado = new EstadoAmbar();
    } else {
      this.estado = new EstadoRojo();
    }
  }

  obtenerColor(): string {
    return this.estado.color();
  }
}

// Usar
const semaforo = new Semaforo();
console.log(semaforo.obtenerColor());  // Rojo

semaforo.cambiar();
console.log(semaforo.obtenerColor());  // Verde

semaforo.cambiar();
console.log(semaforo.obtenerColor());  // Ámbar
----

===== Command

Encapsula solicitud como objeto.

[source,typescript]
----
interface Comando {
  ejecutar(): void;
  deshacer(): void;
}

class OperacionSuma implements Comando {
  constructor(
    private a: number,
    private b: number,
    private receptor: Calculadora
  ) {}

  ejecutar(): void {
    this.receptor.sumar(this.a, this.b);
  }

  deshacer(): void {
    this.receptor.restar(this.a, this.b);
  }
}

class Calculadora {
  private resultado: number = 0;

  sumar(a: number, b: number): void {
    this.resultado += a + b;
    console.log(`Resultado: ${this.resultado}`);
  }

  restar(a: number, b: number): void {
    this.resultado -= a + b;
    console.log(`Resultado: ${this.resultado}`);
  }
}

class CentralComandos {
  private historial: Comando[] = [];

  ejecutar(comando: Comando): void {
    comando.ejecutar();
    this.historial.push(comando);
  }

  deshacer(): void {
    const comando = this.historial.pop();
    if (comando) {
      comando.deshacer();
    }
  }
}

// Usar
const calc = new Calculadora();
const central = new CentralComandos();

central.ejecutar(new OperacionSuma(5, 3, calc));  // Resultado: 8
central.ejecutar(new OperacionSuma(2, 4, calc));  // Resultado: 14

central.deshacer();  // Resultado: 8
----

===== Chain of Responsibility

Pasa solicitud a lo largo de cadena de handlers.

[source,typescript]
----
interface Manejador {
  manejar(solicitud: Solicitud): boolean;
  siguiente?: Manejador;
}

interface Solicitud {
  nivel: "bajo" | "medio" | "alto";
  asunto: string;
}

class ManejadorSoporte implements Manejador {
  siguiente?: Manejador;

  manejar(solicitud: Solicitud): boolean {
    if (solicitud.nivel === "bajo") {
      console.log(`Soporte resolvió: ${solicitud.asunto}`);
      return true;
    }

    if (this.siguiente) {
      return this.siguiente.manejar(solicitud);
    }

    return false;
  }
}

class ManejadorGerente implements Manejador {
  siguiente?: Manejador;

  manejar(solicitud: Solicitud): boolean {
    if (solicitud.nivel === "medio") {
      console.log(`Gerente aprobó: ${solicitud.asunto}`);
      return true;
    }

    if (this.siguiente) {
      return this.siguiente.manejar(solicitud);
    }

    return false;
  }
}

class ManejadorDirector implements Manejador {
  manejar(solicitud: Solicitud): boolean {
    if (solicitud.nivel === "alto") {
      console.log(`Director decidió: ${solicitud.asunto}`);
      return true;
    }
    return false;
  }
}

// Usar
const soporte = new ManejadorSoporte();
const gerente = new ManejadorGerente();
const director = new ManejadorDirector();

soporte.siguiente = gerente;
gerente.siguiente = director;

soporte.manejar({ nivel: "bajo", asunto: "Error de login" });   // Soporte
soporte.manejar({ nivel: "medio", asunto: "Aumento de sueldo" }); // Gerente
soporte.manejar({ nivel: "alto", asunto: "Fusión con empresa" }); // Director
----

===== Template Method

Define estructura algoritmo, subclases rellenan detalles.

[source,typescript]
----
abstract class ProcesoDeplicacion {
  execute(): void {
    this.validar();
    this.procesar();
    this.finalizar();
  }

  protected validar(): void {
    console.log("Validando entrada...");
  }

  protected abstract procesar(): void;

  protected finalizar(): void {
    console.log("Limpiando recursos...");
  }
}

class ProcesoDatos extends ProcesoDeplicacion {
  protected procesar(): void {
    console.log("Procesando datos...");
  }
}

class ProcesoReporte extends ProcesoDeplicacion {
  protected procesar(): void {
    console.log("Generando reporte...");
  }

  protected finalizar(): void {
    console.log("Enviando reporte por email...");
    super.finalizar();
  }
}

// Usar
const proceso1 = new ProcesoDatos();
proceso1.execute();
// Validando entrada...
// Procesando datos...
// Limpiando recursos...

const proceso2 = new ProcesoReporte();
proceso2.execute();
// Validando entrada...
// Generando reporte...
// Enviando reporte por email...
// Limpiando recursos...
----


==== Ejemplo Integrado: Sistema de Procesamiento de Pedidos

[source,typescript]
----
// Enums para estados
enum EstadoPedido {
  Pendiente = "pendiente",
  Procesando = "procesando",
  Completado = "completado",
  Cancelado = "cancelado"
}

// Interfaces
interface Observador {
  actualizar(pedido: Pedido): void;
}

interface EstrategiaEnvio {
  calcularCosto(peso: number): number;
}

// Estados
interface EstadoActualPedido {
  siguiente(): void;
}

// Implementaciones
class PedidoEstadoPendiente implements EstadoActualPedido {
  constructor(private pedido: Pedido) {}
  siguiente(): void {
    console.log("Procesando pedido...");
    this.pedido.estado = EstadoPedido.Procesando;
  }
}

class PedidoEstadoCompletado implements EstadoActualPedido {
  constructor(private pedido: Pedido) {}
  siguiente(): void {
    console.log("Pedido entregado");
    this.pedido.estado = EstadoPedido.Completado;
  }
}

class EnvioEstandar implements EstrategiaEnvio {
  calcularCosto(peso: number): number {
    return peso * 5;
  }
}

class EnvioExpress implements EstrategiaEnvio {
  calcularCosto(peso: number): number {
    return peso * 15;
  }
}

class Pedido {
  private observadores: Observador[] = [];
  estado: EstadoPedido = EstadoPedido.Pendiente;

  constructor(
    public id: string,
    public descripcion: string,
    public peso: number,
    private estrategiaEnvio: EstrategiaEnvio
  ) {}

  suscribir(observador: Observador): void {
    this.observadores.push(observador);
  }

  notificar(): void {
    this.observadores.forEach(obs => obs.actualizar(this));
  }

  procesar(): void {
    this.estado = EstadoPedido.Procesando;
    console.log(`Pedido ${this.id} en proceso`);
    this.notificar();
  }

  completar(): void {
    this.estado = EstadoPedido.Completado;
    console.log(`Pedido ${this.id} completado`);
    this.notificar();
  }

  obtenerCostoEnvio(): number {
    return this.estrategiaEnvio.calcularCosto(this.peso);
  }
}

// Observador
class NotificadorEmail implements Observador {
  actualizar(pedido: Pedido): void {
    console.log(`📧 Email: Pedido ${pedido.id} ahora está ${pedido.estado}`);
  }
}

// Usar
const pedido = new Pedido("PED001", "Laptop", 2.5, new EnvioExpress());

pedido.suscribir(new NotificadorEmail());

console.log(`Costo envío: $${pedido.obtenerCostoEnvio()}`);

pedido.procesar();   // Notifica
pedido.completar();  // Notifica
----


==== Ejercicios Propuestos

.1. Factory personalizado:
[source,typescript]
----
// Crear factory para diferentes tipos de conexiones:
// - Base de datos
// - API REST
// - Archivo local
// Implementar método genérico
----

.2. Decorator avanzado:
[source,typescript]
----
// Crear decorators que añadan:
// - Logging automático
// - Caching de resultados
// - Validación de parámetros
// Combinar múltiples decorators
----

.3. Observer completo:
[source,typescript]
----
// Sistema de carrito de compras
// Observadores: Inventario, Facturación, Notificaciones
// Emitir eventos cuando se agregan/eliminan productos
----

.4. Cadena compleja:
[source,typescript]
----
// Chain of Responsibility para validación
// Cada handler valida un aspecto diferente
// Si passa todas las validaciones, procesar
----


=== Módulo 13: Configuración y Tooling

La configuración adecuada de TypeScript es crucial para el desarrollo eficiente. Este módulo cubre herramientas y configuración.

==== 13.1 tsconfig.json: Opciones Importantes

El archivo `tsconfig.json` controla el comportamiento del compilador TypeScript.

===== Estructura básica

[source,json]
----
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
----

===== Opciones del compilador esenciales

[source,json]
----
{
  "compilerOptions": {
    // Versión de JavaScript objetivo
    "target": "ES2020",

    // Sistema de módulos
    "module": "ES2020",  // ESM o commonjs

    // Librerías disponibles
    "lib": ["ES2020", "DOM"],

    // Directorios
    "outDir": "./dist",
    "rootDir": "./src",
    "baseUrl": "./src",
    "paths": {
      "@/*": ["./*"],
      "@utils/*": ["utils/*"]
    },

    // Verificación de tipos estricta
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,

    // Compatibilidad con módulos
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,

    // Emisión de archivos
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "removeComments": false,

    // Búsqueda de módulos
    "moduleResolution": "node",
    "resolveJsonModule": true,

    // Optimizaciones
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,

    // Experimentales
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"],
  "ts-node": {
    "transpileOnly": true,
    "compilerOptions": {
      "module": "commonjs"
    }
  }
}
----

===== Configuración por entorno

[source,json]
----
// tsconfig.json base
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ES2020",
    "strict": true
  },
  "include": ["src"]
}

// tsconfig.build.json (extender config base)
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "declaration": true,
    "outDir": "./dist",
    "sourceMap": false
  },
  "exclude": ["**/*.test.ts", "src/deprecated"]
}

// tsconfig.test.json (para testing)
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./test-dist",
    "sourceMap": true
  },
  "include": ["src", "tests"]
}
----

===== Validar configuración

[source,typescript]
----
// verify-tsconfig.ts
import * as fs from "fs";
import * as path from "path";
import * as ts from "typescript";

function validarConfiguracion(configPath: string): void {
  const configFile = ts.readConfigFile(configPath, ts.sys.readFile);

  if (configFile.error) {
    console.error("Error al leer tsconfig:", configFile.error);
    return;
  }

  const config = ts.parseJsonConfigFileContent(
    configFile.config,
    ts.sys,
    path.dirname(configPath)
  );

  if (config.errors.length > 0) {
    config.errors.forEach(error => {
      console.error(error.messageText);
    });
  } else {
    console.log("✓ Configuración válida");
    console.log("Opciones:", config.options);
  }
}

validarConfiguracion("./tsconfig.json");
----


==== 13.2 Compilación y Watch Mode

===== Compilación básica

[source,bash]
----
# Compilar una vez
tsc

# Compilar archivos específicos
tsc src/index.ts src/utils.ts

# Compilar a versión específica
tsc --target ES2020 --module commonjs

# Con archivo de configuración
tsc --project tsconfig.build.json

# Mostrar errores sin emitir
tsc --noEmit

# Mostrar configuración resolvida
tsc --showConfig
----

===== Watch mode para desarrollo

[source,bash]
----
# Compilar y observar cambios
tsc --watch

# Watch con configuración específica
tsc --watch --project tsconfig.json

# Watch sin emitir (solo chequear tipos)
tsc --watch --noEmit

# Watch con modo incremental
tsc --watch --incremental
----

===== Configuración de scripts

[source,json]
----
{
  "scripts": {
    "build": "tsc --project tsconfig.build.json",
    "build:watch": "tsc --project tsconfig.json --watch",
    "type-check": "tsc --noEmit",
    "dev": "ts-node --project tsconfig.json src/index.ts",
    "dev:watch": "nodemon --exec ts-node src/index.ts",
    "clean": "rm -rf dist",
    "prebuild": "npm run clean",
    "postbuild": "npm run type-check"
  }
}
----

===== Compilación incremental

[source,json]
----
{
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./.tsbuildinfo"
  }
}
----

[source,bash]
----
# Primera compilación (crea .tsbuildinfo)
tsc

# Segunda compilación (solo archivos cambiados)
tsc

# Limpiar caché incremental
rm -f .tsbuildinfo
----

===== Monitoreo avanzado con nodemon

[source,json]
----
// nodemon.json
{
  "watch": ["src"],
  "ext": "ts",
  "ignore": ["src/**/*.test.ts"],
  "exec": "ts-node",
  "env": {
    "NODE_ENV": "development"
  }
}
----

[source,bash]
----
# Ejecutar con nodemon
nodemon

# O con script personalizado
npm run dev:watch
----

===== Health check para compilación

[source,typescript]
----
// build-monitor.ts
import * as fs from "fs";
import * as path from "path";
import { execSync } from "child_process";

interface BuildStatus {
  exitCode: number;
  errors: string[];
  warnings: string[];
  duration: number;
}

function monitearBuild(): BuildStatus {
  const inicio = Date.now();

  try {
    const output = execSync("tsc --noEmit", { encoding: "utf-8" });
    const duracion = Date.now() - inicio;

    return {
      exitCode: 0,
      errors: [],
      warnings: [],
      duration: duracion
    };
  } catch (error: any) {
    const duracion = Date.now() - inicio;
    const stderr = error.stderr.toString();

    return {
      exitCode: error.status,
      errors: stderr.includes("error TS") ? [stderr] : [],
      warnings: stderr.includes("warning") ? [stderr] : [],
      duration: duracion
    };
  }
}

const status = monitearBuild();
console.log(`Build Status:`, status);
console.log(`Duration: ${status.duration}ms`);
process.exit(status.exitCode);
----


==== 13.3 Integración con Webpack, Vite, Rollup

===== Webpack con TypeScript

[source,javascript]
----
// webpack.config.js
const path = require("path");

module.exports = {
  entry: "./src/index.ts",
  output: {
    path: path.resolve(__dirname, "dist"),
    filename: "bundle.js"
  },
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: "ts-loader",
        exclude: /node_modules/
      }
    ]
  },
  resolve: {
    extensions: [".ts", ".js"],
    alias: {
      "@": path.resolve(__dirname, "src/")
    }
  },
  devtool: "source-map",
  mode: process.env.NODE_ENV || "development"
};
----

[source,json]
----
{
  "devDependencies": {
    "webpack": "^5.0.0",
    "webpack-cli": "^4.0.0",
    "ts-loader": "^9.0.0",
    "typescript": "^5.0.0"
  }
}
----

===== Vite con TypeScript

[source,typescript]
----
// vite.config.ts
import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";
import path from "path";

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src")
    }
  },
  server: {
    port: 3000,
    open: true
  },
  build: {
    outDir: "dist",
    sourcemap: true
  }
});
----

[source,json]
----
{
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "vite": "^4.0.0",
    "@vitejs/plugin-vue": "^4.0.0",
    "typescript": "^5.0.0"
  }
}
----

===== Rollup con TypeScript

[source,javascript]
----
// rollup.config.js
import typescript from "@rollup/plugin-typescript";
import resolve from "@rollup/plugin-node-resolve";
import commonjs from "@rollup/plugin-commonjs";

export default {
  input: "src/index.ts",
  output: {
    file: "dist/bundle.js",
    format: "esm",
    sourcemap: true
  },
  plugins: [
    resolve(),
    commonjs(),
    typescript({
      tsconfig: "tsconfig.build.json"
    })
  ],
  external: ["lodash"]
};
----

===== Comparativa de bundlers

[source]
----
┌──────────┬──────────────┬─────────────┬──────────────┐
│ Aspecto  │ Webpack      │ Vite        │ Rollup       │
├──────────┼──────────────┼─────────────┼──────────────┤
│ Velocidad│ Lenta        │ Muy rápida  │ Media        │
│ Config   │ Compleja     │ Simple      │ Media        │
│ HMR      │ Básico       │ Excelente   │ N/A          │
│ Bundling│ Bundler      │ Bundler     │ Lib focus    │
│ Apps     │ Grandes      │ Modernas    │ Librerías    │
└──────────┴──────────────┴─────────────┴──────────────┘
----


==== 13.4 Linting y Formateo: ESLint, Prettier

===== Configurar ESLint

[source,json]
----
// .eslintrc.json
{
  "env": {
    "node": true,
    "es2020": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:@typescript-eslint/recommended-requiring-type-checking"
  ],
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaVersion": 2020,
    "sourceType": "module",
    "project": "./tsconfig.json"
  },
  "plugins": ["@typescript-eslint"],
  "rules": {
    "@typescript-eslint/explicit-function-return-types": "warn",
    "@typescript-eslint/no-explicit-any": "error",
    "@typescript-eslint/no-unused-vars": ["error", { "argsIgnorePattern": "^_" }],
    "no-console": ["warn", { "allow": ["warn", "error"] }]
  },
  "ignorePatterns": ["dist", "node_modules", "**/*.test.ts"]
}
----

[source,bash]
----
# Instalar ESLint
npm install --save-dev eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin

# Validar código
npx eslint src

# Arreglar automáticamente
npx eslint src --fix

# Con config específica
npx eslint --config .eslintrc.json src
----

===== Configurar Prettier

[source,json]
----
// .prettierrc.json
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": false,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false,
  "arrowParens": "always"
}

// .prettierignore
node_modules
dist
build
*.test.ts
----

===== ESLint + Prettier integrados

[source,json]
----
{
  "scripts": {
    "lint": "eslint src --ext .ts",
    "lint:fix": "eslint src --ext .ts --fix",
    "format": "prettier --write \"src/**/*.ts\"",
    "format:check": "prettier --check \"src/**/*.ts\"",
    "validate": "npm run lint && npm run format:check && npm run type-check"
  }
}
----

===== Pre-commit hooks con husky

[source,bash]
----
npm install husky lint-staged --save-dev

npx husky install

npx husky add .husky/pre-commit "npx lint-staged"
----

[source,json]
----
// package.json
{
  "lint-staged": {
    "*.ts": [
      "eslint --fix",
      "prettier --write"
    ]
  }
}
----

===== Crear regla personalizada

[source,typescript]
----
// rules/no-console-log.ts
import { ESLintUtils, TSESTree } from "@typescript-eslint/utils";

export default ESLintUtils.RuleCreator(
  name => `https://example.com/rules/${name}`
)(
  {
    name: "no-console-log",
    meta: {
      type: "problem",
      docs: {
        description: "Disallow console.log, use console.error or console.warn",
        recommended: "error"
      }
    },
    defaultOptions: [],
    create(context) {
      return {
        CallExpression(node: TSESTree.CallExpression) {
          if (
            node.callee.type === "MemberExpression" &&
            (node.callee.object as any).name === "console" &&
            (node.callee.property as any).name === "log"
          ) {
            context.report({
              node,
              message: "Use console.error or console.warn instead of console.log"
            });
          }
        }
      };
    }
  }
);
----

===== Reportes de linting

[source,typescript]
----
// lint-report.ts
import { execSync } from "child_process";
import * as fs from "fs";

interface LintResult {
  total: number;
  errors: number;
  warnings: number;
  files: string[];
}

function generarReporte(): LintResult {
  try {
    const output = execSync(
      "eslint src --format=json",
      { encoding: "utf-8" }
    );
    const results = JSON.parse(output);

    let totalErrors = 0;
    let totalWarnings = 0;
    const filesConProblemas: string[] = [];

    results.forEach((file: any) => {
      if (file.messages.length > 0) {
        filesConProblemas.push(file.filePath);
        file.messages.forEach((msg: any) => {
          if (msg.severity === 2) totalErrors++;
          if (msg.severity === 1) totalWarnings++;
        });
      }
    });

    return {
      total: results.length,
      errors: totalErrors,
      warnings: totalWarnings,
      files: filesConProblemas
    };
  } catch (error) {
    return {
      total: 0,
      errors: 0,
      warnings: 0,
      files: []
    };
  }
}

const reporte = generarReporte();
console.log("Lint Report:", reporte);
fs.writeFileSync("lint-report.json", JSON.stringify(reporte, null, 2));
----


==== Ejemplo Integrado: Setup Completo de Proyecto

[source,json]
----
// package.json
{
  "name": "mi-proyecto",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "ts-node --esm src/index.ts",
    "dev:watch": "nodemon --exec ts-node --esm src/index.ts",
    "build": "tsc --project tsconfig.build.json",
    "build:watch": "tsc --project tsconfig.json --watch",
    "type-check": "tsc --noEmit",
    "lint": "eslint src --ext .ts",
    "lint:fix": "eslint src --ext .ts --fix",
    "format": "prettier --write \"src/**/*.ts\"",
    "format:check": "prettier --check \"src/**/*.ts\"",
    "validate": "npm run type-check && npm run lint && npm run format:check",
    "clean": "rm -rf dist"
  },
  "devDependencies": {
    "typescript": "^5.0.0",
    "ts-node": "^10.0.0",
    "nodemon": "^3.0.0",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.0.0",
    "prettier": "^3.0.0",
    "husky": "^8.0.0",
    "lint-staged": "^14.0.0"
  }
}
----

[source,json]
----
// .eslintrc.json
{
  "env": {"node": true, "es2020": true},
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended"
  ],
  "parser": "@typescript-eslint/parser",
  "plugins": ["@typescript-eslint"],
  "rules": {
    "@typescript-eslint/no-explicit-any": "error",
    "@typescript-eslint/explicit-function-return-types": "warn"
  }
}
----

[source,json]
----
// .prettierrc.json
{
  "semi": true,
  "singleQuote": false,
  "printWidth": 100,
  "tabWidth": 2,
  "trailingComma": "es5"
}
----

[source,json]
----
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ES2020",
    "lib": ["ES2020"],
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
----


==== Ejercicios Propuestos

.1. Configuración personalizada:
[source,typescript]
----
// Crear tsconfig.json para:
// - Desarrollo (watch mode, sourcemaps)
// - Producción (optimizado, sin maps)
// Extender configuración base
----

.2. Script de build:
[source,bash]
----
// Crear script que:
// - Limpia dist/
// - Compila TypeScript
// - Corre linting
// - Genera reportes
// - Si todos ok, empaqueta
----

.3. Regla ESLint:
[source,typescript]
----
// Crear regla personalizada que:
// - Detecta funciones sin tipo de retorno
// - Sugiere agregarlo
// - Aplica fix automático
----

.4. Pre-commit validation:
[source,bash]
----
// Setup con husky:
// - Lint antes de commit
// - Type-check antes de push
// - Format automático en stage
// - Bloquear push si falla
----


=== Módulo 14: Testing en TypeScript

El testing es esencial para verificar que el código funciona correctamente. TypeScript proporciona herramientas adicionales para testing más robusto.

==== 14.1 Configurar Mocha/Chai con TypeScript

**Mocha** es un framework de testing, y **Chai** proporciona aserciones.

===== Setup inicial

[source,bash]
----
npm install --save-dev mocha chai @types/mocha typescript ts-node
----

===== Archivos de configuración

[source,json]
----
// tsconfig.test.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "./test-dist",
    "types": ["mocha", "node"]
  },
  "include": ["src/**/*", "tests/**/*"]
}
----

[source,json]
----
// .mocharc.json
{
  "require": "ts-node/register",
  "extensions": ["ts"],
  "spec": "tests/**/*.test.ts",
  "timeout": 5000,
  "slow": 3000
}
----

[source,json]
----
// package.json
{
  "scripts": {
    "test": "mocha",
    "test:watch": "mocha --watch --watch-extensions ts",
    "test:reporter": "mocha --reporter html --reporter-options outFile=test-report.html"
  }
}
----

===== Suite y tests básicos

[source,typescript]
----
// tests/calculadora.test.ts
import { expect } from "chai";

// Funciones a probar
function sumar(a: number, b: number): number {
  return a + b;
}

function restar(a: number, b: number): number {
  return a - b;
}

// Suite de tests
describe("Calculadora", () => {
  describe("Suma", () => {
    it("debería sumar dos números positivos", () => {
      const resultado = sumar(5, 3);
      expect(resultado).to.equal(8);
    });

    it("debería sumar números negativos", () => {
      const resultado = sumar(-5, -3);
      expect(resultado).to.equal(-8);
    });

    it("debería sumar positivo con negativo", () => {
      const resultado = sumar(5, -3);
      expect(resultado).to.equal(2);
    });
  });

  describe("Resta", () => {
    it("debería restar dos números", () => {
      const resultado = restar(5, 3);
      expect(resultado).to.equal(2);
    });

    it("debería manejar restas negativas", () => {
      const resultado = restar(3, 5);
      expect(resultado).to.equal(-2);
    });
  });
});
----

===== Aserciones de Chai

[source,typescript]
----
// tests/aserciones.test.ts
import { expect } from "chai";

describe("Aserciones Chai", () => {
  // Igualdad
  it("debe verificar igualdad", () => {
    expect(5).to.equal(5);
    expect("texto").to.equal("texto");
    expect([1, 2]).to.deep.equal([1, 2]);
  });

  // Verdad
  it("debe verificar verdad", () => {
    expect(true).to.be.true;
    expect(false).to.be.false;
    expect(null).to.be.null;
    expect(undefined).to.be.undefined;
  });

  // Tipos
  it("debe verificar tipos", () => {
    expect(42).to.be.a("number");
    expect("texto").to.be.a("string");
    expect([]).to.be.an("array");
    expect({}).to.be.an("object");
  });

  // Arrays y strings
  it("debe verificar contenido", () => {
    expect([1, 2, 3]).to.include(2);
    expect("hello").to.include("ell");
    expect({ a: 1, b: 2 }).to.have.property("a");
  });

  // Comparaciones
  it("debe hacer comparaciones", () => {
    expect(5).to.be.greaterThan(3);
    expect(3).to.be.lessThan(5);
    expect(5).to.be.greaterThanOrEqual(5);
    expect(5).to.be.lengthOf(1); // string length
  });

  // Excepciones
  it("debe detectar excepciones", () => {
    const fn = () => {
      throw new Error("Algo salió mal");
    };

    expect(fn).to.throw();
    expect(fn).to.throw(Error);
    expect(fn).to.throw("Algo salió mal");
  });
});
----

===== Hooks (before, after, etc)

[source,typescript]
----
// tests/hooks.test.ts
import { expect } from "chai";

describe("Hooks", () => {
  // Se ejecuta antes de todos los tests
  before(() => {
    console.log("Iniciando suite");
  });

  // Se ejecuta después de todos los tests
  after(() => {
    console.log("Finalizando suite");
  });

  // Se ejecuta antes de cada test
  beforeEach(() => {
    console.log("Antes de cada test");
  });

  // Se ejecuta después de cada test
  afterEach(() => {
    console.log("Después de cada test");
  });

  it("test 1", () => {
    expect(true).to.be.true;
  });

  it("test 2", () => {
    expect(true).to.be.true;
  });
});
----

===== Ejemplo práctico: Testing de clase

[source,typescript]
----
// src/usuario.ts
export interface UsuarioId {
  id: number;
  nombre: string;
  email: string;
}

export class Repositorio {
  private usuarios: UsuarioId[] = [];
  private idActual = 1;

  crear(nombre: string, email: string): UsuarioId {
    const usuario: UsuarioId = {
      id: this.idActual++,
      nombre,
      email
    };
    this.usuarios.push(usuario);
    return usuario;
  }

  obtener(id: number): UsuarioId | undefined {
    return this.usuarios.find(u => u.id === id);
  }

  obtenerPorEmail(email: string): UsuarioId | undefined {
    return this.usuarios.find(u => u.email === email);
  }

  actualizar(id: number, cambios: Partial<UsuarioId>): UsuarioId | undefined {
    const usuario = this.obtener(id);
    if (!usuario) return undefined;

    Object.assign(usuario, cambios);
    return usuario;
  }

  eliminar(id: number): boolean {
    const index = this.usuarios.findIndex(u => u.id === id);
    if (index > -1) {
      this.usuarios.splice(index, 1);
      return true;
    }
    return false;
  }

  obtenerTodos(): UsuarioId[] {
    return [...this.usuarios];
  }
}

// tests/usuario.test.ts
import { expect } from "chai";
import { Repositorio } from "../src/usuario";

describe("Repositorio de Usuarios", () => {
  let repositorio: Repositorio;

  beforeEach(() => {
    repositorio = new Repositorio();
  });

  describe("crear", () => {
    it("debería crear un usuario con ID único", () => {
      const usuario = repositorio.crear("Juan", "juan@example.com");
      expect(usuario).to.have.property("id", 1);
      expect(usuario).to.have.property("nombre", "Juan");
    });

    it("debería incrementar ID con cada usuario", () => {
      const user1 = repositorio.crear("Juan", "juan@example.com");
      const user2 = repositorio.crear("María", "maria@example.com");

      expect(user1.id).to.equal(1);
      expect(user2.id).to.equal(2);
    });
  });

  describe("obtener", () => {
    it("debería obtener usuario por ID", () => {
      const creado = repositorio.crear("Juan", "juan@example.com");
      const obtenido = repositorio.obtener(creado.id);

      expect(obtenido).to.deep.equal(creado);
    });

    it("debería retornar undefined si no existe", () => {
      const resultado = repositorio.obtener(999);
      expect(resultado).to.be.undefined;
    });
  });

  describe("actualizar", () => {
    it("debería actualizar usuario existente", () => {
      const creado = repositorio.crear("Juan", "juan@example.com");
      repositorio.actualizar(creado.id, { nombre: "Carlos" });

      const actualizado = repositorio.obtener(creado.id);
      expect(actualizado?.nombre).to.equal("Carlos");
    });
  });

  describe("eliminar", () => {
    it("debería eliminar usuario existente", () => {
      const creado = repositorio.crear("Juan", "juan@example.com");
      const resultado = repositorio.eliminar(creado.id);

      expect(resultado).to.be.true;
      expect(repositorio.obtener(creado.id)).to.be.undefined;
    });

    it("debería retornar false si no existe", () => {
      const resultado = repositorio.eliminar(999);
      expect(resultado).to.be.false;
    });
  });
});
----


==== 14.2 Testing de Tipos con Conditional Types

Verificar que los tipos funcionen correctamente en tiempo de compilación.

===== Type-level testing

[source,typescript]
----
// tests/tipos.test.ts

// Helper para testing de tipos
type Expect<T extends true> = T;
type Equals<X, Y> = 
  (<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2) ? true : false;

// Tests de tipos básicos
type Test1 = Expect<Equals<string, string>>;  // ✓
// type Test2 = Expect<Equals<string, number>>;  // ✗ Error

// Test de tipos genéricos
type ObtenerTipo<T> = T extends string ? "string" : 
                      T extends number ? "number" :
                      "otro";

type Test3 = Expect<Equals<ObtenerTipo<"hola">, "string">>;  // ✓
type Test4 = Expect<Equals<ObtenerTipo<42>, "number">>;      // ✓
type Test5 = Expect<Equals<ObtenerTipo<true>, "otro">>;      // ✓

// Test de tipos con arrays
type ObtenerElemento<T> = T extends (infer E)[] ? E : never;

type Test6 = Expect<Equals<ObtenerElemento<[1, 2, 3]>, number>>;  // ✓
type Test7 = Expect<Equals<ObtenerElemento<string[]>, string>>;   // ✓
type Test8 = Expect<Equals<ObtenerElemento<string>, never>>;      // ✓
----

===== Testing con tsd para tipos complejos

[source,bash]
----
npm install --save-dev tsd
----

[source,typescript]
----
// tipos.ts
export interface Respuesta<T> {
  datos: T;
  estado: "éxito" | "error";
}

export function procesar<T>(entrada: T): Respuesta<T> {
  return {
    datos: entrada,
    estado: "éxito"
  };
}

export type RespuestaExito<T> = Respuesta<T> & { estado: "éxito" };

// tests/tipos.test-d.ts (con tsd)
import { expectType, expectNotType, expectAssignable, expectNotAssignable } from "tsd";
import { Respuesta, procesar, RespuestaExito } from "../tipos";

// Expectativas básicas
expectType<Respuesta<string>>(procesar("test"));
expectType<Respuesta<number>>(procesar(42));

// Chequeos de tipo específico
const respuesta = procesar("test") as Respuesta<string>;
expectType<"éxito" | "error">(respuesta.estado);
expectNotType<"pendiente">(respuesta.estado);

// Chequeos asignables
expectAssignable<Respuesta<any>>({ datos: "x", estado: "éxito" });
expectNotAssignable<Respuesta<string>>({ datos: 123, estado: "éxito" });
----


==== 14.3 Mocking y Stubbing en TypeScript

Reemplazar dependencias para tests aislados.

===== Sinon para stubbing

[source,bash]
----
npm install --save-dev sinon @types/sinon
----

[source,typescript]
----
// src/notificador.ts
export interface Notificador {
  enviar(email: string, mensaje: string): Promise<boolean>;
}

export class Servicio {
  constructor(private notificador: Notificador) {}

  async registrarUsuario(email: string): Promise<void> {
    const enviado = await this.notificador.enviar(email, "Bienvenido");
    if (!enviado) {
      throw new Error("No se pudo enviar email");
    }
  }
}

// tests/notificador.test.ts
import { expect } from "chai";
import * as sinon from "sinon";
import { Servicio, Notificador } from "../src/notificador";

describe("Servicio con mocking", () => {
  let stub: sinon.SinonStub;
  let notificador: Notificador;
  let servicio: Servicio;

  beforeEach(() => {
    notificador = {
      enviar: sinon.stub().resolves(true)
    };
    servicio = new Servicio(notificador);
    stub = notificador.enviar as sinon.SinonStub;
  });

  it("debería registrar usuario e invocar notificador", async () => {
    await servicio.registrarUsuario("test@example.com");

    expect(stub.calledOnce).to.be.true;
    expect(stub.calledWith("test@example.com", "Bienvenido")).to.be.true;
  });

  it("debería manejar error si notificación falla", async () => {
    stub.resolves(false);

    try {
      await servicio.registrarUsuario("test@example.com");
      expect.fail("Debería lanzar error");
    } catch (error) {
      expect((error as Error).message).to.include("No se pudo enviar email");
    }
  });

  it("should verify stub call count", () => {
    stub.callCount === 0 ? null : null;
  });
});
----

===== Jest con mocks

[source,bash]
----
npm install --save-dev jest ts-jest @types/jest
----

[source,json]
----
// jest.config.js
module.exports = {
  preset: "ts-jest",
  testEnvironment: "node",
  testMatch: ["**/__tests__/**/*.ts", "**/?(*.)+(spec|test).ts"]
};
----

[source,typescript]
----
// tests/api.test.ts (con Jest)
import axios from "axios";

jest.mock("axios");
const mockedAxios = axios as jest.Mocked<typeof axios>;

describe("API Cliente", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it("debería obtener datos de API", async () => {
    const mockData = { id: 1, nombre: "Juan" };
    
    mockedAxios.get.mockResolvedValue({ data: mockData });

    const response = await axios.get("/usuarios/1");

    expect(mockedAxios.get).toHaveBeenCalledWith("/usuarios/1");
    expect(response.data).toEqual(mockData);
  });

  it("debería manejar errores de API", async () => {
    const error = new Error("Network error");
    mockedAxios.get.mockRejectedValue(error);

    await expect(axios.get("/usuarios/999")).rejects.toThrow("Network error");
  });
});
----

===== Inyección de dependencias para testing

[source,typescript]
----
// src/base-datos.ts
export interface BaseDatos {
  conectar(): Promise<void>;
  consultar(sql: string): Promise<any[]>;
  desconectar(): Promise<void>;
}

export class Repositorio {
  constructor(private db: BaseDatos) {}

  async obtenerUsuarios(): Promise<any[]> {
    await this.db.conectar();
    const usuarios = await this.db.consultar("SELECT * FROM usuarios");
    await this.db.desconectar();
    return usuarios;
  }
}

// tests/base-datos.test.ts
import { expect } from "chai";
import { Repositorio, BaseDatos } from "../src/base-datos";

describe("Repositorio con BD MockeadA", () => {
  let mockDB: BaseDatos;
  let repositorio: Repositorio;

  beforeEach(() => {
    mockDB = {
      conectar: async () => {},
      consultar: async () => [
        { id: 1, nombre: "Juan" },
        { id: 2, nombre: "María" }
      ],
      desconectar: async () => {}
    };

    repositorio = new Repositorio(mockDB);
  });

  it("debería obtener usuarios de la BD", async () => {
    const usuarios = await repositorio.obtenerUsuarios();

    expect(usuarios).to.have.lengthOf(2);
    expect(usuarios[0]).to.have.property("nombre", "Juan");
  });
});
----


==== 14.4 Cobertura de Código

Medir qué porcentaje del código está siendo probado.

===== Configurar cobertura con Istanbul

[source,bash]
----
npm install --save-dev nyc
----

[source,json]
----
// .nycrc.json
{
  "all": true,
  "include": ["src/**/*.ts"],
  "exclude": ["**/*.test.ts", "**/*.d.ts"],
  "reporter": ["text", "html", "json"],
  "report-dir": "./coverage",
  "extension": [".ts"]
}
----

[source,json]
----
// package.json
{
  "scripts": {
    "test": "mocha",
    "coverage": "nyc mocha",
    "coverage:report": "nyc report --reporter=html"
  }
}
----

===== Interpretar reportes de cobertura

[source,bash]
----
# Ejecutar tests con cobertura
npm run coverage

# Ver reporte HTML
open coverage/index.html

# Salida típica:
# =============================== Coverage summary =========================
# Statements   : 92.5% ( 185/200 )
# Branches     : 85.0% ( 34/40 )
# Functions    : 90.0% ( 18/20 )
# Lines        : 92.5% ( 185/200 )
# ===========================================================================
----

===== Establecer umbrales de cobertura

[source,json]
----
// .nycrc.json
{
  "all": true,
  "check-coverage": true,
  "lines": 80,
  "functions": 80,
  "branches": 75,
  "statements": 80,
  "include": ["src/**/*.ts"],
  "exclude": ["**/*.test.ts"]
}
----

===== Analizar cobertura faltante

[source,typescript]
----
// src/validador.ts
export function validarEmail(email: string): boolean {
  if (!email.includes("@")) {
    return false;  // CUBIERTO
  }

  const partes = email.split("@");
  if (partes[1].length < 3) {
    return false;  // NO CUBIERTO por tests
  }

  return true;
}

export function validarEdad(edad: number): boolean {
  if (edad < 0) {
    return false;
  }

  if (edad > 150) {
    return false;  // NO CUBIERTO
  }

  return true;
}

// tests/validador.test.ts
import { expect } from "chai";
import { validarEmail, validarEdad } from "../src/validador";

describe("Validador", () => {
  it("debe rechazar email sin @", () => {
    expect(validarEmail("test")).to.be.false;
  });

  it("debe aceptar email válido", () => {
    expect(validarEmail("test@example.com")).to.be.true;
  });

  it("debe rechazar edad negativa", () => {
    expect(validarEdad(-5)).to.be.false;
  });

  it("debe aceptar edad válida", () => {
    expect(validarEdad(30)).to.be.true;
  });

  // Falta: test para edad > 150 y email con dominio corto
});
----

[source,bash]
----
# Ver qué líneas no están cubiertas
npm run coverage

# Verá marca "not covered" en líneas 7 y 19
----

===== Usar badges de cobertura

[source,markdown]
----
# Proyecto

![Coverage](https://img.shields.io/badge/coverage-92.5%25-green)
![Tests](https://img.shields.io/badge/tests-42%20passing-green)

## Ejecutar Tests

\`\`\`bash
npm test
\`\`\`
----


==== Ejemplo Integrado: Testing Completo de Aplicación

[source,typescript]
----
// src/carrito.ts
export interface Producto {
  id: string;
  nombre: string;
  precio: number;
  cantidad: number;
}

export class Carrito {
  private items: Producto[] = [];

  agregarProducto(producto: Producto): void {
    const existente = this.items.find(p => p.id === producto.id);

    if (existente) {
      existente.cantidad += producto.cantidad;
    } else {
      this.items.push({ ...producto });
    }
  }

  removerProducto(id: string): void {
    const index = this.items.findIndex(p => p.id === id);
    if (index > -1) {
      this.items.splice(index, 1);
    }
  }

  calcularTotal(): number {
    return this.items.reduce(
      (total, p) => total + p.precio * p.cantidad,
      0
    );
  }

  obtenerItems(): Producto[] {
    return [...this.items];
  }

  vaciar(): void {
    this.items = [];
  }
}

// tests/carrito.test.ts
import { expect } from "chai";
import { Carrito } from "../src/carrito";

describe("Carrito de Compras", () => {
  let carrito: Carrito;

  beforeEach(() => {
    carrito = new Carrito();
  });

  describe("agregarProducto", () => {
    it("debería agregar producto al carrito vacío", () => {
      carrito.agregarProducto({
        id: "1",
        nombre: "Laptop",
        precio: 1000,
        cantidad: 1
      });

      const items = carrito.obtenerItems();
      expect(items).to.have.lengthOf(1);
      expect(items[0].nombre).to.equal("Laptop");
    });

    it("debería incrementar cantidad si producto existe", () => {
      carrito.agregarProducto({
        id: "1",
        nombre: "Mouse",
        precio: 25,
        cantidad: 1
      });
      carrito.agregarProducto({
        id: "1",
        nombre: "Mouse",
        precio: 25,
        cantidad: 2
      });

      const items = carrito.obtenerItems();
      expect(items[0].cantidad).to.equal(3);
    });
  });

  describe("calcularTotal", () => {
    it("debería calcular total correcto", () => {
      carrito.agregarProducto({ id: "1", nombre: "Laptop", precio: 1000, cantidad: 1 });
      carrito.agregarProducto({ id: "2", nombre: "Mouse", precio: 25, cantidad: 2 });

      const total = carrito.calcularTotal();
      expect(total).to.equal(1050);  // (1000 * 1) + (25 * 2)
    });

    it("debería retornar 0 para carrito vacío", () => {
      expect(carrito.calcularTotal()).to.equal(0);
    });
  });

  describe("removerProducto", () => {
    it("debería remover producto existente", () => {
      carrito.agregarProducto({ id: "1", nombre: "Laptop", precio: 1000, cantidad: 1 });
      carrito.removerProducto("1");

      expect(carrito.obtenerItems()).to.have.lengthOf(0);
    });

    it("no debería fallar al remover inexistente", () => {
      expect(() => carrito.removerProducto("99")).to.not.throw();
    });
  });

  describe("vaciar", () => {
    it("debería vaciar todos los productos", () => {
      carrito.agregarProducto({ id: "1", nombre: "Laptop", precio: 1000, cantidad: 1 });
      carrito.agregarProducto({ id: "2", nombre: "Mouse", precio: 25, cantidad: 1 });

      carrito.vaciar();

      expect(carrito.obtenerItems()).to.have.lengthOf(0);
      expect(carrito.calcularTotal()).to.equal(0);
    });
  });
});
----


==== Ejercicios Propuestos

.1. Suite de tests básica:
[source,typescript]
----
// Crear clase Contador con:
// - incrementar()
// - decrementar()
// - obtenerValor()
// - reiniciar()
// Escribir tests para todos los métodos
----

.2. Async testing:
[source,typescript]
----
// Crear función async que:
// - Obtiene datos de API simulada
// - Procesa los datos
// - Retorna resultado
// Tests con Mocha async/await
----

.3. Mocking de dependencia:
[source,typescript]
----
// Clase que depende de Logger
// Logger tiene método log(msg: string)
// Mock Logger en tests
// Verificar que fue llamado correctamente
----

.4. Cobertura completa:
[source,typescript]
----
// Escribir tests para alcanzar >90% cobertura
// Incluir casos edge y errores
// Generar reporte HTML
// Establecer umbrales de cobertura
----


=== Módulo 15: Rendimiento y Optimización

La optimización de código TypeScript es crucial para aplicaciones rápidas. Este módulo cubre herramientas y técnicas para mejorar el rendimiento.

==== 15.1 Análisis de Performance del Código TypeScript

===== Medir tiempo de ejecución

[source,typescript]
----
// Medición simple
console.time("operación");
// Código a medir
for (let i = 0; i < 1000000; i++) {
  Math.sqrt(i);
}
console.timeEnd("operación");
// Salida: operación: 12.345ms

// Medición más precisa con performance API
import { performance } from "perf_hooks";

const inicio = performance.now();

// Código a medir
for (let i = 0; i < 1000000; i++) {
  Math.sqrt(i);
}

const fin = performance.now();
console.log(`Tiempo: ${(fin - inicio).toFixed(2)}ms`);
----

===== Profiling de memoria

[source,typescript]
----
// Monitorear uso de memoria
function mostrarMemoria(): void {
  const mem = process.memoryUsage();
  console.log(`Heap usado: ${Math.round(mem.heapUsed / 1024 / 1024)}MB`);
  console.log(`Heap total: ${Math.round(mem.heapTotal / 1024 / 1024)}MB`);
  console.log(`RSS: ${Math.round(mem.rss / 1024 / 1024)}MB`);
}

// Detectar memory leaks
class CacheSinLimite {
  private cache = new Map<string, any>();

  set(clave: string, valor: any): void {
    this.cache.set(clave, valor);
    // ✗ Sin límite - memory leak potencial
  }

  get(clave: string): any {
    return this.cache.get(clave);
  }
}

// Solución: LRU Cache con límite
class CacheConLimite {
  private cache = new Map<string, any>();
  private readonly maxSize: number;

  constructor(maxSize: number = 100) {
    this.maxSize = maxSize;
  }

  set(clave: string, valor: any): void {
    if (this.cache.has(clave)) {
      this.cache.delete(clave);
    }

    this.cache.set(clave, valor);

    // Si excede límite, eliminar entrada más antigua
    if (this.cache.size > this.maxSize) {
      const primeira = this.cache.keys().next().value;
      this.cache.delete(primeira);
    }
  }

  get(clave: string): any {
    return this.cache.get(clave);
  }
}

// Usar
const cache = new CacheConLimite(50);
for (let i = 0; i < 100; i++) {
  cache.set(`key-${i}`, { data: "valor".repeat(1000) });
}
console.log("Cache limitado a 50 items");
----

===== Benchmarking de algoritmos

[source,typescript]
----
import { performance } from "perf_hooks";

function benchmark(
  nombre: string,
  fn: () => void,
  iteraciones: number = 1000
): void {
  const inicio = performance.now();

  for (let i = 0; i < iteraciones; i++) {
    fn();
  }

  const fin = performance.now();
  const promedio = (fin - inicio) / iteraciones;

  console.log(`${nombre}: ${promedio.toFixed(4)}ms por iteración`);
}

// Comparar algoritmos de búsqueda
function busquedaLineal(array: number[], objetivo: number): boolean {
  for (const item of array) {
    if (item === objetivo) return true;
  }
  return false;
}

function busquedaBinaria(array: number[], objetivo: number): boolean {
  let izq = 0, der = array.length - 1;

  while (izq <= der) {
    const mid = Math.floor((izq + der) / 2);
    if (array[mid] === objetivo) return true;
    if (array[mid] < objetivo) izq = mid + 1;
    else der = mid - 1;
  }
  return false;
}

// Ejecutar benchmark
const array = Array.from({ length: 10000 }, (_, i) => i);

benchmark("Búsqueda Lineal", () => {
  busquedaLineal(array, 9999);
}, 100);

benchmark("Búsqueda Binaria", () => {
  busquedaBinaria(array, 9999);
}, 100);

// Salida:
// Búsqueda Lineal: 0.0450ms por iteración
// Búsqueda Binaria: 0.0010ms por iteración (45x más rápido)
----

===== Profiler Node.js

[source,bash]
----
# Usar --prof para generar perfil V8
node --prof app.js

# Procesar archivo .isolate generado
node --prof-process isolate-*.log > perfil.txt

# Ver resultado con herramientas gráficas
# Chrome DevTools: about:inspect
----

===== Identificar cuellos de botella

[source,typescript]
----
class AnalisisRendimiento {
  private tiempos: Map<string, number[]> = new Map();

  iniciar(clave: string): () => void {
    const inicio = performance.now();

    return () => {
      const fin = performance.now();
      const duracion = fin - inicio;

      if (!this.tiempos.has(clave)) {
        this.tiempos.set(clave, []);
      }

      this.tiempos.get(clave)!.push(duracion);
    };
  }

  obtenerReporte(): void {
    console.log("=== Reporte de Rendimiento ===\n");

    for (const [clave, duraciones] of this.tiempos) {
      const promedio = duraciones.reduce((a, b) => a + b) / duraciones.length;
      const max = Math.max(...duraciones);
      const min = Math.min(...duraciones);

      console.log(`${clave}:`);
      console.log(`  Promedio: ${promedio.toFixed(2)}ms`);
      console.log(`  Min: ${min.toFixed(2)}ms`);
      console.log(`  Max: ${max.toFixed(2)}ms`);
      console.log(`  Llamadas: ${duraciones.length}\n`);
    }
  }
}

// Usar
const analisis = new AnalisisRendimiento();

const timer1 = analisis.iniciar("consulta-bd");
// ... código de consulta
timer1();

const timer2 = analisis.iniciar("procesamiento");
// ... procesamiento
timer2();

analisis.obtenerReporte();
----


==== 15.2 Optimización de Tipos para Compilación

===== Impacto de tipos en compilación

[source,json]
----
// tsconfig.json menos óptimo
{
  "compilerOptions": {
    "skipLibCheck": false,  // ✗ Verifica tipos de librerías
    "noImplicitAny": true,   // ✗ Análisis más lento
    "strictNullChecks": true, // ✗ Más validación
    "target": "ES5"          // ✗ Transpilación más compleja
  }
}

// tsconfig.json optimizado
{
  "compilerOptions": {
    "skipLibCheck": true,     // ✓ Salta verificación de tipos de node_modules
    "noImplicitAny": true,
    "target": "ES2020",       // ✓ Menos transpilación
    "incremental": true,      // ✓ Compilación incremental
    "isolatedModules": true,  // ✓ Módulos independientes
    "declaration": false,     // Si no necesitas .d.ts
    "tsBuildInfoFile": ".tsbuildinfo"
  }
}
----

===== Evitar any cuando es posible

[source,typescript]
----
// ✗ Lento - any detiene type checking
function procesarDatos(datos: any): any {
  return datos.propiedad.metodo();
}

// ✓ Rápido - tipos específicos
interface Datos {
  propiedad: {
    metodo(): string;
  };
}

function procesarDatos(datos: Datos): string {
  return datos.propiedad.metodo();
}

// ✓ unknown + type guards también funciona
function procesarDatos(datos: unknown): string {
  if (typeof datos === "object" && datos !== null && "propiedad" in datos) {
    return String((datos as any).propiedad.metodo());
  }
  return "";
}
----

===== Compilación condicional basada en ambiente

[source,typescript]
----
// utils.ts
export function log(mensaje: string): void {
  if (process.env.NODE_ENV === "development") {
    console.log(mensaje);
  }
  // En producción, se elimina por tree-shaking
}

// main.ts
import { log } from "./utils";

log("Debug info");  // Solo en desarrollo

// tsconfig.json
{
  "compilerOptions": {
    "define": {
      "DEBUG": false  // Para modo producción
    }
  }
}
----

===== Modular architecture para compilación rápida

[source,text]
----
src/
  core/
    tsconfig.json (strict)
  utils/
    tsconfig.json (estándar)
  features/
    tsconfig.json (relajado para desarrollo)
    typescript/
----

[source,json]
----
// src/core/tsconfig.json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "strict": true
  },
  "include": ["./**/*.ts"]
}

// src/utils/tsconfig.json
{
  "extends": "../../tsconfig.json",
  "include": ["./**/*.ts"]
}
----

===== Medir tiempo de compilación

[source,bash]
----
# Tiempo de compilación
time tsc

# Con estadísticas detalladas
tsc --diagnostics

# Generar perfil de compilación
tsc --extendedDiagnostics > build-stats.txt
----

===== Cachés y construcciones incrementales

[source,bash]
----
# Habilitar compilación incremental
tsc --incremental

# Ver archivo de estado
cat .tsbuildinfo

# Limpiar caché
rm .tsbuildinfo

# Building from clean state
tsc --clean
tsc
----


==== 15.3 Tree-shaking y Código Muerto

===== Código eliminado por bundlers

[source,typescript]
----
// math.ts
export function sumar(a: number, b: number): number {
  return a + b;
}

export function restar(a: number, b: number): number {
  return a - b;
}

export function funcionNoUsada(): void {
  console.log("Esto nunca se llama");
}

// main.ts
import { sumar } from "./math";

console.log(sumar(5, 3));  // webpack/rollup elimina restar() y funcionNoUsada()

// Bundle resultado (con tree-shaking):
// export function sumar(a, b) { return a + b; }
// console.log(sumar(5, 3));

// Sin tree-shaking el bundle sería más grande
----

===== Exportaciones nombradas vs default

[source,typescript]
----
// ✗ Default exports no son tan tree-shakeable
export default {
  sumar: (a: number, b: number) => a + b,
  restar: (a: number, b: number) => a - b,
  funcionNoUsada: () => console.log("unused")
};

// ✓ Named exports son mejores para tree-shaking
export const sumar = (a: number, b: number) => a + b;
export const restar = (a: number, b: number) => a - b;
export const funcionNoUsada = () => console.log("unused");

// Usar
import { sumar } from "./math";

// Bundler puede eliminar restar y funcionNoUsada
----

===== Side effects en package.json

[source,json]
----
// package.json
{
  "name": "mi-libreria",
  "main": "dist/index.js",
  "module": "dist/index.esm.js",
  "sideEffects": false,  // ✓ Seguro para tree-shaking
  "exports": {
    ".": {
      "import": "./dist/index.esm.js",
      "require": "./dist/index.js"
    }
  }
}

// Si tienes archivos con side effects:
{
  "sideEffects": [
    "./src/polyfills.ts",
    "./src/globals.css"
  ]
}
----

===== Detectar código muerto

[source,typescript]
----
// src/utils.ts
export function usado(): void {
  console.log("Se usa en main");
}

export function noUsado(): void {
  console.log("Nunca se importa");
}

function privadoNoUsado(): void {
  console.log("Privado, no se exporta");
}

// main.ts
import { usado } from "./utils";

usado();

// TypeScript puede advertir sobre variables no usadas
// Usar: "noUnusedLocals": true en tsconfig.json
----

===== Análisis de bundle size

[source,bash]
----
# Instalar herramientas
npm install --save-dev webpack-bundle-analyzer source-map-explorer

# Generar bundle y analizar
webpack && npx webpack-bundle-analyzer dist/stats.json

# O con source-map-explorer
npm run build
npx source-map-explorer 'dist/**/*.js'

# Ver tamaño de archivos
ls -lh dist/

# Comprimir y medir
gzip -c dist/bundle.js | wc -c
----

===== Optimizar imports

[source,typescript]
----
// ✗ Importar todo - 200KB
import lodash from "lodash";
console.log(lodash.sum([1, 2, 3]));

// ✓ Importar solo lo necesario - 5KB
import { sum } from "lodash-es";
console.log(sum([1, 2, 3]));

// ✓ Mejor aún - usar función nativa
const sum = (arr: number[]) => arr.reduce((a, b) => a + b, 0);
console.log(sum([1, 2, 3]));

// Verificar en webpack.config.js
{
  resolve: {
    alias: {
      "lodash-es": "lodash"
    }
  }
}
----

===== Dynamic imports para code splitting

[source,typescript]
----
// router.ts
interface Rutas {
  [key: string]: () => Promise<any>;
}

const rutas: Rutas = {
  home: () => import("./pages/home"),
  about: () => import("./pages/about"),
  contact: () => import("./pages/contact")
};

async function cargarPagina(ruta: string): Promise<void> {
  if (ruta in rutas) {
    const modulo = await rutas[ruta]();
    modulo.render();
  }
}

// Uso
cargarPagina("home");    // Solo descarga home.js
cargarPagina("about");   // Descarga about.js cuando se necesita
----


==== 15.4 Debugging de Código TypeScript Compilado

===== Source maps

[source,json]
----
// tsconfig.json
{
  "compilerOptions": {
    "sourceMap": true,
    "sourceRoot": "../src",
    "mapRoot": "../maps"
  }
}
----

[source,bash]
----
# Compilar con source maps
tsc --sourceMap

# Ver archivo .map generado
cat dist/main.js.map
----

===== Debugging en VS Code

[source,json]
----
// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Launch Program",
      "program": "${workspaceFolder}/dist/index.js",
      "preLaunchTask": "tsc: build",
      "outFiles": ["${workspaceFolder}/dist/**/*.js"],
      "sourceMaps": true
    }
  ]
}
----

===== Chrome DevTools debugging

[source,bash]
----
# Ejecutar con inspector
node --inspect dist/main.js

# O en modo break
node --inspect-brk dist/main.js

# Abre chrome://inspect en navegador Chrome
# Haz clic en "inspect"
----

===== Debugging con breakpoints

[source,typescript]
----
// main.ts
import { calcular } from "./utils";

function procesarDatos(valores: number[]): void {
  // Breakpoint: establecer en línea siguiente
  const resultados = valores.map(v => calcular(v));

  // Usar debugger; para pausa automática
  debugger;

  console.log(resultados);
}

procesarDatos([1, 2, 3]);

// En DevTools:
// 1. Abre inspector (F12)
// 2. Verás código original TypeScript (no compilado)
// 3. Haz hover sobre variables para ver valores
// 4. Coloca breakpoints haciendo clic
----

===== Logging estratégico

[source,typescript]
----
// logger.ts
enum LogLevel {
  ERROR = 0,
  WARN = 1,
  INFO = 2,
  DEBUG = 3
}

class Logger {
  private nivel: LogLevel = process.env.NODE_ENV === "production"
    ? LogLevel.WARN
    : LogLevel.DEBUG;

  log(nivel: LogLevel, mensaje: string, datos?: any): void {
    if (nivel <= this.nivel) {
      const prefijo = LogLevel[nivel];
      console.log(`[${prefijo}] ${mensaje}`, datos || "");
    }
  }

  error(msg: string, err?: Error): void {
    this.log(LogLevel.ERROR, msg, err?.stack);
  }

  warn(msg: string): void {
    this.log(LogLevel.WARN, msg);
  }

  info(msg: string): void {
    this.log(LogLevel.INFO, msg);
  }

  debug(msg: string, datos?: any): void {
    this.log(LogLevel.DEBUG, msg, datos);
  }
}

export const logger = new Logger();

// Usar
logger.debug("Valor recibido", { entrada: 42 });
logger.error("Falló la operación", new Error("Network error"));
----

===== Tracing de ejecución

[source,typescript]
----
function tracer<T extends (...args: any[]) => any>(fn: T, nombre?: string): T {
  return ((...args: any[]) => {
    const nombreFunc = nombre || fn.name || "anónima";
    console.log(`→ ${nombreFunc}(`, args, ")");

    const resultado = fn(...args);

    console.log(`← ${nombreFunc} retorna`, resultado);
    return resultado;
  }) as T;
}

// Usar
const suma = (a: number, b: number) => a + b;
const sumaTrackeada = tracer(suma, "suma");

sumaTrackeada(5, 3);
// Salida:
// → suma( [ 5, 3 ] )
// ← suma retorna 8
----

===== Profiling en producción

[source,typescript]
----
// stats.ts
class EstadisticasProduccion {
  private errores: Map<string, number> = new Map();
  private tiempos: Map<string, number[]> = new Map();

  registrarError(tipo: string): void {
    this.errores.set(tipo, (this.errores.get(tipo) || 0) + 1);
  }

  registrarTiempo(operacion: string, ms: number): void {
    if (!this.tiempos.has(operacion)) {
      this.tiempos.set(operacion, []);
    }
    this.tiempos.get(operacion)!.push(ms);
  }

  obtenerReporte() {
    const reporte = {
      errores: Object.fromEntries(this.errores),
      operaciones: Object.fromEntries(
        Array.from(this.tiempos).map(([op, tiempos]) => [
          op,
          {
            promedio: tiempos.reduce((a, b) => a + b) / tiempos.length,
            max: Math.max(...tiempos),
            llamadas: tiempos.length
          }
        ])
      )
    };

    return reporte;
  }

  enviarAAnalytics(): void {
    // Enviar a servicio de monitoreo
    console.log(JSON.stringify(this.obtenerReporte()));
  }
}

export const stats = new EstadisticasProduccion();
----


==== Ejemplo Integrado: Optimización de Aplicación

[source,typescript]
----
// app.ts
import { performance } from "perf_hooks";

class OptimizadorApp {
  private metricas: Map<string, number[]> = new Map();

  async procesarConAnalisis<T>(
    nombre: string,
    fn: () => Promise<T>
  ): Promise<T> {
    const inicio = performance.now();

    try {
      const resultado = await fn();
      const duracion = performance.now() - inicio;

      this.registrarMetrica(nombre, duracion);

      return resultado;
    } catch (error) {
      const duracion = performance.now() - inicio;
      this.registrarMetrica(`${nombre}-error`, duracion);
      throw error;
    }
  }

  private registrarMetrica(nombre: string, duracion: number): void {
    if (!this.metricas.has(nombre)) {
      this.metricas.set(nombre, []);
    }
    this.metricas.get(nombre)!.push(duracion);
  }

  generarReporte(): void {
    console.log("=== Métricas de Aplicación ===\n");

    for (const [nombre, duraciones] of this.metricas) {
      const promedio = duraciones.reduce((a, b) => a + b) / duraciones.length;
      console.log(`${nombre}:`);
      console.log(`  Promedio: ${promedio.toFixed(2)}ms`);
      console.log(`  Llamadas: ${duraciones.length}\n`);
    }
  }
}

// Usar
const app = new OptimizadorApp();

const resultado = await app.procesarConAnalisis("carga-datos", async () => {
  // Simular operación lenta
  await new Promise(resolve => setTimeout(resolve, 100));
  return { datos: [1, 2, 3] };
});

app.generarReporte();
----


==== Ejercicios Propuestos

.1. Benchmarking:
[source,typescript]
----
// Comparar dos algoritmos:
// - Búsqueda con array.includes()
// - Búsqueda con Set.has()
// Medir tiempo para arrays de diferentes tamaños
----

.2. Memory profiling:
[source,typescript]
----
// Crear caché sin límite
// Monitorear memoria
// Implementar LRU cache con límite
// Verificar que no tiene memory leak
----

.3. Tree-shaking:
[source,typescript]
----
// Crear librería con funciones exportadas
// Configurar webpack para tree-shaking
// Importar solo lo necesario
// Medir tamaño del bundle
----

.4. Profiling de aplicación:
[source,typescript]
----
// Agregar medición de tiempo a funciones críticas
// Usar performance API
// Generar reporte de rendimiento
// Identificar cuellos de botella
----

=== Módulo 16: Arquitectura y Escalabilidad

La arquitectura escalable es esencial para aplicaciones TypeScript grandes. Este módulo cubre patrones y herramientas para sistemas complejos.

==== 16.1 Arquitectura de Aplicaciones TypeScript Grandes

===== Capas de la arquitectura

[source,text]
----
src/
  presentation/
    controllers/
    views/
    middleware/
  application/
    services/
    dto/
    mappers/
  domain/
    entities/
    interfaces/
    value-objects/
  infrastructure/
    repositories/
    database/
    external-services/
----

[source,typescript]
----
// domain/usuario/usuario.ts
export interface UsuarioId {
  value: string;
}

export class Usuario {
  constructor(
    private id: UsuarioId,
    private nombre: string,
    private email: string
  ) {}

  getId(): UsuarioId {
    return this.id;
  }

  getNombre(): string {
    return this.nombre;
  }

  cambiarNombre(nuevoNombre: string): void {
    if (nuevoNombre.length < 2) {
      throw new Error("Nombre inválido");
    }
    this.nombre = nuevoNombre;
  }

  getEmail(): string {
    return this.email;
  }
}

// application/usuario/crear-usuario.ts
import { Usuario, UsuarioId } from "../../domain/usuario/usuario";
import { RepositorioUsuario } from "../../domain/usuario/repositorio-usuario";

export interface CrearUsuarioInput {
  id: string;
  nombre: string;
  email: string;
}

export class CrearUsuarioServicio {
  constructor(private repositorio: RepositorioUsuario) {}

  async ejecutar(entrada: CrearUsuarioInput): Promise<void> {
    const usuarioId: UsuarioId = { value: entrada.id };
    const usuario = new Usuario(usuarioId, entrada.nombre, entrada.email);

    await this.repositorio.guardar(usuario);
  }
}

// infrastructure/repositorio-usuario-sql.ts
import { RepositorioUsuario } from "../../domain/usuario/repositorio-usuario";
import { Usuario, UsuarioId } from "../../domain/usuario/usuario";

export class RepositorioUsuarioSQL implements RepositorioUsuario {
  async guardar(usuario: Usuario): Promise<void> {
    // Implementación SQL
    console.log(`Guardando usuario: ${usuario.getNombre()}`);
  }

  async obtenerPorId(id: UsuarioId): Promise<Usuario | null> {
    // Implementación SQL
    return null;
  }
}

// presentation/usuario-controller.ts
import { CrearUsuarioServicio } from "../../application/usuario/crear-usuario";

export class UsuarioController {
  constructor(private crearUsuario: CrearUsuarioServicio) {}

  async crear(req: any, res: any): Promise<void> {
    try {
      await this.crearUsuario.ejecutar(req.body);
      res.status(201).json({ mensaje: "Usuario creado" });
    } catch (error) {
      res.status(400).json({ error: (error as Error).message });
    }
  }
}
----

===== Dependency Injection

[source,typescript]
----
// container.ts
import { RepositorioUsuarioSQL } from "../infrastructure/repositorio-usuario-sql";
import { CrearUsuarioServicio } from "../application/usuario/crear-usuario";
import { UsuarioController } from "../presentation/usuario-controller";

export class Contenedor {
  private static instancia: Contenedor;
  private servicios: Map<string, any> = new Map();

  private constructor() {
    this.registrarServicios();
  }

  private registrarServicios(): void {
    // Registrar repositorios
    this.servicios.set("repositorio-usuario", new RepositorioUsuarioSQL());

    // Registrar servicios de aplicación
    const repositorio = this.obtener("repositorio-usuario");
    this.servicios.set("crear-usuario", new CrearUsuarioServicio(repositorio));

    // Registrar controladores
    const crearUsuario = this.obtener("crear-usuario");
    this.servicios.set("usuario-controller", new UsuarioController(crearUsuario));
  }

  static obtenerInstancia(): Contenedor {
    if (!Contenedor.instancia) {
      Contenedor.instancia = new Contenedor();
    }
    return Contenedor.instancia;
  }

  obtener<T>(clave: string): T {
    return this.servicios.get(clave);
  }
}

// main.ts
const contenedor = Contenedor.obtenerInstancia();
const controller = contenedor.obtener<UsuarioController>("usuario-controller");
----

===== Manejo de errores en capas

[source,typescript]
----
// domain/errores/usuario-no-encontrado.ts
export class UsuarioNoEncontradoError extends Error {
  constructor(id: string) {
    super(`Usuario ${id} no encontrado`);
    this.name = "UsuarioNoEncontradoError";
  }
}

// domain/errores/email-invalido.ts
export class EmailInvalidoError extends Error {
  constructor(email: string) {
    super(`Email ${email} inválido`);
    this.name = "EmailInvalidoError";
  }
}

// application/usuario/obtener-usuario.ts
import { UsuarioNoEncontradoError } from "../../domain/errores/usuario-no-encontrado";

export class ObtenerUsuarioServicio {
  constructor(private repositorio: RepositorioUsuario) {}

  async ejecutar(id: string): Promise<Usuario> {
    const usuario = await this.repositorio.obtenerPorId({ value: id });

    if (!usuario) {
      throw new UsuarioNoEncontradoError(id);
    }

    return usuario;
  }
}

// presentation/usuario-controller.ts
export class UsuarioController {
  async obtener(req: any, res: any): Promise<void> {
    try {
      const usuario = await this.obtenerUsuario.ejecutar(req.params.id);
      res.json(usuario);
    } catch (error) {
      if (error instanceof UsuarioNoEncontradoError) {
        res.status(404).json({ error: error.message });
      } else {
        res.status(500).json({ error: "Error interno" });
      }
    }
  }
}
----

===== Eventos de dominio

[source,typescript]
----
// domain/eventos/evento-dominio.ts
export interface EventoDominio {
  ocurridoEn: Date;
  agregarAlHistorial(): void;
}

// domain/eventos/usuario-creado.ts
export class UsuarioCreadoEvento implements EventoDominio {
  ocurridoEn: Date;

  constructor(
    public usuarioId: string,
    public nombre: string,
    public email: string
  ) {
    this.ocurridoEn = new Date();
  }

  agregarAlHistorial(): void {
    console.log(`Usuario creado: ${this.usuarioId}`);
  }
}

// domain/usuario/usuario.ts
export class Usuario {
  private eventosNoPublicados: EventoDominio[] = [];

  static crear(id: string, nombre: string, email: string): Usuario {
    const usuario = new Usuario({ value: id }, nombre, email);
    usuario.eventosNoPublicados.push(
      new UsuarioCreadoEvento(id, nombre, email)
    );
    return usuario;
  }

  obtenerEventosNoPublicados(): EventoDominio[] {
    return this.eventosNoPublicados;
  }

  limpiarEventos(): void {
    this.eventosNoPublicados = [];
  }
}

// application/publicador-eventos.ts
export interface PublicadorEventos {
  publicar(eventos: EventoDominio[]): Promise<void>;
}

export class CrearUsuarioServicio {
  constructor(
    private repositorio: RepositorioUsuario,
    private publicador: PublicadorEventos
  ) {}

  async ejecutar(entrada: CrearUsuarioInput): Promise<void> {
    const usuario = Usuario.crear(entrada.id, entrada.nombre, entrada.email);
    await this.repositorio.guardar(usuario);
    const eventos = usuario.obtenerEventosNoPublicados();
    await this.publicador.publicar(eventos);
    usuario.limpiarEventos();
  }
}
----

==== 16.2 Shared Libraries y Monorepos

===== Estructura de monorepo

[source,text]
----
monorepo/
  packages/
    core/
      src/
      tsconfig.json
      package.json
    common/
      src/
      tsconfig.json
      package.json
    api/
      src/
      tsconfig.json
      package.json
    web/
      src/
      tsconfig.json
      package.json
  tsconfig.json
  package.json
  lerna.json
----

===== Configurar lerna y pnpm

[source,bash]
----
npm install -g lerna
lerna init --independent
----

[source,json]
----
{
  "version": "independent",
  "packages": ["packages/*"],
  "npmClient": "npm",
  "command": {
    "publish": {
      "ignoreChanges": ["*.test.ts", "**/*.md"]
    }
  }
}
----

[source,yaml]
----
# pnpm-workspace.yaml
packages:
  - 'packages/*'
----

===== Dependencias entre paquetes

[source,json]
----
{
  "name": "@monorepo/core",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts"
}
----

[source,typescript]
----
import { EntityBase } from "@monorepo/core";

export class Servicio extends EntityBase {
  // Extiende clase del paquete core
}
----

===== Scripts en monorepo

[source,json]
----
{
  "scripts": {
    "build": "pnpm -r build",
    "test": "pnpm -r test",
    "lint": "pnpm -r lint"
  }
}
----

==== 16.3 Versionado y Semantic Versioning

===== Semver: MAJOR.MINOR.PATCH

[source,text]
----
MAJOR: Cambios incompatibles (breaking changes)
  1.0.0 -> 2.0.0

MINOR: Nuevas funcionalidades compatibles
  1.0.0 -> 1.1.0

PATCH: Fixes de bugs
  1.0.0 -> 1.0.1

Ejemplo: 2.3.5
  2 = MAJOR
  3 = MINOR
  5 = PATCH
----

===== Automatizar versionado

[source,bash]
----
npm install -g commitizen cz-conventional-changelog
npm install --save-dev @commitlint/config-conventional

commitizen init cz-conventional-changelog --save-dev
git cz commit
----

[source,bash]
----
npm install --save-dev standard-version

# En package.json
# "scripts": { "release": "standard-version" }

npm run release
# Genera CHANGELOG.md, tags, actualiza version
----

===== Publicar versión a npm

[source,json]
----
{
  "name": "@mi-org/libreria",
  "version": "1.2.3",
  "publishConfig": { "access": "public" },
  "scripts": { "prepublishOnly": "npm run build && npm run test" }
}
----

[source,bash]
----
npm publish
npm publish --tag beta
npm publish --tag alpha
npm view @mi-org/libreria versions
----

==== 16.4 Documentación con TypeDoc

===== Configurar TypeDoc

[source,bash]
----
npm install --save-dev typedoc
----

[source,json]
----
{
  "entryPoints": ["src"],
  "out": "docs",
  "theme": "default",
  "excludePrivate": true,
  "excludeExternals": true,
  "name": "Mi Librería"
}
----

===== Documentar código

[source,typescript]
----
/**
 * Calcula la suma de dos números
 * @param a - Primer número
 * @param b - Segundo número
 * @returns La suma de a y b
 */
export function sumar(a: number, b: number): number {
  return a + b;
}

/**
 * Clase para gestionar usuarios
 * @example
 * const gestor = new GestorUsuarios(config);
 * const usuario = await gestor.obtener("id-123");
 */
export class GestorUsuarios {
  constructor(private config: ConfiguracionRepositorio) {}

  /**
   * Obtiene un usuario por ID
   * @param id - ID del usuario
   * @returns Promise con los datos del usuario
   * @throws {Error} Si el usuario no existe
   */
  async obtener(id: string): Promise<any> {
    return {};
  }
}
----

===== Generar documentación

[source,bash]
----
npx typedoc
npx typedoc --out ./api-docs
open docs/index.html
----

[source,json]
----
{
  "scripts": {
    "docs": "typedoc",
    "docs:watch": "typedoc --watch"
  }
}
----

===== Publicar documentación

[source,bash]
----
npm run docs
git checkout --orphan docs
git add docs/
git commit -m "Documentation"
git push -u origin docs
----

==== Ejemplo Integrado: Arquitectura de Microservicios

[source,typescript]
----
// packages/core/src/entity.ts
export abstract class Entity<T> {
  protected id: T;
  constructor(id: T) {
    this.id = id;
  }
  getId(): T {
    return this.id;
  }
}

// packages/usuario/src/usuario.ts
import { Entity } from "@monorepo/core";

export class Usuario extends Entity<string> {
  constructor(
    id: string,
    private nombre: string,
    private email: string
  ) {
    super(id);
  }

  getNombre(): string {
    return this.nombre;
  }

  getEmail(): string {
    return this.email;
  }
}

// packages/usuario/src/servicio.ts
export class ServicioUsuario {
  constructor(private repo: RepositorioUsuario) {}

  async crear(id: string, nombre: string, email: string): Promise<Usuario> {
    const usuario = new Usuario(id, nombre, email);
    await this.repo.guardar(usuario);
    return usuario;
  }

  async obtener(id: string): Promise<Usuario | null> {
    return this.repo.obtenerPorId(id);
  }

  async listar(): Promise<Usuario[]> {
    return this.repo.obtenerTodos();
  }
}

// packages/usuario-api/src/controlador.ts
export class ControladorUsuario {
  constructor(private servicio: ServicioUsuario) {}

  async crear(req: any, res: any): Promise<void> {
    try {
      const usuario = await this.servicio.crear(
        req.body.id,
        req.body.nombre,
        req.body.email
      );
      res.status(201).json(usuario);
    } catch (error) {
      res.status(400).json({ error: (error as Error).message });
    }
  }

  async obtener(req: any, res: any): Promise<void> {
    const usuario = await this.servicio.obtener(req.params.id);
    if (usuario) {
      res.json(usuario);
    } else {
      res.status(404).json({ error: "No encontrado" });
    }
  }

  async listar(req: any, res: any): Promise<void> {
    const usuarios = await this.servicio.listar();
    res.json(usuarios);
  }
}
----

==== Ejercicios Propuestos

.1. Arquitectura por capas:
[source,typescript]
----
// Crear aplicación con:
// - Domain: Entidades y lógica de negocio
// - Application: Servicios
// - Infrastructure: Implementaciones
// - Presentation: Controladores
// - Inyectar dependencias
----

.2. Monorepo:
[source,bash]
----
// Setup:
// - Crear estructura de monorepo
// - Crear 3 paquetes (core, utils, api)
// - Establecer dependencias entre paquetes
// - Configurar scripts compartidos
----

.3. Versionado:
[source,bash]
----
// Setup:
// - Instalar commitizen y commitlint
// - Hacer commits convencionales
// - Automatizar bumping de versión
// - Publicar a npm
----

.4. Documentación:
[source,typescript]
----
// Crear:
// - Documentación JSDoc completa
// - Generar HTML con TypeDoc
// - Incluir ejemplos en docs
// - Publicar en GitHub Pages
----

===== Resumen del curso

Este curso ha cubierto TypeScript desde los fundamentos hasta arquitectura avanzada. El dominio de estos conceptos te permitirá:

✅ Escribir código type-safe y mantenible
✅ Construir aplicaciones escalables
✅ Colaborar efectivamente en equipos
✅ Resolver problemas complejos con TypeScript
✅ Optimizar rendimiento y usuario experience

Continúa practicando, explora proyectos reales, y mantente actualizado con los nuevos features de TypeScript!
