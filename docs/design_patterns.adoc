= Temario — Patrones de diseño de objetos
:author: Daniel Rojo Pérez
:revdate: 2026-02-17
:revnumber: 1.0
:toc: left
:toclevels: 3
:numbered:
:sectnums:
:source-highlighter: rouge

== Presentación y objetivo
Este temario cubre los fundamentos y ejemplos prácticos de los patrones de diseño orientados a objetos (GoF + patrones útiles en desarrollo moderno). El objetivo es que el alumno sepa reconocer cuándo aplicar un patrón, implantarlo en TypeScript/JavaScript y refactorizar código real para mejorar mantenibilidad, extensibilidad y testabilidad.

== Duración estimada
- Curso intensivo: 8–12 horas (teoría + prácticas)
- Formato sugerido: 6 módulos + taller práctico

== Resultados de aprendizaje
- Identificar problemas de diseño habituales y seleccionar el patrón adecuado.
- Implementar patrones en TypeScript con buenas prácticas (tests, interfaces y tipos).
- Aplicar principios SOLID y técnicas de refactorización para mejorar código existente.

== Módulo 1 — Introducción a los patrones (45 min)
=== ¿Qué es un patrón de diseño?
- Definición: solución probada a un problema recurrente en diseño de software.
- Estructura típica: Intención, Motivación, Estructura (UML), Consecuencias, Ejemplo.

=== Historia y catálogo GoF
- Breve repaso de los autores (Gamma, Helm, Johnson, Vlissides) y la clasificación: Creacionales, Estructurales, de Comportamiento.

=== UML básico y notación de patrones
- Clases, interfaces, dependencias y relaciones frecuentes usadas en ejemplos.

== Módulo 2 — Principios de diseño y antipatrons (1h)
=== Principios clave
- SOLID (Single Responsibility, Open/Closed, Liskov, Interface Segregation, Dependency Inversion)
- Principios GRASP (Creator, Controller, Information Expert)

=== Buenas prácticas
- Preferir composición sobre herencia, programación a interfaces, minimizar acoplamiento.

=== Anti‑patterns comunes
- God object, shotgun surgery, tight coupling — cuándo refactorizar hacia un patrón.

== Módulo 3 — Patrones creacionales (2h)
=== Objetivos
- Entender técnicas para separar la creación de objetos y controlar su ciclo de vida.
- Dar herramientas para construir APIs extensibles y fáciles de testear.

=== Patrones y variantes (qué veremos)
- Factory Method — creación basada en subclases o decisiones en tiempo de ejecución.
- Abstract Factory — familias de productos coherentes.
- Builder — construcción paso a paso (flujo encadenado) para objetos complejos e inmutables.
- Prototype — clonación/duplicado de objetos configurables.
- Singleton (discusión) — cuándo evitarlo y alternativas con DI.

=== Ejemplo rápido (Builder)
[source,ts]
----
    class QueryBuilder {
      private parts: string[] = [];
      select(...cols: string[]) { this.parts.push(`SELECT ${cols.join(',')}`); return this }
      from(table: string) { this.parts.push(`FROM ${table}`); return this }
      where(cond: string) { this.parts.push(`WHERE ${cond}`); return this }
      build() { return this.parts.join(' ') }
    }
----

=== Ejercicio
- Implementar `NotificationFactory` y un `NotificationBuilder` con tests que verifiquen distintas configuraciones.

== Módulo 4 — Patrones estructurales (2h)
=== Objetivos
- Aprender a componer y adaptar estructuras para reducir acoplamiento y mejorar reutilización.

=== Patrones y casos de uso
- Adapter — adaptar interfaces incompatibles.
- Facade — simplificar APIs complejas.
- Bridge — separar abstracción de implementación.
- Composite — representar jerarquías recursivas.
- Decorator — añadir comportamiento dinámicamente.
- Proxy — control de acceso / lazy loading / caching.
- Flyweight — compartir estado para reducir memoria.

=== Ejemplo rápido (Decorator)
[source,ts]
----
    interface Notifier { send(msg: string): Promise<void> }
    class EmailNotifier implements Notifier { async send(m: string){ console.log('email',m) } }
    class LoggedNotifier implements Notifier { constructor(private inner: Notifier){} async send(m:string){ console.log('log before'); await this.inner.send(m); console.log('log after') } }
----

=== Ejercicio
- Refactorizar un subsistema de envío (email + sms) para exponer una `Facade` y aplicar `Decorator` para logging y reintentos.

== Módulo 5 — Patrones de comportamiento (2.5h)
=== Objetivos
- Diseñar la interacción entre objetos, responsabilidades y protocolos de comunicación.

=== Patrones y énfasis en diseño
- Strategy, Observer/Publisher-Subscriber, Command (undo/redo), Iterator, State, Template Method.
- Chain of Responsibility, Mediator, Visitor, Memento (visión general y cuándo aplicarlos).

=== Ejemplo rápido (Command + Memento)
[source,ts]
----
    type Command = { execute(): void; undo?(): void }
    class AddTask implements Command { constructor(private store:any, private task:any){} execute(){ this.store.add(this.task)} undo(){ this.store.remove(this.task.id) } }
----

=== Ejercicio práctico
- Implementar un sistema de comandos con undo/redo y un bus de eventos (`Observer`) con tests.

== Módulo 6 — Patrones asíncronos (1.5h)
=== Objetivos
- Entender patrones para programación concurrente y asincrónica: resiliencia, control de flujo y comunicación entre componentes.

=== Patrones y técnicas a cubrir
- Promise / async-await (patterns for composition): Promise.all, race, allSettled.
- Pub/Sub y Event Bus — desacoplar emisores y consumidores.
- Retry / Backoff, Circuit Breaker, Bulkhead — resiliencia y tolerancia a fallos.
- Worker Pool / Throttling / Debounce — control de concurrencia y rate limiting.
- Saga (orquestación vs coreografía) y patrones para transacciones distribuidas (visión general).
- Idempotency y deduplicación en flujos asíncronos.

=== Ejemplo rápido (Retry con backoff)
[source,ts]
----
    async function retry<T>(fn: ()=>Promise<T>, retries = 3, delay = 200){
      try { return await fn() }
      catch (err) {
        if (retries <= 0) throw err
        await new Promise(r => setTimeout(r, delay))
        return retry(fn, retries-1, delay*2)
      }
    }
----

=== Ejercicio
- Implementar un `EventBus` (pub/sub) y un `retry` reusable con tests; diseñar un pequeño flujo que use un `WorkerPool` y un `CircuitBreaker` sencillo.

== Taller práctico — Proyecto final (2–3h)
- Propuesta: aplicación modular (p. ej. gestor de tareas o pipeline de procesamiento) que requiera:
  - Creacionales: Builder/Factory
  - Estructurales: Adapter/Facade/Decorator
  - Comportamiento: Command/Observer/State
- Entregables: diseño UML, implementación en TypeScript, pruebas y breve README que explique las decisiones de diseño.

== Evaluación y ejercicios propuestos
- Mini-quizzes por módulo (preguntas cortas)
- 2 ejercicios de implementación (uno por patrones creacionales/estructurales)
- Proyecto final con revisión de código (peer review)

== Recursos y lecturas recomendadas
- Gamma et al., "Design Patterns: Elements of Reusable Object-Oriented Software" (GoF)
- "Head First Design Patterns" — enfoque práctico y visual
- Artículos y ejemplos en TypeScript (repositorios con implementaciones y tests)

== Apéndice: ejemplos completos en TypeScript

Los ejemplos siguientes son versiones completas y ejecutables (autocontenidas) de los patrones tratados en el temario. También he añadido archivos de ejemplo en `examples/patterns/` dentro del repositorio para facilitar su ejecución y pruebas.

=== Creacionales
==== Factory Method
[source,ts]
----
    // Factory Method — selección de parser según el tipo de documento
    interface Parser { parse(input: string): any }
    class JsonParser implements Parser { parse(input: string){ return JSON.parse(input) } }
    class CsvParser implements Parser { parse(input: string){ return input.split(/\n/).map(r => r.split(',')) } }
    
    abstract class ParserFactory {
      abstract createParser(type: string): Parser
      parse(type: string, input: string) { const p = this.createParser(type); return p.parse(input) }
    }
    
    class ConcreteParserFactory extends ParserFactory {
      createParser(type: string): Parser {
        if (type === 'json') return new JsonParser()
        if (type === 'csv') return new CsvParser()
        throw new Error('unknown type')
      }
    }
    
    // Uso
    const factory = new ConcreteParserFactory()
    console.log(factory.parse('json', '{"a":1}'))
    console.log(factory.parse('csv', 'a,b\n1,2'))
----

==== Abstract Factory
[source,ts]
----
    // Abstract Factory — familias de componentes UI
    interface Button { render(): string }
    interface Checkbox { render(): string }
    interface UIFactory { createButton(): Button; createCheckbox(): Checkbox }
    
    class MacButton implements Button { render(){ return '<MacButton/>' } }
    class MacCheckbox implements Checkbox { render(){ return '<MacCheckbox/>' } }
    class MacFactory implements UIFactory { createButton(){ return new MacButton() } createCheckbox(){ return new MacCheckbox() } }
    
    class WinButton implements Button { render(){ return '<WinButton/>' } }
    class WinCheckbox implements Checkbox { render(){ return '<WinCheckbox/>' } }
    class WinFactory implements UIFactory { createButton(){ return new WinButton() } createCheckbox(){ return new WinCheckbox() } }
    
    function clientCode(factory: UIFactory){ console.log(factory.createButton().render()); console.log(factory.createCheckbox().render()) }
    clientCode(new MacFactory()); clientCode(new WinFactory())
----

==== Builder
[source,ts]
----
    // Builder — construcción fluida de objetos complejos
    class Pizza {
      dough = ''
      sauce = ''
      toppings: string[] = []
    }
    
    class PizzaBuilder {
      private pizza = new Pizza()
      setDough(d: string){ this.pizza.dough = d; return this }
      setSauce(s: string){ this.pizza.sauce = s; return this }
      addTopping(t: string){ this.pizza.toppings.push(t); return this }
      build(){ const p = this.pizza; this.pizza = new Pizza(); return p }
    }
    
    const margherita = new PizzaBuilder().setDough('thin').setSauce('tomato').addTopping('mozzarella').build()
    console.log(margherita)
----

==== Prototype
[source,ts]
----
    // Prototype — clonar objetos (ejemplo explícito)
    class Shape {
      constructor(public x:number, public y:number, public color:string){}
      clone(){ return new Shape(this.x, this.y, this.color) }
    }
    const s1 = new Shape(10,20,'red')
    const s2 = s1.clone(); s2.x = 99
    console.log(s1, s2)
----

==== Singleton (discusión y ejemplo)
[source,ts]
----
    // Singleton — acceso global controlado (usar con precaución)
    class Logger {
      private static _instance: Logger | null = null
      private constructor(private prefix = '[app]'){}
      static get instance(){ if (!this._instance) this._instance = new Logger(); return this._instance }
      log(msg: string){ console.log(`${this.prefix} ${msg}`) }
    }
    Logger.instance.log('inicio')
----

=== Estructurales
==== Adapter
[source,ts]
----
    // Adapter — adaptar una API antigua a una nueva
    class OldPaymentService { payInCents(cents: number){ return `paid ${cents}c` } }
    
    interface NewPaymentClient { pay(amount: number): string }
    class PaymentAdapter implements NewPaymentClient {
      constructor(private adaptee: OldPaymentService){}
      pay(amount: number){ return this.adaptee.payInCents(Math.round(amount*100)) }
    }
    
    const adapter = new PaymentAdapter(new OldPaymentService())
    console.log(adapter.pay(12.34))
----

==== Facade
[source,ts]
----
    // Facade — simplificar subsistemas
    class Auth { signIn(u:string,p:string){ return `token:${u}` } }
    class DB { save(k:string,v:any){ return `saved:${k}` } }
    class LoggerSvc { info(m:string){ console.log('LOG',m) } }
    class AppFacade {
      constructor(private auth=new Auth(), private db=new DB(), private log=new LoggerSvc()){}
      async register(username:string,password:string){ const token = this.auth.signIn(username,password); this.db.save('user', {username}); this.log.info('registered'); return token }
    }
    const app = new AppFacade(); app.register('u','p').then(t => console.log(t))
----

==== Bridge
[source,ts]
----
    // Bridge — separar abstracción de implementación
    interface Device { isOn(): boolean; turnOn(): void; turnOff(): void }
    class Tv implements Device { private on = false; isOn(){ return this.on } turnOn(){ this.on = true } turnOff(){ this.on = false } }
    class RemoteControl {
      constructor(protected device: Device){}
      toggle(){ if (this.device.isOn()) this.device.turnOff(); else this.device.turnOn() }
    }
    const tv = new Tv(); const remote = new RemoteControl(tv); remote.toggle(); console.log(tv.isOn())
----

==== Composite
[source,ts]
----
    // Composite — composición recursiva
    interface Component { getPrice(): number; print(indent?:string): void }
    class Item implements Component { constructor(private name:string, private price:number){} getPrice(){ return this.price } print(i=''){ console.log(i+this.name, this.price) } }
    class Box implements Component {
      private children: Component[] = []
      constructor(private name:string){}
      add(c: Component){ this.children.push(c) }
      getPrice(){ return this.children.reduce((s,c)=>s+c.getPrice(),0) }
      print(i=''){ console.log(i+this.name); this.children.forEach(c=>c.print(i+'  ')) }
    }
    const box = new Box('root'); box.add(new Item('pen',1.2)); const inner = new Box('inner'); inner.add(new Item('book',12)); box.add(inner); box.print(); console.log('total', box.getPrice())
----

==== Decorator
[source,ts]
----
    // Decorator — añadir responsabilidad dinámicamente
    interface Notifier { send(msg: string): Promise<void> }
    class EmailNotifier implements Notifier { async send(m:string){ console.log('email:', m) }}
    class NotifierDecorator implements Notifier { constructor(protected inner: Notifier){} async send(m:string){ await this.inner.send(m) }}
    class LoggingNotifier extends NotifierDecorator { async send(m:string){ console.log('before'); await super.send(m); console.log('after') }}
    (async ()=>{ const n = new LoggingNotifier(new EmailNotifier()); await n.send('hello') })()
----

==== Proxy
[source,ts]
----
    // Proxy — control de acceso / caching
    class RemoteService { async fetch(id:number){ console.log('fetch remote', id); return { id, value: Math.random() } } }
    class CacheProxy {
      private cache = new Map<number, any>()
      constructor(private svc = new RemoteService()){}
      async fetch(id:number){ if (this.cache.has(id)) return this.cache.get(id); const v = await this.svc.fetch(id); this.cache.set(id, v); return v }
    }
    (async ()=>{ const p = new CacheProxy(); console.log(await p.fetch(1)); console.log('cached', await p.fetch(1)) })()
----

==== Flyweight
[source,ts]
----
    // Flyweight — compartir estado intrínseco
    class CharFlyweight { constructor(public char:string){} render(fontSize:number, color:string){ return `${this.char}@${fontSize}/${color}` } }
    class FlyweightFactory { private pool = new Map<string, CharFlyweight>()
      get(char:string){ if (!this.pool.has(char)) this.pool.set(char, new CharFlyweight(char)); return this.pool.get(char)! }
    }
    const f = new FlyweightFactory(); console.log(f.get('a').render(12,'red'))
----

=== Comportamiento
==== Strategy
[source,ts]
----
    // Strategy — encapsular algoritmos intercambiables
    interface Strategy { execute(a:number,b:number): number }
    class Add implements Strategy { execute(a:number,b:number){ return a+b } }
    class Mul implements Strategy { execute(a:number,b:number){ return a*b } }
    class Calculator { constructor(private s: Strategy){} setStrategy(s: Strategy){ this.s = s } run(a:number,b:number){ return this.s.execute(a,b) } }
    const c = new Calculator(new Add()); console.log(c.run(2,3)); c.setStrategy(new Mul()); console.log(c.run(2,3))
----

==== Observer / Pub-Sub
[source,ts]
----
    // Observer — EventBus simple
    type Handler = (...args: any[])=>void
    class EventBus {
      private subs = new Map<string, Handler[]>()
      on(evt:string, h:Handler){ const a = this.subs.get(evt) ?? []; a.push(h); this.subs.set(evt,a); return ()=>this.off(evt,h) }
      off(evt:string, h:Handler){ const arr = this.subs.get(evt) ?? []; this.subs.set(evt, arr.filter(x=>x!==h)) }
      emit(evt:string, ...args:any[]){ (this.subs.get(evt) ?? []).forEach(h=>h(...args)) }
    }
    const bus = new EventBus(); const off = bus.on('msg', (m:any)=>console.log('got',m)); bus.emit('msg','hello'); off(); bus.emit('msg','ignored')
----

==== Command (con undo/redo)
[source,ts]
----
    // Command — ejecutar acciones con historial
    interface Command { execute(): void; undo?(): void }
    class Store { private items: string[] = []; add(i:string){ this.items.push(i) } remove(i:string){ this.items = this.items.filter(x=>x!==i) } list(){ return [...this.items] } }
    class AddCommand implements Command { constructor(private store:Store, private item:string){} execute(){ this.store.add(this.item) } undo(){ this.store.remove(this.item) } }
    class Invoker { private history: Command[] = []; execute(c:Command){ c.execute(); this.history.push(c) } undo(){ const c = this.history.pop(); if (c && c.undo) c.undo() } }
    const s = new Store(); const inv = new Invoker(); inv.execute(new AddCommand(s,'a')); inv.execute(new AddCommand(s,'b')); console.log(s.list()); inv.undo(); console.log(s.list())
----

==== Iterator
[source,ts]
----
    // Iterator — colección iterable personalizada
    class Range implements Iterable<number> {
      constructor(private start:number, private end:number){}
      *[Symbol.iterator](){ for(let i=this.start;i<=this.end;i++) yield i }
    }
    for (const n of new Range(1,3)) console.log(n)
----

==== State
[source,ts]
----
    // State — comportamiento dependiente del estado interno
    interface State { press(): void }
    class OnState implements State { constructor(private lamp: Lamp){ } press(){ console.log('turning off'); this.lamp.setState(new OffState(this.lamp)) } }
    class OffState implements State { constructor(private lamp: Lamp){ } press(){ console.log('turning on'); this.lamp.setState(new OnState(this.lamp)) } }
    class Lamp { constructor(private state: State = new OffState(undefined as any)) { this.state = state } setState(s: State){ this.state = s } press(){ this.state.press() } }
    const lamp = new Lamp(new OffState(undefined as any)); lamp.setState(new OffState(lamp)); lamp.press(); lamp.press()
----

==== Template Method
[source,ts]
----
    // Template Method — algoritmo con pasos fijos y personalizables
    abstract class DataProcessor {
      process(){ this.read(); this.transform(); this.save() }
      protected abstract read(): void
      protected abstract transform(): void
      protected abstract save(): void
    }
    class CsvProcessor extends DataProcessor { protected read(){ console.log('read csv') } protected transform(){ console.log('transform csv') } protected save(){ console.log('save csv') } }
    new CsvProcessor().process()
----

==== Chain of Responsibility
[source,ts]
----
    // Chain of Responsibility — encadenar handlers
    class Handler {
      constructor(public next?: Handler){}
      handle(request: number){ if (this.next) return this.next.handle(request); return null }
    }
    class DivisibleByTwo extends Handler { handle(r:number){ if (r%2===0) return 'two'; return super.handle(r) } }
    class DivisibleByThree extends Handler { handle(r:number){ if (r%3===0) return 'three'; return super.handle(r) } }
    const chain = new DivisibleByTwo(new DivisibleByThree()); console.log(chain.handle(9))
----

==== Mediator
[source,ts]
----
    // Mediator — coordinar colegas
    class ChatRoom {
      private users = new Map<string, Participant>()
      register(p: Participant){ this.users.set(p.name, p); p.room = this }
      send(from:string, to:string, msg:string){ const u = this.users.get(to); if (u) u.receive(from,msg) }
    }
    class Participant { room?: ChatRoom; constructor(public name: string){} send(to:string,msg:string){ this.room?.send(this.name,to,msg) } receive(from:string,msg:string){ console.log(`${this.name} got '${msg}' from ${from}`) } }
    const room = new ChatRoom(); const alice = new Participant('alice'); const bob = new Participant('bob'); room.register(alice); room.register(bob); alice.send('bob','hi')
----

==== Visitor (simplified)
[source,ts]
----
    // Visitor — operar sobre estructuras heterogéneas
    interface Element { accept(v: Visitor): void }
    class NodeA implements Element { constructor(public value:string){} accept(v:Visitor){ v.visitNodeA(this) } }
    class NodeB implements Element { constructor(public num:number){} accept(v:Visitor){ v.visitNodeB(this) } }
    interface Visitor { visitNodeA(n:NodeA): void; visitNodeB(n:NodeB): void }
    class RenderVisitor implements Visitor { visitNodeA(n:NodeA){ console.log('A', n.value) } visitNodeB(n:NodeB){ console.log('B', n.num) } }
    const nodes: Element[] = [new NodeA('x'), new NodeB(2)]; const rv = new RenderVisitor(); nodes.forEach(n=>n.accept(rv))
----

==== Memento
[source,ts]
----
    // Memento — capturar y restaurar estado
    class Memento { constructor(public state: string){} }
    class Editor { private state = ''; write(s:string){ this.state += s } save(){ return new Memento(this.state) } restore(m:Memento){ this.state = m.state } read(){ return this.state } }
    const e = new Editor(); e.write('hello'); const m = e.save(); e.write(' world'); console.log(e.read()); e.restore(m); console.log(e.read())
----

=== Asíncronos
==== Event Bus / Pub-Sub
[source,ts]
----
    // EventBus asíncrono
    type AsyncHandler = (...args:any[])=>Promise<void>|void
    class AsyncEventBus {
      private subs = new Map<string, AsyncHandler[]>()
      on(evt:string, h:AsyncHandler){ const a = this.subs.get(evt) ?? []; a.push(h); this.subs.set(evt,a); return ()=>this.off(evt,h) }
      off(evt:string, h:AsyncHandler){ const arr = this.subs.get(evt) ?? []; this.subs.set(evt, arr.filter(x=>x!==h)) }
      async emit(evt:string, ...args:any[]){ const list = this.subs.get(evt) ?? []; await Promise.all(list.map(h=>Promise.resolve(h(...args)))) }
    }
    const ab = new AsyncEventBus(); ab.on('job', async (id)=>{ console.log('handling', id); await new Promise(r=>setTimeout(r,50)) }); ab.emit('job', 1)
----

==== Retry / Backoff
[source,ts]
----
    // Retry con backoff exponencial
    async function retry<T>(fn: ()=>Promise<T>, retries = 3, delay = 100){
      try { return await fn() }
      catch (err) {
        if (retries <= 0) throw err
        await new Promise(r => setTimeout(r, delay))
        return retry(fn, retries-1, delay*2)
      }
    }
    let attempts = 0
    async function flaky(){ attempts++; if (attempts < 3) throw new Error('fail'); return 'ok' }
    retry(flaky, 5, 50).then(console.log).catch(e=>console.error('final error', e.message))
----

==== Circuit Breaker (sencillo)
[source,ts]
----
    // Circuit Breaker — protección básica
    type Fn<T> = ()=>Promise<T>
    class CircuitBreaker {
      private failures = 0; private state:'CLOSED'|'OPEN'|'HALF' = 'CLOSED'; private nextAttempt = 0
      constructor(private readonly threshold = 3, private readonly timeout = 1000) {}
      async exec<T>(fn: Fn<T>){
        if (this.state === 'OPEN' && Date.now() < this.nextAttempt) throw new Error('circuit open')
        try {
          const res = await fn(); this.success(); return res
        } catch (err) { this.fail(); throw err }
      }
      private success(){ this.failures = 0; this.state = 'CLOSED' }
      private fail(){ this.failures++; if (this.failures >= this.threshold){ this.state = 'OPEN'; this.nextAttempt = Date.now() + this.timeout } }
    }
    const cb = new CircuitBreaker(2, 200); let fcount=0
    async function sometimesFails(){ fcount++; if (fcount%2===0) return 'ok'; throw new Error('bad') }
    ;(async ()=>{ try{ await cb.exec(sometimesFails) } catch(e){ console.log('err1') } try{ await cb.exec(sometimesFails) } catch(e){ console.log('err2') } })()
----

==== Worker Pool (Bulkhead)
[source,ts]
----
    // WorkerPool — límite de concurrencia
    class WorkerPool {
      private active = 0; private queue: (()=>void)[] = []
      constructor(private concurrency = 2){}
      run<T>(job: ()=>Promise<T>): Promise<T>{
        return new Promise((resolve,reject)=>{
          const runJob = () => { this.active++; job().then(r=>{ resolve(r); this.finish(); }).catch(err=>{ reject(err); this.finish(); }) }
          if (this.active < this.concurrency) runJob(); else this.queue.push(runJob)
        })
      }
      private finish(){ this.active--; const next = this.queue.shift(); if (next) next() }
    }
    const pool = new WorkerPool(2)
    async function work(i:number){ await new Promise(r=>setTimeout(r,100)); return i }
    Promise.all([1,2,3,4].map(i=>pool.run(()=>work(i)).then(x=>console.log('done',x))))
----

==== Throttle / Debounce
[source,ts]
----
    // Debounce y Throttle para funciones async/sync
    function debounce<T extends (...args:any[])=>any>(fn:T, wait=100){ let t: any; return (...args: any[])=>{ clearTimeout(t); t = setTimeout(()=>fn(...args), wait) } }
    function throttle<T extends (...args:any[])=>any>(fn:T, limit=100){ let last = 0; return (...args:any[])=>{ const now = Date.now(); if (now - last >= limit){ last = now; fn(...args) } } }
    const d = debounce((x:number)=>console.log('deb', x), 50); d(1); d(2); d(3)
    const th = throttle((x:number)=>console.log('thr', x), 50); th(1); th(2); setTimeout(()=>th(3), 60)
----

==== Saga (orquestación simplificada)
[source,ts]
----
    // Saga — orquestación con acciones compensatorias (simplificado)
    type Step = { action: ()=>Promise<any>, compensate?: (res:any)=>Promise<void> }
    async function runSaga(steps: Step[]){ const results: any[] = []
      for (const s of steps){ try { const r = await s.action(); results.push(r) } catch (err) { for (let i = results.length-1; i>=0; i--){ const comp = steps[i].compensate; if (comp) await comp(results[i]) } throw err } }
      return results
    }
    ;(async ()=>{
      const steps: Step[] = [
        { action: async ()=>{ console.log('step1'); return 1 }, compensate: async ()=>console.log('undo1') },
        { action: async ()=>{ console.log('step2'); throw new Error('boom') }, compensate: async ()=>console.log('undo2') }
      ]
      try { await runSaga(steps) } catch(e){ console.log('saga failed') }
    })()
----

==== Idempotency
[source,ts]
----
    // Idempotency — wrapper por clave
    function idempotent<K, T>(fn:(k:K)=>Promise<T>){ const cache = new Map<K, Promise<T>>(); return (k:K)=>{ if (!cache.has(k)) cache.set(k, fn(k)); return cache.get(k)! } }
    const service = async (id:number)=>{ await new Promise(r=>setTimeout(r,50)); return { id } }
    const idemp = idempotent(service)
    Promise.all([idemp(1), idemp(1)].map(p=>p.then(console.log)))
----

