= Curso de Mocha - Temario
:toc:
:toc-title: Contenido
:doctype: book
:icons: font
:source-highlighter: highlight.js
:sectlinks:

---

== Módulo 1: Fundamentos del Testing

=== 1.1 Introducción al Testing

==== ¿Qué es el Testing Automático?

El testing automático es el proceso de escribir código que verifica automáticamente que otro código funciona como se espera. En lugar de probar manualmente cada funcionalidad de una aplicación, los tests automáticos ejecutan verificaciones repetidamente de forma rápida y confiable.

.Sin Testing Automático:
- Pruebas manuales repetitivas y propensas a errores
- Difícil detectar cambios inesperados en el código
- Mayor tiempo de desarrollo y depuración
- Confianza reducida en los cambios

.Con Testing Automático:
- Verificación rápida y consistente
- Detección inmediata de regresiones
- Desarrollo más ágil y confiable
- Documentación viva del código

==== Beneficios del Testing

[cols="1,2"]
====
| Beneficio | Descripción

| *Confianza* | Seguridad de que el código funciona como se espera
| *Regresiones* | Detección inmediata de cambios no deseados
| *Documentación* | Los tests actúan como ejemplos de uso
| *Diseño* | Mejora el diseño del código (más modular y testeable)
| *Velocidad* | Feedback inmediato sin necesidad de pruebas manuales
| *Refactoring* | Libertad para mejorar código sin miedo a romper cosas
| *Mantenibilidad* | Código más limpio y fácil de entender
| *Calidad* | Reducción de bugs en producción
====

==== Tipos de Testing

===== Testing Unitario

Prueba componentes individuales de manera aislada. Verifica que una función o método realice su tarea específica correctamente.

.Características:
- Prueba unidades pequeñas de código (funciones, métodos)
- Aisladas de dependencias externas
- Rápidas de ejecutar
- Muchas y frecuentes

.Ejemplo:
[source,typescript]
----
// Función a probar
function suma(a: number, b: number): number {
  return a + b;
}

// Test unitario
describe('Función suma', () => {
  it('debe sumar dos números correctamente', () => {
    const resultado = suma(2, 3);
    if (resultado !== 5) {
      throw new Error(`Esperado 5, pero obtuvo ${resultado}`);
    }
  });
});
----

===== Testing de Integración

Verifica que múltiples componentes trabajen juntos correctamente. Prueba la interacción entre módulos.

.Características:
- Prueba múltiples componentes juntos
- Verifica comunicación entre módulos
- Más lentás que tests unitarios
- Menos cantidad que tests unitarios

.Ejemplo:
[source,typescript]
----
// Componentes a integrar
class CalculadoraAvanzada {
  constructor(private calculadoraBasica: Calculadora) {}
  
  promedio(numeros: number[]): number {
    const suma = numeros.reduce((a, b) => 
      this.calculadoraBasica.suma(a, b), 0);
    return suma / numeros.length;
  }
}

// Test de integración
describe('CalculadoraAvanzada', () => {
  it('debe calcular promedio usando suma', () => {
    const calc = new CalculadoraAvanzada(new Calculadora());
    const resultado = calc.promedio([2, 4, 6]);
    if (resultado !== 4) {
      throw new Error(`Esperado 4, obtuve ${resultado}`);
    }
  });
});
----

===== Testing End-to-End (E2E)

Prueba la aplicación completa desde la perspectiva del usuario. Simula interacciones reales.

.Características:
- Prueba flujos completos del usuario
- Interactúa con la UI y APIs
- Las más lentas
- Las menos frecuentes

.Ejemplo (Conceptual):
[source,typescript]
----
// Test E2E simulado
describe('Flujo de compra', () => {
  it('usuario puede comprar un producto', async () => {
    // Usuario abre la app
    await navegarA('/productos');
    
    // Busca un producto
    await escribir('[data-test=busqueda]', 'laptop');
    await hacer('click', '[data-test=buscar-btn]');
    
    // Agrega al carrito
    await hacer('click', '[data-test=agregar-carrito]');
    
    // Completa compra
    await navegarA('/carrito');
    await hacer('click', '[data-test=comprar-btn]');
    
    // Verifica confirmación
    const mensaje = await obtenerTexto('[data-test=confirmacion]');
    if (!mensaje.includes('Compra exitosa')) {
      throw new Error('Compra no completada');
    }
  });
});
----

==== Test-Driven Development (TDD)

TDD es una metodología donde escribes los tests ANTES de implementar el código. Sigue un ciclo específico:

.Ciclo TDD (Red-Green-Refactor):
1. *Red* (Rojo): Escribe un test que falla
2. *Green* (Verde): Escribe el código mínimo para pasar el test
3. *Refactor*: Mejora el código manteniendo los tests pasando

.Ventajas de TDD:
- Código más modular y testeable por defecto
- Documentación clara de requisitos
- Menos bugs en producción
- Mayor confianza en cambios

.Ejemplo TDD:
[source,typescript]
----
// PASO 1: RED - Escribir test que falla
describe('Calculadora', () => {
  it('debe calcular el factorial de 5', () => {
    const fab = new Calculadora();
    const resultado = fab.factorial(5);
    if (resultado !== 120) {
      throw new Error(`Esperado 120, obtuve ${resultado}`);
    }
  });
});
// El test FALLA porque factorial() no existe

// PASO 2: GREEN - Código mínimo para pasar
class Calculadora {
  factorial(n: number): number {
    f (n === 0 || n === 1) return 1;
    return n * this.factorial(n - 1);
  }
}
// El test PASA

// PASO 3: REFACTOR - Mejorar manteniendo tests verdes
class Calculadora {
  factorial(n: number): number {
    if (n < 0) {
      throw new Error('Factorial no definido para números negativos');
    }
    f (n === 0 || n === 1) return 1;
    
    let resultado = 1;
    for (let i = 2; i <= n; i++) {
      resultado *= i;
    }
    return resultado;
  }
}
// El test sigue pasando, pero el código es mejor
----

==== Pirámide de Tests

La pirámide de tests muestra la distribución ideal de tests en un proyecto:

[source]
----
          ┌──────────────┐
          │  E2E Tests   │  Pocos, lentos, caros
          │   (10%)      │
          ├──────────────┤
          │ Integration  │  Medianos, velocidad media
          │   Tests      │
          │   (30%)      │
          ├──────────────┤
          │  Unit Tests  │  Muchos, rápidos, baratos
          │   (60%)      │
          └──────────────┘
----

.Regla de la Pirámide:
- *60% Unit Tests*: Pruebas rápidas de componentes individuales
- *30% Integration Tests*: Pruebas de interacción entre módulos
- *10% E2E Tests*: Pruebas de flujos completos del usuario

.Por qué esta estructura:
- Unit tests son baratos y rápidos
- Proporcionan feedback inmediato
- Cubren la mayoría de casos
- E2E son costosos, se usan solo para flujos críticos

---

=== 1.2 Conceptos Clave

==== Casos de Prueba (Test Cases)

Un caso de prueba es una especificación de un comportamiento que tu código debe tener. Cada test verifica una acción específica.

.Estructura de un buen caso de prueba:

[cols="1,3"]
====
| Componente | Descripción

| *Setup/Arrange* | Preparar los datos necesarios
| *Action/Act* | Ejecutar el código a probar
| *Assertion/Assert* | Verificar el resultado esperado
====

.Ejemplo completo (AAA Pattern):
[source,typescript]
----
desc=ribe('Carrito de compras', () => {
  it('debe calcular el total correctamente con impuesto', () => {
    // ARRANGE - Preparar datos
    const carrito = new CarritoCompras(0.16); // 16% impuesto
    const producto1 = { nombre: 'Laptop', precio: 1000 };
    const producto2 = { nombre: 'Mouse', precio: 50 };
    
    // ACT - Ejecutar la acción
    carrito.agregar(producto1);
    carrito.agregar(producto2);
    const total = carrito.calcularTotal();
    
    // ASSERT - Verificar el resultado
    const esperado = (1000 + 50) * 1.16; // 1218
    if (total !== esperado) {
      throw new Error(
        `Esperado ${esperado}, obtuve ${total}`
      );
    }
  });
});
----

==== Assertions / Aserciones

Una aserción es una verificación booleana que debe ser verdadera. Si es falsa, el test falla.

.Tipos comunes de aserciones:

[cols="1,2,2"]
====
| Tipo | Ejemplo | Propósito

| *Igualdad* | `assert.equal(actual, esperado)` | Verificar valores iguales
| *Tipo* | `assert.strictEqual(5, '5')` | Verificar tipo y valor
| *Verdadero* | `assert.ok(booleano)` | Verificar que es truthy
| *Falsedad* | `assert.strictEqual(valor, false)` | Verificar que es falsy
| *Inclusión* | `assert(array.includes(item))` | Verificar si contiene
| *Excepción* | `assert.throws(() => fn())` | Verificar que lanza error
====

.Eje=mplo de aserciones:
[source,typescript]
----
// Usando Node.js assert
import assert from 'assert';

describe('Aserciones', () => {
  it('debe verificar igualdad', () => {
    const resultado = 2 + 2;
    assert.equal(resultado, 4); // ✓ Pasa
  });
  
  it('debe verificar tipo y valor', () => {
    assert.strictEqual(5, 5); // ✓ Pasa
    // assert.strictEqual(5, '5'); // ✗ Fallaría
  });
  
  it('debe verificar que algo es verdadero', () => {
    assert.ok(true); // ✓ Pasa
    assert.ok('texto'); // ✓ Pasa (truthy)
  });
  
  it('debe verificar excepciones', () => {
    assert.throws(
      () => { throw new Error('Boom!'); },
      Error
    ); // ✓ Pasa
  });
  
  it('debe verificar inclusión en array', () => {
    const colores = ['rojo', 'azul', 'verde'];
    assert.ok(colores.includes('azul')); // ✓ Pasa
  });
});
----

==== Fixtures

Las fixtures son datos o estados preparados que usa tu test. Son útiles para evitar repetir setup en cada test.

.Tipos de fixtures:

[cols="1,3"]
====
| Tipo | Uso

| *Fixture estática* | Datos fijos en archivos (JSON, etc.)
| *Fixture dinámica* | Datos generados en setup
| *Factory functions* | Funciones que crean objetos de prueba
| *Fixtures con hooks* | Preparación con before/beforeEach
====

.Ejemplo sin fixtures (Código repetido):
[source,typescript]
----
describe('Usuario', () => {
  it('debe calcular edad correctamente', () => {
    // Setup repetido
    const usuario = {
      nombre: 'Juan',
      apellido: 'Pérez',
      nacimiento: new Date(1990, 0, 1)
    };
    const edad = calcularEdad(usuario);
    assert.equal(edad >= 30, true);
  });
  
  it('debe validar email del usuario', () => {
    // Setup repetido (similar)
    const usuario = {
      nombre: 'Juan',
      apellido: 'Pérez',
      email: 'juan@example.com'
    };
    assert.ok(validarEmail(usuario.email));
  });
});
----

.Ejemplo CON fixtures (DRY - Don't Repeat Yourself):
[source,typescript]
----
describe('Usuario', () => {
  let usuario; // Fixture variable
  
  beforeEach(() => {
    // Setup común antes de cada test
    usuario = {
      nombre: 'Juan',
      apellido: 'Pérez',
      nacimiento: new Date(1990, 0, 1),
      email: 'juan@example.com'
    };
  });
  
  it('debe calcular edad correctamente', () => {
    const edad = calcularEdad(usuario);
    assert.equal(edad >= 30, true);
  });
  
  it('debe validar email del usuario', () => {
    assert.ok(validarEmail(usuario.email));
  });
});
----

.Fixture factory function:
[source,typescript]
----
// Factory para crear usuarios
function crearUsuarioTest(overrides = {}) {
  return {
    nombre: 'Juan',
    apellido: 'Pérez',
    nacimiento: new Date(1990, 0, 1),
    email: 'juan@example.com',
    rol: 'usuario',
    ...overrides // Permite sobrescribir valores
  };
}

describe('Usuario', () => {
  it('debe funcionar con usuario normal', () => {
    const usuario = crearUsuarioTest();
    assert.equal(usuario.rol, 'usuario');
  });
  
  it('debe funcionar con usuario admin', () => {
    const admin = crearUsuarioTest({ rol: 'admin' });
    assert.equal(admin.rol, 'admin');
  });
});
----

==== Mocks y Stubs

Estos son dobles de test que reemplazan dependencias reales.

===== Stubs (Reemplazos)

Un stub es un objeto que reemplaza una dependencia real y devuelve también datos predefinidos.

.Usado para:
- Reemplazar llamadas a APIs externas
- Evitar bases de datos reales
- Controlar valores de retorno
- Simular errores

.Ejemplo:
[source,typescript]
----
// Servicio real que queremos stubear
class ServicioClima {
  obtenerTemperatura(ciudad: string): Promise<number> {
    // Llamada real a API externa
    return fetch(`https://api.clima.com/${ciudad}`)
      .then(r => r.json());
  }
}

// En el test creamos un stub
describe('Aplicación de Clima', () => {
  it('debe mostrar temperatura', async () => {
    // Stub del servicio
    const servicioStub = {
      obtenerTemperatura: async () => 25 // Valor fijo
    };
    
    const app = new AplicacionClima(servicioStub);
    const resultado = await app.mostrarClima('Madrid');
    
    assert.equal(resultado, '25°C');
  });
});
----

===== Mocks (Burlas)

Un mock es similar a un stub, pero además verifica que fue llamado de forma específica.

.Usado para:
- Verificar que se llamó un método
- Verificar con qué argumentos se llamó
- Verificar número de llamadas
- Comportamiento esperado

.Ejemplo:
[source,typescript]
----
// Servicio de log que queremos verificar
class RegistroLog {
  registrar(mensaje: string): void {
    console.log(`[LOG] ${mensaje}`);
  }
}

describe('Mock de Log', () => {
  it('debe registrar evento de login', () => {
    // Mock del servicio
    let logCalls = [];
    const mockLog = {
      registrar: (mensaje: string) => {
        logCalls.push(mensaje);
      }
    };
    
    // Usar el servicio
    const authService = new AuthService(mockLog);
    authService.login('usuario@example.com', 'password');
    
    // Verificar que se llamó correctamente
    assert.equal(logCalls.length, 1);
    assert.ok(logCalls[0].includes('login'));
    assert.ok(logCalls[0].includes('usuario@example.com'));
  });
});
----

==== Code Coverage (Cobertura de Código)

El code coverage mide qué porcentaje de tu código está siendo ejecutado por los tests.

[cols="1,2,1"]
====
| Tipo | Descripción | Meta

| *Statement* | Líneas de código ejecutadas | 80%+
| *Branch* | Caminos condicionales cubiertos | 75%+
| *Function* | Funciones llamadas en tests | 80%+
| *Line* | Líneas específicas ejecutadas | 80%+
====

.Ejemplo - Función sin cobertura completa:
[source,typescript]
----
function validarEdad(edad: number): string {
  if (edad < 18) {
    return 'Menor de edad'; // NO PROBADO
  }
  if (edad > 65) {
    return 'Jubilado'; // NO PROBADO
  }
  return 'Adulto'; // PROBADO
}

// Test que solo prueba un caso
describe('validarEdad', () => {
  it('debe retornar adulto para edad 30', () => {
    assert.equal(validarEdad(30), 'Adulto');
  });
});
// Coverage: 33% (solo 1 de 3 branches)
----

.Ejemplo - Cobertura completa:
[source,typescript]
----
describe('validarEdad', () => {
  it('debe retornar menor para edad < 18', () => {
    assert.equal(validarEdad(10), 'Menor de edad');
  });
  
  it('debe retornar adulto para 18-65', () => {
    assert.equal(validarEdad(30), 'Adulto');
  });
  
  it('debe retornar jubilado para edad > 65', () => {
    assert.equal(validarEdad(70), 'Jubilado');
  });
});
// Coverage: 100% (todos los branches cubiertos)
----

.Meta de cobertura recomendada:
- *Código crítico* (lógica de negocio): 85-100%
- *Código importante* (APIs): 75-85%
- *Código de utilidad*: 60-75%
- *Nunca* busques 100% ciegamente - calidad sobre cantidad

== Módulo 2: Configuración e Instalación

Mocha es un framework de testing flexible que necesita instalación y configuración. Este módulo te guiará por todo el proceso de instalación y configuración inicial.

=== 2.1 Instalación de Mocha

==== ¿Qué es Mocha?

Mocha es un framework de testing moderno y flexible para JavaScript/TypeScript que ejecuta tests de forma secuencial y proporciona reporte detallados de resultados. Es agnóstico respecto a librerías de assertions (puedes usar assert nativo, Chai, etc.).

.Características principales:
- Tests síncronos y asíncrono
- Estructura clara con describe/it
- Reportes detallados
- Suite of tests opcional
- Soporte para múltiples estilos de reporting
- Plugins y extensiones

==== Versiones Requeridas

Antes de instalar Mocha, verifica tus versiones:

[cols="1,2,3"]
====
| Herramienta | Versión Mínima | Recomendada

| Node.js | 14.x | 18.x o superior
| npm | 6.x | 9.x o superior
| yarn | 1.x | 3.x o superior
====

.Verificar tu versión de Node.js:
[source,bash]
----
node= --version
# v18.12.0

npm --version
# 9.2.0
----

Si necesitas actualizar Node.js, descárgalo de https://nodejs.org/

==== Instalación Mediante npm

La instalación local es la más recomendada. Esto asegura que todos en el equipo usen la misma versión.

.Paso 1: Crear un proyecto (si no lo tienes)
[source,bash]
----
mkdir mi-proyecto-tests
cd mi-proyecto-tests
npm init -y
----

El archivo `package.json` sería así:
[source,json]
----
{
  "name": "mi-proyecto-tests",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
----

.Paso 2: Instalar Mocha como dependencia de desarrollo
[source,bash]
----
npm install --save-dev mocha
----

Este comando:
- Descarga Mocha desde npm registry
- Se guarda en `node_modules/`
- Se añade a `devDependencies` en `package.json`

Verificar instalación:
[source,bash]
----
npx mocha --version
# 10.2.0
----

==== Instalación Mediante Yarn

Si prefieres usar Yarn:

[source,bash]
----
yarn add --dev mocha
----

Verificar:
[source,bash]
----
yarn mocha --version
----

==== Instalación Local vs Global

[cols="1,2,2"]
====
| Aspecto | Local (Recomendado) | Global

| Comando | `npx mocha` | `mocha`
| npm install | `npm install --save-dev mocha` | `npm install -g mocha`
| Ubicación | `node_modules/` | `/usr/local/lib/`
| Equipo | Consistente en todo el equipo | Puede variar por PC
| Control | Fácil de actualizar en proyecto | Más difícil de controlar
| Reproducibilidad | Alta (mismo en CI/CD) | Baja (pueden diferir versiones)
====

.Mej=or práctica: Instala siempre localmente
[source,bash]
----
# ✓ Recomendado
npm install --save-dev mocha

# ✗ Evita instalación global para proyectos
npm install -g mocha
----

==== Crear tu Primer Test

.Paso 1: Crear directorio de tests
[source,bash]
----
mkdir test
----

.Paso 2: Crear archivo test
[source,bash]
----
touch test/suma.test.ts
----

.Paso 3: Escribir un test simple
[source,typescript]
----
// test/suma.test.ts
function suma(a: number, b: number): number {
  return a + b;
}

describe('Función suma', () => {
  it('debe sumar 2 + 3 = 5', () => {
    const resultado = suma(2, 3);
    if (resultado !== 5) {
      throw new Error(`Esperado 5, obtuvo ${resultado}`);
    }
  });
});
----

.Paso 4: Actualizar package.json
[source,json]
----
{
  "scripts": {
    "test": "mocha 'test/**/*.test.ts'"
  }
}
----

.Paso 5: Ejecutar test
[source,bash]
----
npm test
----

---

=== 2.2 Configuración Inicial

==== Package.json y Scripts de Test

El archivo `package.json` es el punto central de configuración de tu proyecto Node.js.

.Estructura básica con tests:
[source,json]
----
{
  "name": "mi-proyecto",
  "version": "1.0.0",
  "description": "Proyecto con tests en Mocha",
  "main": "index.js",
  "scripts": {
    "test": "mocha 'test/**/*.test.ts'",
    "test:watch": "mocha 'test/**/*.test.ts' --watch",
    "test:coverage": "nyc mocha 'test/**/*.test.ts'",
    "test:debug": "mocha --inspect-brk 'test/**/*.test.ts'"
  },
  "devDependencies": {
    "mocha": "^10.2.0"
  },
  "keywords": ["testing"],
  "author": "Tu Nombre",
  "license": "MIT"
}
----

.Scripts comunes:

[cols="1,2,2"]
====
| Script | Comando | Propósito

| `test` | `npm test` | Ejecutar tests
| `test:watch` | `npm run test:watch` | Ejecutar en modo observación
| `test:coverage` | `npm run test:coverage` | Generar reporte de cobertura
| `test:debug` | `npm run test:debug` | Debuggear tests
====

.Ejecutar scripts:
[source,bash]
----
npm test                    # Ejecuta tests
npm run test:watch         # Ejecuta y observa cambios
npm run test:coverage      # Genera coverage
npm run test:debug         # Modo debug en puerto 9229
----

==== Archivo mocha.opts / .mocharc.json

Para configuraciones más complejas, puedes crear un archivo de configuración dedicado. Mocha puede leer configuración de varios formatos.

.Opciones disponibles:

[cols="1,3"]
====
| Formato | Archivo

| JSON | `.mocharc.json`
| YAML | `.mocharc.yaml`
| JavaScript | `.mocharc.js`
| Heredado | `test/mocha.opts`
====

.Ejemplo .mocharc.json:
[source,json]
----
{
  "require": "ts-node/register",
  "extensions": ["ts"],
  "spec": "test/**/*.test.ts",
  "timeout": 5000,
  "slow": 300,
  "reporter": "spec",
  "ui": "bdd"
}
----

.Explicación de opciones:
[cols="1,3"]
====
| Opción | Descripción

| `require` | Módulos a cargar antes de ejecutar tests
| `extensions` | Extensiones de archivo a buscar
| `spec` | Patrón de búsqueda de archivos test
| `timeout` | Tiempo máximo por test en ms (5000 = 5s)
| `slow` | Tiempo para marcar test como lento en ms (300ms)
| `reporter` | Formato de reporte (spec, json, tap, etc.)
| `ui` | Estilo de interfaz (bdd, tdd, qunit)
====

.Ejemplo .mocharc.js:
[source,javascript]
----
module.exports = {
  require: 'ts-node/register',
  extensions: ['ts'],
  spec: 'test/**/*.test.ts',
  timeout: 5000,
  slow: 300,
  reporter: 'spec',
  ui: 'bdd',
  // Configuración dinámica
  globals: ['__DEV__'],
  // Ignorar archivos
  ignore: ['**/node_modules/**']
};
----

==== Configuración de Rutas

Para trabajar con TypeScript y módulos, necesitas configurar las rutas correctamente.

.Estructura del proyecto recomendada:
[source]
----
mi-proyecto/
├── src/
│   ├── index.ts
│   ├── utils.ts
│   └── math.ts
├── test/
│   ├── unit/
│   │   ├── math.test.ts
│   │   └── utils.test.ts
│   └── integration/
│       └── index.test.ts
├── .mocharc.json
├── tsconfig.json
└── package.json
----

.Patrón de búsqueda en .mocharc.json:
[source,json]
----
{
  "spec": [
    "test/unit/**/*.test.ts",
    "test/integration/**/*.test.ts"
  ],
  "exclude": [
    "test/fixtures/**"
  ]
}
----

.Ejecutar solo tests unitarios:
[source,bash]
----
mocha 'test/unit/**/*.test.ts'
----

.Ejecutar tests que contienen "math":
[source,bash]
----
mocha --grep "math" 'test/**/*.test.ts'
----

==== Variables de Entorno

Las variables de entorno te permiten cambiar comportamientos según el contexto.

.Usando variables de entorno en tests:
[source,typescript]
----
// test/config.test.ts
describe('Configuración por entorno', () => {
  it('debe usar base URL correcta', () => {
    const base = process.env.API_URL || 'http://localhost:3000';
    console.log(`API URL: ${base}`);
    
    f (process.env.NODE_ENV === 'test') {
      // Lógica específica para tests
    }
  });
});
----

.Archivo .env para desarrollo:
[source,bash]
----
# .env
API_URL=http://localhost:3000
DATABASE_URL=mongodb://localhost:27017
NODE_ENV=development
----

.Instalar dotenv para cargar variables:
[source,bash]
----
npm install --save-dev dotenv
----

.Usar en test setup:
[source,typescript]
----
// test/setup.ts
import dotenv from 'dotenv';

dotenv.config();

console.log(`Ejecutando tests en ${process.env.NODE_ENV}`);
console.log(`Base URL: ${process.env.API_URL}`);
----

.Configurar en .mocharc.json:
[source,json]
----
{
  "require": [
    "dotenv/config",
    "test/setup.ts"
  ],
  "spec": "test/**/*.test.ts"
}
----

.Ejecutar con variables custom:
[source,bash]
----
API_URL=http://staging.api.com npm test
NODE_ENV=test npm run test:coverage
----

---

=== 2.3 Configuración para TypeScript

Mocha puede ejecutar TypeScript nativamente con ts-node, sin necesidad de compilar previamente.

==== Instalación de ts-node

ts-node es un ejecutor de TypeScript que compila sobre la marcha.

[source,bash]
----
npm install --save-dev ts-node typescript
----

Verificar instalación:
[source,bash]
----
npx ts-node --version
----

==== Compilador TypeScript en Mocha

.Opción 1: Usar require en .mocharc.json
[source,json]
----
{
  "require": "ts-node/register",
  "extensions": ["ts"],
  "spec": "test/**/*.test.ts"
}
----

.Opción 2: Usar loader moderno (Node.js 18+)
[source,json]
----
{
  "loader": "ts-node/esm",
  "extensions": ["ts"],
  "spec": "test/**/*.test.ts",
  "node-option": "loader=ts-node/esm"
}
----

.Opción 3: Usar require en consola
[source,bash]
----
npx mocha --require ts-node/register 'test/**/*.test.ts'
----

==== Configuración de tsconfig.json

Tu archivo `tsconfig.json` controla cómo se compila TypeScript.

.Configuración mínima para tests:
[source,json]
----
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src/**/*", "test/**/*"],
  "exclude": ["node_modules", "dist"]
}
----

.Explicación de opciones:
[cols="1,3"]
====
| Opción | Descripción

| `target` | Versión de JavaScript objetivo
| `module` | Sistema de módulos (commonjs para Node.js)
| `strict` | Modo estricto para mayor seguridad
| `sourceMap` | Mapeos para debugging
| `skipLibCheck` | No verificar archivos .d.ts
| `esModuleInterop` | Compatibilidad con módulos ES6
====

===== Sourcemaps para Debugging

Los sourcemaps permiten debuggear el TypeScript original, no el JavaScript compilado.

.Habilitar sourcemaps en tsconfig.json:
[source,json]
----
{
  "compilerOptions": {
    "sourceMap": true,
    "inlineSourceMap": false,
    "inlineSources": false
  }
}
----

.Configurar en .mocharc.json:
[source,json]
----
{
  "require": "ts-node/register",
  "extensions": ["ts"],
  "spec": "test/**/*.test.ts",
  "node-option": [
    "loader=ts-node/esm",
    "enable-source-maps"
  ]
}
----

==== Ejemplo Completo: Proyecto TypeScript + Mocha

.1. Estructura del proyecto:
[source,bash]
----
mkdir proyecto-ts-mocha
cd proyecto-ts-mocha
npm init -y
----

.2. Instalar dependencias:
[source,bash]
----
npm install --save-dev mocha ts-node typescript chai @types/node @types/chai
----

.3. Crear archivos:

[source,bash]
----
# Crear directorios
mkdir -p src test

# Crear archivos
touch src/calculator.ts
touch test/calculator.test.ts
touch tsconfig.json
touch .mocharc.json
----

.4. Implementación (src/calculator.ts):
[source,typescript]
----
export class Calculadora {
  sumar(a: number, b: number): number {
    return a + b;
  }
  
  restar(a: number, b: number): number {
    return a - b;
  }
  
  multiplicar(a: number, b: number): number {
    return a * b;
  }
  
  dividir(a: number, b: number): number {
    f (b === 0) {
      throw new Error('No se puede dividir por cero');
    }
    return a / b;
  }
}
----

.5. Test (test/calculator.test.ts):
[source,typescript]
----
import { expect } from 'chai';
import { Calculadora } from '../src/calculator';

describe('Clase Calculadora', () => {
  let calc: Calculadora;
  
  beforeEach(() => {
    calc = new Calculadora();
  });
  
  describe('método sumar', () => {
    it('debe sumar dos números positivos', () => {
      expect(calc.sumar(2, 3)).to.equal(5);
    });
    
    it('debe sumar números negativos', () => {
      expect(calc.sumar(-2, -3)).to.equal(-5);
    });
  });
  
  describe('método dividir', () => {
    it('debe dividir números correctamente', () => {
      expect(calc.dividir(10, 2)).to.equal(5);
    });
    
    it('debe lanzar error al dividir por cero', () => {
      expect(() => calc.dividir(10, 0))
        .to.throw('No se puede dividir por cero');
    });
  });
});
----

.6. tsconfig.json:
[source,json]
----
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "sourceMap": true,
    "declaration": true
  },
  "include": ["src/**/*", "test/**/*"],
  "exclude": ["node_modules"]
}
----

.7. .mocharc.json:
[source,json]
----
{
  "require": "ts-node/register",
  "extensions": ["ts"],
  "spec": "test/**/*.test.ts",
  "timeout": 5000,
  "slow": 300,
  "reporter": "spec"
}
----

.8. Actualizar package.json:
[source,json]
----
{
  "scripts": {
    "test": "mocha",
    "test:watch": "mocha --watch --watch-extensions ts"
  }
}
----

.9. Ejecutar tests:
[source,bash]
----
npm test

# Salida esperada:
#   Clase Calculadora
#     método sumar
#       ✓ debe sumar dos números positivos
#       ✓ debe sumar números negativos
#     método dividir
#       ✓ debe dividir números correctamente
#       ✓ debe lanzar error al dividir por cero
# 
#   4 passing (5ms)
----

==== Troubleshooting Común

[cols="1,2,3"]
====
| Problema | Causa | Solución

| `Cannot find module 'ts-node'` | ts-node no está instalado | `npm install --save-dev ts-node`
| `Cannot find module 'typescript'` | TypeScript no instalado | `npm install --save-dev typescript`
| `Timeout error` | Test toma más de 5s | Aumentar timeout en .mocharc.json
| `Sourcemap error` | SourceMap no generado | Habilitar `sourceMap: true` en tsconfig.json
| `Module not found` | Ruta incorrecta | Verificar paths en tsconfig.json
====

---

== Módulo 3: Sintaxis y API de Mocha

Este módulo cubre la sintaxis fundamental de Mocha y cómo usar sus APIs para escribir tests efectivos. Mocha proporciona una interfaz simple pero poderosa para organizar y ejecutar tus tests.

=== 3.1 Hooks y Bloques de Prueba

==== describe() - Agrupación de Tests

`describe()` es una función que agrupa tests relacionados en un bloque lógico. Te permite organizarlos jerárquicamente y crear contextos específicos.

.Sintaxis básica:
[source,typescript]
----
describe('Descripción del grupo', () => {
  // Tests aquí
});
----

.Ejemplo simple:
[source,typescript]
----
describe('Función sumar', () => {
  it('debe sumar dos números positivos', () => {
    // Test aquí
  });
  
  it('debe sumar números negativos', () => {
    // Test aquí
  });
});
----

==== it() / test() - Definición de Casos de Prueba

`it()` (alias `test()`) define un caso de prueba individual. Cada `it()` representa una expectativa específica del código.

.Sintaxis:
[source,typescript]
----
it('descripción del comportamiento esperado', () => {
  // Código de prueba
});

// O equivalentemente:
test('descripción del comportamiento esperado', () => {
  // Código de prueba
});
----

.Estructura recomendada (AAA Pattern):
[source,typescript]
----
describe('Clase Usuario', () => {
  it('debe crear un usuario con nombre y email válidos', () => {
    // ARRANGE - Preparar datos
    const datos = { nombre: 'Juan', email: 'juan@example.com' };
    
    // ACT - Ejecutar la acción
    const usuario = new Usuario(datos);
    
    // ASSERT - Verificar resultados
    if (usuario.nombre !== 'Juan') {
      throw new Error('El nombre no se asignó correctamente');
    }
    if (usuario.email !== 'juan@example.com') {
      throw new Error('El email no se asignó correctamente');
    }
  });
});
----

==== Anidamiento de Bloques describe()

Puedes anidar `describe()` para crear una estructura jerárquica que refleje la organización de tu código.

.Estructura anidada:
[source,typescript]
----
describe('Aplicación de Banco', () => {
  describe('Clase Cuenta', () => {
    describe('método depositar', () => {
      it('debe aumentar el balance', () => {
        const cuenta = new Cuenta(1000);
        cuenta.depositar(500);
        if (cuenta.balance !== 1500) {
          throw new Error('Balance incorrecto');
        }
      });
    });
    
    describe('método retirar', () => {
      it('debe disminuir el balance', () => {
        const cuenta = new Cuenta(1000);
        cuenta.retirar(300);
        if (cuenta.balance !== 700) {
          throw new Error('Balance incorrecto');
        }
      });
      
      it('debe lanzar error si el saldo es insuficiente', () => {
        const cuenta = new Cuenta(100);
        try {
          cuenta.retirar(500);
          throw new Error('Debería haber lanzado un error');
        } catch (e) {
          if (!e.message.includes('Saldo insuficiente')) {
            throw e;
          }
        }
      });
    });
  });
});
----

Salida esperada:
[source]
----
Aplicación de Banco
  Clase Cuenta
    método depositar
      ✓ debe aumentar el balance
    método retirar
      ✓ debe disminuir el balance
      ✓ debe lanzar error si el saldo es insuficiente

3 passing
----

==== Callbacks vs Promises vs Async/Await

Mocha soporta tres formas de manejar código asíncrono:

.1. Callbacks con done:
[source,typescript]
----
describe('Callbacks', () => {
  it('debe esperar a que se complete una callback', (done) => {
    setTimeout(() => {
      // Verificar resultado
      if (true) {
        done(); // Indica que el test terminó
      } else {
        done(new Error('Test falló'));
      }
    }, 100);
  });
});
----

.2. Promises:
[source,typescript]
----
describe('Promises', () => {
  it('debe esperar a que se resuelva una promesa', () => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve('Éxito');
      }, 100);
    }).then(resultado => {
      if (resultado !== 'Éxito') {
        throw new Error('Resultado incorrecto');
      }
    });
  });
});
----

.3. Async/Await (Recomendado):
[source,typescript]
----
describe('Async/Await', () => {
  it('debe esperar con async/await', async () => {
    const resultado = await new Promise((resolve) => {
      setTimeout(() => resolve('Éxito'), 100);
    });
    
    if (resultado !== 'Éxito') {
      throw new Error('Resultado incorrecto');
    }
  });
});
----

.Comparación de estilos:

[cols="1,1,3"]
====
| Estilo | Uso | Ventajas

| *Callback* | Código muy viejo | Compatible con cualquier navegador
| *Promise* | Código moderno | Mejor que callbacks
| *Async/Await* | Recomendado | Más legible, más fácil de entender
====

.Ejemplo práctico con API:
[source,typescript]
----
desc=ribe('Llamadas a API', () => {
  it('debe obtener usuario desde API con async/await', async () => {
    // ARRANGE
    const userId = 1;
    
    // ACT
    const response = await fetch(`https://api.example.com/users/${userId}`);
    const usuario = await response.json();
    
    // ASSERT
    if (!usuario.id) {
      throw new Error('Usuario no tiene ID');
    }
    if (usuario.id !== userId) {
      throw new Error('ID no coincide');
    }
  });
});
----

---

=== 3.2 Hooks del Ciclo de Vida

Los hooks son funciones especiales que se ejecutan en momentos específicos del ciclo de vida de los tests. Son útiles para setup y teardown.

==== before() - Antes de Todos los Tests

`before()` ejecuta una sola vez antes de que se ejecuten todos los tests en un bloque `describe()`.

.Caso de uso: Configuración global
[source,typescript]
----
describe('Base de Datos', () => {
  let baseDatos;
  
  before(async () => {
    // Se ejecuta UNA SOLA VEZ, antes de todos los tests
    console.log('Conectando a base de datos...');
    baseDatos = new BaseDatos();
    await baseDatos.conectar('mongodb://localhost:27017');
  });
  
  it('debe insertar un documento', async () => {
    const resultado = await baseDatos.insertar({ nombre: 'Juan' });
    if (!resultado.id) {
      throw new Error('No se creó el documento');
    }
  });
  
  it('debe obtener un documento', async () => {
    const usuario = await baseDatos.obtenerPor({ nombre: 'Juan' });
    if (!usuario) {
      throw new Error('Usuario no encontrado');
    }
  });
});

// Salida:
// Conectando a base de datos...
// ✓ debe insertar un documento
// ✓ debe obtener un documento
----

==== after() - Después de Todos los Tests

`after()` ejecuta una sola vez después de que terminen todos los tests en un bloque `describe()`.

.Caso de uso: Limpieza global
[source,typescript]
----
describe('Base de Datos', () => {
  let baseDatos;
  
  before(async () => {
    baseDatos = new BaseDatos();
    await baseDatos.conectar('mongodb://localhost:27017');
  });
  
  it('debe insertar documento', async () => {
    // Test...
  });
  
  after(async () => {
    // Se ejecuta UNA SOLA VEZ, después de todos los tests
    console.log('Cerrando conexión a base de datos...');
    await baseDatos.desconectar();
  });
});

// Salida:
// ✓ debe insertar documento
// Cerrando conexión a base de datos...
----

==== beforeEach() - Antes de Cada Test

`beforeEach()` ejecuta antes de cada test individual en un bloque `describe()`.

.Caso de uso: Setup/Reset de estado
[source,typescript]
----
describe('Carrito de Compras', () => {
  let carrito;
  
  beforeEach(() => {
    // Se ejecuta ANTES DE CADA TEST
    console.log('Creando carrito vacío...');
    carrito = new Carrito();
  });
  
  it('debe estar vacío al iniciarse', () => {
    if (carrito.items.length !== 0) {
      throw new Error('Carrito no vacío');
    }
  });
  
  it('debe agregar productos', () => {
    carrito.agregar({ nombre: 'Laptop', precio: 1000 });
    if (carrito.items.length !== 1) {
      throw new Error('Producto no agregado');
    }
  });
  
  it('debe calcular total correctamente', () => {
    carrito.agregar({ nombre: 'Mouse', precio: 50 });
    carrito.agregar({ nombre: 'Teclado', precio: 100 });
    const total = carrito.calcularTotal();
    if (total !== 150) {
      throw new Error('Total incorrecto');
    }
  });
});

// Salida:
// Creando carrito vacío...
// ✓ debe estar vacío al iniciarse
// Creando carrito vacío...
// ✓ debe agregar productos
// Creando carrito vacío...
// ✓ debe calcular total correctamente
----

==== afterEach() - Después de Cada Test

`afterEach()` ejecuta después de cada test individual.

.Caso de uso: Limpieza de estado
[source,typescript]
----
describe('Sistema de Archivos', () => {
  let sistema;
  
  beforeEach(() => {
    sistema = new SistemaArchivos();
  });
  
  afterEach(async () => {
    // Se ejecuta DESPUÉS DE CADA TEST
    console.log('Limpiando archivos de test...');
    await sistema.limpiar();
  });
  
  it('debe crear archivo', () => {
    sistema.crearArchivo('test.txt', 'contenido');
    if (!sistema.existeArchivo('test.txt')) {
      throw new Error('Archivo no creado');
    }
  });
  
  it('debe escribir contenido', () => {
    sistema.crearArchivo('data.json', '{"id": 1}');
    const contenido = sistema.leerArchivo('data.json');
    if (contenido !== '{"id": 1}') {
      throw new Error('Contenido incorrecto');
    }
  });
});

// Salida:
// ✓ debe crear archivo
// Limpiando archivos de test...
// ✓ debe escribir contenido
// Limpiando archivos de test...
----

==== Timeout en Hooks

Los hooks tienen un timeout por defecto de 2000ms. Puedes personalizarlo:

.Aumentar timeout de un hook:
[source,typescript]
----
describe('Operaciones Lentas', () => {
  before(function(done) {
    this.timeout(5000); // Esperar 5 segundos
    
    // Operación que toma tiempo
    setTimeout(() => {
      done();
    }, 4500);
  });
  
  it('debe completar operación', () => {
    // Test...
  });
});
----

.Deshabilitar timeout en un hook:
[source,typescript]
----
before(function(done) {
  this.timeout(0); // Sin timeout
  
  // Operación de duración indefinida
  largaOperacion().then(() => done());
});
----

.Tabla de timeouts:

[cols="1,2,3"]
====
| Contexto | Timeout por defecto | Se puede cambiar

| Test | 2000ms | Sí
| Hook | 2000ms | Sí
| Async hook | 2000ms | Sí
====

==== Orden de Ejecución

Es importante entender el orden exacto:
=
[source]
----
describe('Suite de Tests', () => {
  before(() => console.log('1. before - una sola vez'));
  
  beforeEach(() => console.log('2. beforeEach'));
  
  it('primer test', () => console.log('3. test 1'));
  
  beforeEach(() => console.log('2. beforeEach'));
  
  it('segundo test', () => console.log('3. test 2'));
  
  afterEach(() => console.log('4. afterEach'));
  
  after(() => console.log('5. after - una sola vez'));
});

// Salida:
// 1. before - una sola vez
// 2. beforeEach
// 3. test 1
// 4. afterEach
// 2. beforeEach
// 3. test 2
// 4. afterEach
// 5. after - una sola vez
----

---

=== 3.3 Control de Ejecución

==== skip() - Saltar Tests

Usa `skip()` para omitir un test sin eliminarlo.

.Syntax:
[source,typescript]
----
describe.skip('Suite completa omitida', () => {
  // Ninguno de estos tests se ejecuta
  it('no se ejecuta', () => {});
});

it.skip('test individual omitido', () => {
  // Este test no se ejecuta
});
----

.Caso de uso: Tests pending (Por implementar)
[source,typescript]
----
describe('Funcionalidad en Desarrollo', () => {
  it.skip('debe soportar búsqueda avanzada', () => {
    // Aún no implementado
  });
  
  it.skip('debe exportar a PDF', () => {
    // Aún no implementado
  });
  
  it('debe listar usuarios', () => {
    const usuarios = usuariosService.listar();
    if (!Array.isArray(usuarios)) {
      throw new Error('No es array');
    }
  });
});

// Salida:
// ✓ debe listar usuarios
// - debe soportar búsqueda avanzada (pendiente)
// - debe exportar a PDF (pendiente)
----

.Saltar condicionalmente:
[source,typescript]
----
describe('Integración con Stripe', () => {
  const tieneStripeKey = !!process.env.STRIPE_API_KEY;
  
  it(tieneStripeKey ? 'debe procesar pago' : 'SKIP: debe procesar pago', 
    () => {
      // Test solo se ejecuta si STRIPE_API_KEY está configurada
      const pago = procesarPago({ monto: 100 });
      if (!pago.id) {
        throw new Error('Pago no procesado');
      }
    }
  );
});
----

==== only() - Ejecutar Solo Tests Específicos

Usa `only()` para ejecutar solo un test o suite específica. Útil durante debugging.

.Syntax:
[source,typescript]
----
describe.only('Solo esta suite se ejecuta', () => {
  it('se ejecuta', () => {
    // Este test se ejecuta
  });
});

describe('Esta suite NO se ejecuta', () => {
  it('no se ejecuta', () => {
    // Este test se omite
  });
});
----

.Debugging con only:
[source,typescript]
----
describe('Servicio de Usuarios', () => {
  it('debe crear usuario', () => {
    // ...
  });
  
  it.only('debe validar email (debugging)', () => {
    // Solo este test se ejecuta
    const isValid = validarEmail('usuario@example.com');
    if (!isValid) {
      throw new Error('Email no válido');
    }
  });
  
  it('debe hash contraseña', () => {
    // Este test se omite
  });
});

// Salida:
// ✓ debe validar email (debugging)
// 2 skipped (solo se ejecutó 1)
----

⚠️ *Advertencia:* Recuerda remover `.only()` antes de hacer commit, para evitar que otros tests no se ejecuten en CI/CD.

==== this.retries() - Reintentos

Reintentar un test un número específico de veces si falla.

.Syntax:
[source,typescript]
----
it('debe reconectar y reintentarlo', function() {
  this.retries(3); // Reintentar hasta 3 veces
  
  // Si falla, Mocha lo intenta de nuevo
  const conexion = establecerConexion();
  if (!conexion) {
    throw new Error('Conexión fallida');
  }
});
----

.Caso de uso: Tests de red flaky
[source,typescript]
----
describe('Integración con API Externa', () => {
  it('debe obtener datos con reintentos', function() {
    this.retries(2); // Intentar hasta 3 veces (1 + 2 reintentos)
    
    const datos = fetch('https://api-inestable.com/datos')
      .then(r => r.json());
    
    if (!datos.id) {
      throw new Error('Datos incompletos');
    }
  });
});

// Si falla el primer intento, lo reintenta
// Salida posible:
// ✓ debe obtener datos con reintentos (intento 3)
----

.Timeout con reintentos:
[source,typescript]
----
it('descarga archivo grande', function() {
  this.timeout(10000); // 10 segundos por intento
  this.retries(2);     // Reintentar si toma más de 10s
  
  // Descargar archivo...
});
----

==== this.timeout() - Personalizar Timeout

Cambiar el timeout de un test específico:

.Timeout aumentado:
[source,typescript]
----
it('debe procesar gran volumen de datos', function() {
  this.timeout(30000); // 30 segundos
  
  const resultado = procesarGranVolumen([...mucho_datos]);
  if (!resultado) {
    throw new Error('Procesamiento falló');
  }
});
----

.Deshabilitar timeout:
[source,typescript]
----
it('operación de duración indefinida', function() {
  this.timeout(0); // Sin límite de tiempo
  
  while (true) {
    // Operación que podría ser infinita
  }
});
----

.Timeout muy corto:
[source,typescript]
----
it('debe responder rápidamente', function() {
  this.timeout(100); // Solo 100ms
  
  const inicio = Date.now();
  const resultado = operacionRapida();
  const duracion = Date.now() - inicio;
  
  if (duracion > 50) {
    throw new Error('Operación muy lenta');
  }
});
----

==== Combinando Opciones

Puedes combinar varias opciones:

[source,typescript]
----
describe('Sincronización de Datos', () => {
  it('debe sincronizar en paralelo', function() {
    this.timeout(15000);    // Timeout más largi
    this.retries(2);        // Reintentar si falla
    this.slow(5000);        // Marcar como lento si > 5s
    
    return Promise.all([
      sincronizar('usuarios'),
      sincronizar('productos'),
      sincronizar('pedidos')
    ]);
  });
});
----

==== Tabla de Control de Ejecución

[cols="1,2,3,2"]
====
| Función | Propósito | Scope | Resultado

| `it.skip()` | Omitir test | Test individual | Marcado como pendiente
| `describe.skip()` | Omitir suite | Suite completa | Todos omitidos
| `it.only()` | Ejecutar solo este | Test individual | Solo este se ejecuta
| `describe.only()` | Ejecutar solo suite | Suite | Solo esta se ejecuta
| `this.retries(n)` | Reintentar n veces | Test individual | Se reintenta si falla
| `this.timeout(ms)` | Establecer timeout | Test/Hook | Error si excede tiempo
====

===== Ejemplo Completo: Control de Ejecución

[source,typescript]
----
describe('Gestión de Usuarios', () => {
  
  it('debe crear usuario', function() {
    this.timeout(5000);
    const usuario = new Usuario({ nombre: 'Ana', email: 'ana@test.com' });
    if (!usuario.id) throw new Error('No tiene ID');
  });
  
  it.skip('debe enviar email de bienvenida', () => {
    // Por implementar
  });
  
  it('debe buscar usuario por email', function() {
    this.retries(2);
    const usuario = buscarPor({ email: 'juan@test.com' });
    if (!usuario) throw new Error('Usuario no encontrado');
  });
  
  describe('Validaciones', () => {
    it('debe validar email', () => {
      if (!validarEmail('invalido')) {
        throw new Error('Debería rechazar email inválido');
      }
    });
    
    it.only('debe validar contraseña fuerte', () => {
      const esValida = validarPassword('Abc123!@#');
      if (!esValida) throw new Error('Contraseña no validada');
    });
    
    it('debe hashear contraseña', () => {
      // Este no se ejecuta porque hay .only()
    });
  });
});

// Salida esperada:
// Gestión de Usuarios
//   ✓ debe crear usuario
//   - debe enviar email de bienvenida (pendiente)
//   ✓ debe buscar usuario por email
//   Validaciones
//     ✓ debe validar contraseña fuerte
//     1 skipped (solo se ejecutó 1 de 2 tests en Validaciones)
----

---

== Módulo 4: Assertions y Librerías de Assert

Las aserciones sont el corazón de cualquier test. Son verificaciones que confirman que el código se comporta como se espera. Este módulo explora cómo usar aserciones nativas de Node.js y la poderosa librería Chai.

=== 4.1 Métodos de Assert Nativos

Node.js proporciona el módulo `assert` nativo que no requiere instalación. Es simple pero efectivo.

==== Introducción a Assert

El módulo `assert` de Node.js proporciona afirmaciones para testing. Es la forma más básica y no requiere dependencias adicionales.

.Instalar assert (incluido en Node.js):
[source,typescript]
----
// Ya viene con Node.js, solo importar
import assert from 'assert';
----

==== assert.equal() - Igualdad Flexible

Verifica que dos valores sean iguales usando `==` (coerción de tipos).

.Sintaxis:
[source,typescript]
----
assert.equal(actual, esperado, [mensaje]);
----

.Ejemplo:
[source,typescript]
----
import assert from 'assert';

describe('assert.equal()', () => {
  it('debe verificar igualdad con coerción', () => {
    assert.equal(5, 5);              // ✓ Pasa
    assert.equal('5', 5);            // ✓ Pasa (coerción: 5 == '5')
    assert.equal(true, 1);           // ✓ Pasa (coerción: true == 1)
  });
  
  it('debe fallar con valores diferentes', () => {
    try {
      assert.equal(5, 6);
    } catch (err) {
      console.log(err.message); // '5 == 6'
    }
  });
  
  it('debe permitir mensaje personalizado', () => {
    try {
      assert.equal(resultado, esperado, 'El resultado no coincide');
    } catch (err) {
      console.log(err.message); // 'El resultado no coincide'
    }
  });
});
----

==== assert.strictEqual() - Igualdad Estricta

erifica que dos valores sean iguales usando `===` (sin coerción).

.Sintaxis:
[source,typescript]
----
assert.strictEqual(actual, esperado, [mensaje]);
----

.Ejemplo:
[source,typescript]
----
import assert from 'assert';

describe('assert.strictEqual()', () => {
  it('debe verificar igualdad estricta (tipo y valor)', () => {
    assert.strictEqual(5, 5);         // ✓ Pasa
  });
  
  it('debe fallar si tipos diferentes', () => {
    try {
      assert.strictEqual(5, '5');     // ✗ Falla (5 !== '5')
    } catch (err) {
      / Error: 5 === '5'
    }
  });
  
  it('ejemplo práctico: validar tipos', () => {
    const usuario = { id: 1, nombre: 'Juan' };
    
    assert.strictEqual(typeof usuario.id, 'number');
    assert.strictEqual(typeof usuario.nombre, 'string');
  });
});
----

==== assert.ok() - Verificación Booleana

Verifica que un valor sea truthy (verdadero en contexto booleano).

.Sintaxis:
[source,typescript]
----
assert.ok(valor, [mensaje]);
----

.Ejemplo:
[source,typescript]
----
import assert from 'assert';

describe('assert.ok()', () => {
  it('debe verificar valores truthy', () => {
    assert.ok(true);                 // ✓ Pasa
    assert.ok('texto');              // ✓ Pasa (string no vacío es truthy)
    assert.ok([1, 2, 3]);            // ✓ Pasa (array es truthy)
    assert.ok({ id: 1 });            // ✓ Pasa (objeto es truthy)
  });
  
  it('debe fallar con valores falsy', () => {
    try {
      assert.ok(false);              // ✗ Falla
      assert.ok('');                 // ✗ Falla (string vacío)
      assert.ok(null);               // ✗ Falla
      assert.ok(undefined);          // ✗ Falla
    } catch (err) {
      // Error
    }
  });
  
  it('ejemplo práctico: validación', () => {
    const usuario = { nombre: 'Ana' };
    
    assert.ok(usuario.nombre);       // Verifica que nombre existe y no es falsy
    assert.ok(usuario.nombre.length > 0);
  });
});
----

==== assert.throws() - Verificación de Excepciones

Verifica que una función lance una excepción.

.Sintaxis:
[source,typescript]
----
assert.throws(funcion, [tipo_error], [mensaje]);
----

.Ejemplo:
[source,typescript]
----
import assert from 'assert';

function dividir(a: number, b: number): number {
  f (b === 0) {
    throw new Error('No se puede dividir por cero');
  }
  return a / b;
}

describe('assert.throws()', () => {
  it('debe verificar que se lanza una excepción', () => {
    assert.throws(() => dividir(10, 0));
  });
  
  it('debe verificar el tipo de error', () => {
    assert.throws(
      () => dividir(10, 0),
      Error                          // Verificar que es Error
    );
  });
  
  it('debe verificar el mensaje de error', () => {
    assert.throws(
      () => dividir(10, 0),
      /No se puede dividir por cero/  // Regex del mensaje
    );
  });
  
  it('debe fallar si no se lanza excepción', () => {
    try {
      assert.throws(() => dividir(10, 2));  // ✗ No lanza error
    } catch (err) {
      console.log('Test falló: no se lanzó excepción');
    }
  });
  
  it('ejemplo práctico: validación de entrada', () => {
    function crearUsuario(email: string) {
      if (!email.includes('@')) {
        throw new Error('Email inválido');
      }
      return { email };
    }
    
    assert.throws(
      () => crearUsuario('usuariosinvalido'),
      /Email inválido/
    );
  });
});
----

==== assert.rejects() - Verificación de Promises Rechazadas

Verifica que una promesa se rechace (funciona con async/await).

.Sintaxis:
[source,typescript]
----
await assert.rejects(promesa, [tipo_error], [mensaje]);
----

.Ejemplo:
[source,typescript]
----
import assert from 'assert';

async function obtenerUsuario(id: number) {
  if (id <= 0) {
    throw new Error('ID debe ser positivo');
  }
  return { id, nombre: 'Juan' };
}

describe('assert.rejects()', () => {
  it('debe verificar rechazo de promesa', async () => {
    await assert.rejects(async () => {
      await obtenerUsuario(-1);
    });
  });
  
  it('debe verificar tipo de error', async () => {
    await assert.rejects(
      async () => await obtenerUsuario(0),
      Error
    );
  });
  
  it('debe verificar mensaje de error', async () => {
    await assert.rejects(
      async () => await obtenerUsuario(-5),
      /ID debe ser positivo/
    );
  });
  
  it('debe permitir acceso al error', async () => {
    try {
      await assert.rejects(
        async () => await obtenerUsuario(-1)
      );
    } catch (err) {
      assert.ok(err.message.includes('ID debe ser positivo'));
    }
  });
});
----

==== Tabla de Assert Nativos

[cols="1,2,3,2"]
====
| Función | Propósito | Ejemplo | Usa

| `assert.equal()` | Igualdad flexible | `assert.equal(5, '5')` | == (coerción)
 `assert.strictEqual()` | Igualdad estricta | `assert.strictEqual(5, 5)` | === (sin coerción)
| `assert.notEqual()` | Desigualdad flexible | `assert.notEqual(5, 6)` | !=
| `assert.notStrictEqual()` | Desigualdad estricta | `assert.notStrictEqual(5, '5')` | !==
| `assert.ok()` | Verificar truthy | `assert.ok(true)` | Booleano
| `assert.throws()` | Error síncrono | `assert.throws(() => fn())` | Excepciones
| `a=ssert.rejects()` | Error asíncrono | `await assert.rejects(promise)` | Promises
| `assert.deepEqual()` | Objetos iguales | `assert.deepEqual({a:1}, {a:1})` | Profundo
====

---

=== 4.2 Chai - Librería de Assertions

Chai es una librería de assertions muy popular que proporciona una sintaxis más legible y poderosa que assert nativo. Soporta múltiples estilos.

==== Instalación de Chai

[source,bash]
----
npm install --save-dev chai
----

Para TypeScript:
[source,bash]
----
npm install --save-dev chai @types/chai
----

==== Estilos de Chai: BDD vs TDD

Chai soporta dos estilos: BDD (expect/should) y TDD (assert).

[cols="1,2,3"]
====
| Estilo | Sintaxis | Popularidad

| *BDD* | `expect()` o `should` | Muy popular, legible
| *TDD* | `assert` | Tradicional, menos común
====

==== BDD Style: expect()

El estilo `expect()` es el más popular. Usa una sintaxis chainable y legible.

.Ins=talación y importación:
[source,typescript]
----
import { expect } from 'chai';
----

.Sintaxis básica:
[source,typescript]
----
expect(valor).to.equal(esperado);
expect(valor).to.not.equal(esperado);
expect(valor).to.be.true;
expect(valor).to.be.false;
----

.Ejemplos de aserciones básicas:
[source,typescript]
----
import { expect } from 'chai';

describe('Chai - BDD Style expect()', () => {
  it('debe verificar igualdad', () => {
    expect(5).to.equal(5);
    expect('texto').to.equal('texto');
    expect(true).to.be.true;
  });
  
  it('debe verificar desigualdad', () => {
    expect(5).to.not.equal(6);
    expect(false).to.be.false;
  });
  
  it('debe verificar tipos', () => {
    expect(5).to.be.a('number');
    expect('hola').to.be.a('string');
    expect([1, 2]).to.be.an('array');
    expect({}).to.be.an('object');
  });
  
  it('debe verificar inclusión', () => {
    expect([1, 2, 3]).to.include(2);
    expect('hello').to.include('ell');
    expect({ a: 1, b: 2 }).to.include.key('a');
  });
  
  it('debe verificar longitud', () => {
    expect([1, 2, 3]).to.have.lengthOf(3);
    expect('hello').to.have.lengthOf(5);
  });
  
  it('debe verificar excepciones', () => {
    expect(() => {
      throw new Error('¡Boom!');
    }).to.throw();
    
    expect(() => {
      throw new Error('¡Boom!');
    }).to.throw('¡Boom!');
  });
});
----

==== Assertions Chainable (Fluent)

Una de las ventajas de Chai es la sintaxis chainable que hace los tests muy legibles.

.Ejemplo:
[source,typescript]
----
import { expect } from 'chai';

describe('Assertions Chainable', () => {
  it('debe permitir chaining', () => {
    const usuario = {
      nombre: 'Juan',
      email: 'juan@example.com',
      edad: 30,
      roles: ['admin', 'usuario']
    };
    
    expect(usuario)
      .to.be.an('object')
      .that.includes.all.keys('nombre', 'email', 'edad')
      .and.include.key('roles');
    
    expect(usuario.nombre)
      .to.be.a('string')
      .that.is.not.empty
      .and.includes('Juan');
    
    expect(usuario.roles)
      .to.be.an('array')
      .that.is.not.empty
      .and.includes('admin');
  });
});
----

==== BDD Style: should

El estilo `should` añade propiedades a los objetos. Es menos común que `expect()`.

.Sintaxis:
[source,typescript]
----
import 'chai/register-should';

const valor = 5;
valor.should.equal(5);
valor.should.not.equal(6);
valor.should.be.a('number');
----

.Ejemplo:
[source,typescript]
----
import 'chai/register-should';

describe('Chai - BDD Style should', () => {
  it('debe usar should', () => {
    const resultado = 2 + 3;
    
    resultado.should.equal(5);
    resultado.should.be.a('number');
    resultado.should.be.above(4);
    resultado.should.be.below(6);
  });
  
  it('debe funcionar con arrays', () => {
    const items = [1, 2, 3];
    
    items.should.be.an('array');
    items.should.have.lengthOf(3);
    items.should.include(2);
  });
});
----

==== TDD Style: assert

Chai también proporciona un estilo `assert` tradicional, similar a Node.js assert pero más potente.

.Sintaxis:
[source,typescript]
----
import { assert } from 'chai';

assert.equal(valor, esperado);
assert.strictEqual(valor, esperado);
assert.typeOf(valor, 'string');
----

.Ejemplo:
[source,typescript]
----
import { assert } from 'chai';

describe('Chai - TDD Style assert', () => {
  it('debe usar assert', () => {
    const resultado = 2 + 3;
    
    assert.equal(resultado, 5);
    assert.strictEqual(resultado, 5);
    assert.typeOf(resultado, 'number');
    assert.isAbove(resultado, 4);
    assert.isBelow(resultado, 6);
  });
  
  it('debe funcionar con arrays', () => {
    const items = [1, 2, 3];
    
    assert.isArray(items);
    assert.lengthOf(items, 3);
    assert.include(items, 2);
  });
});
----

==== Comparencia Chai vs Assert Nativo

[cols="1,2,2"]
====
| Característica | Assert Nativo | Chai

| *Mensajes de error* | Básicos | Muy descriptivos
| *Chainable* | No | Sí
| *Múltiples estilos* | No | Sí (expect, should, assert)
| *Funciones avanzadas* | Limitadas | Muchas
| *Tamaño* | 1KB | ~20KB
| *Curva de aprendizaje* | Baja | Media
====

===== Principales Aserciones de Chai

[cols="1,2"]
====
| Aserción | Ejemplo

| *Igualdad* | `expect(5).to.equal(5)` / `expect(5).to.eql(5)`
| *Identidad* | `expect(obj).to.equal(obj)`
| *Tipo* | `expect(5).to.be.a('number')`
| *Verdadero/Falso* | `expect(true).to.be.true` / `.to.be.false`
| *Null/Undefined* | `expect(val).to.be.null` / `.to.be.undefined`
| *Numérico* | `expect(5).to.be.above(4)` / `.to.be.below(6)`
| *Inclusión* | `expect([1,2]).to.include(1)` / `.to.include.key('a')`
| *Longitud* | `expect('hello').to.have.lengthOf(5)`
| *E=xcepciones* | `expect(() => fn()).to.throw(Error)`
| *Propiedades* | `expect({a:1}).to.have.property('a')`
| *Existencia* | `expect(val).to.exist`
====

---

=== 4.3 Assertions Avanzadas

==== Validación de Excepciones Detallada

Chai permite validar detalles específicos de excepciones.

.Ejemplo completo:
[source,typescript]
----
import { expect } from 'chai';

function validarContraseña(password: string) {
  if (!password) {
    throw new Error('Contraseña requerida');
  }
  if (password.length < 8) {
    throw new Error('Contraseña muy corta (mínimo 8 caracteres)');
  }
  if (!/[A-Z]/.test(password)) {
    throw new Error('Debe contener mayúsculas');
  }
  if (!/[0-9]/.test(password)) {
    throw new Error('Debe contener números');
  }
  return true;
}

describe('Validación de Excepciones Detallada', () => {
  it('debe lanzar error si está vacía', () => {
    expect(() => validarContraseña(''))
      .to.throw('Contraseña requerida');
  });
  
  it('debe lanzar error si es muy corta', () => {
    expect(() => validarContraseña('Abc123'))
      .to.throw(/mínimo 8 caracteres/);
  });
  
  it('debe lanzar error si falta mayúscula', () => {
    expect(() => validarContraseña('abc12345'))
      .to.throw()
      .and.to.have.property('message')
      .that.includes('mayúsculas');
  });
  
  it('debe permitir contraseña válida', () => {
    expect(() => validarContraseña('Validar123'))
      .to.not.throw();
  });
});
----

==== Validación de Promises Rechazadas

Chai funciona perfectamente con promises y async/await.

.Ejemplo:
[source,typescript]
----
import { expect } from 'chai';

async function obtenerProducto(id: number) {
  if (id <= 0) {
    throw new Error('ID debe ser positivo');
  }
  return { id, nombre: 'Laptop', precio: 1000 };
}

describe('Validación de Promises Rechazadas', () => {
  it('debe rechazar si ID es inválido', async () => {
    try {
      await obtenerProducto(-1);
      throw new Error('Debería haber rechazado');
    } catch (err) {
      expect(err.message).to.include('positivo');
    }
  });
  
  it('alternativa: usar expect con throw', async () => {
    let error;
    try {
      await obtenerProducto(0);
    } catch (err) {
      error = err;
    }
    
    expect(error).to.exist;
    expect(error.message).to.equal('ID debe ser positivo');
  });
  
  it('debe retornar producto válido', async () => {
    const producto = await obtenerProducto(1);
    
    expect(producto)
      .to.be.an('object')
      .that.includes.all.keys('id', 'nombre', 'precio');
    
    expect(producto.id).to.equal(1);
    expect(producto.nombre).to.be.a('string');
    expect(producto.precio).to.be.above(0);
  });
});
----

==== Validación de Tipos Complejos

Validar estructuras de datos complejas.

.Ejemplo:
[source,typescript]
----
import { expect } from 'chai';

interface Usuario {
  id: number;
  nombre: string;
  email: string;
  roles: string[];
  activo: boolean;
}

describe('Validación de Tipos Complejos', () => {
  it('debe validar estructura de usuario', () => {
    const usuario: Usuario = {
      id: 1,
      nombre: 'Juan',
      email: 'juan@example.com',
      roles: ['admin', 'usuario'],
      activo: true
    };
    
    // Validar estructura
    expect(usuario).to.be.an('object');
    expect(usuario).to.have.all.keys('id', 'nombre', 'email', 'roles', 'activo');
    
    // Validar tipos de propiedades
    expect(usuario.id).to.be.a('number');
    expect(usuario.nombre).to.be.a('string');
    expect(usuario.email).to.be.a('string');
    expect(usuario.roles).to.be.an('array');
    expect(usuario.activo).to.be.a('boolean');
    
    // Validar valores
    expect(usuario.id).to.equal(1);
    expect(usuario.nombre).to.not.be.empty;
    expect(usuario.email).to.include('@');
    expect(usuario.roles).to.include('admin');
    expect(usuario.activo).to.be.true;
  });
  
  it('debe validar arrays de objetos', () => {
    const usuarios: Usuario[] = [
      { id: 1, nombre: 'Juan', email: 'juan@example.com', roles: ['admin'], activo: true },
      { id: 2, nombre: 'Ana', email: 'ana@example.com', roles: ['usuario'], activo: true }
    ];
    
    expect(usuarios).to.be.an('array').with.lengthOf(2);
    
    usuarios.forEach((usuario, index) => {
      expect(usuario).to.have.all.keys('id', 'nombre', 'email', 'roles', 'activo');
      expect(usuario.id).to.be.a('number').and.be.greaterThan(0);
      expect(usuario.nombre).to.be.a('string').and.not.be.empty;
    });
  });
});
----

==== Mensajes de Error Personalizados

Los mensajes personalizados ayudan a entender qué falló.

.Ejemplo con Chai:
[source,typescript]
----
import { expect } from 'chai';

describe('Mensajes de Error Personalizados', () => {
  it('debe mostrar mensaje descriptivo', () => {
    const usuarioActual = 'Juan';
    const usuarioEsperado = 'Ana';
    
    expect(usuarioActual, `El usuario debería ser ${usuarioEsperado}`)
      .to.equal(usuarioEsperado);
  });
  
  it('mensaje en validación compleja', () => {
    const usuario = null;
    
    expect(usuario, 'El usuario no debe ser null después de crear')
      .to.exist;
  });
  
  it('mensaje con contexto de negocio', () => {
    const precioFinal = 150;
    const precioMaximo = 100;
    
    expect(precioFinal, `El precio final ($${precioFinal}) no debe exceder el máximo ($${precioMaximo})`)
      .to.be.below(precioMaximo);
  });
});
----

==== Comparación: Assert vs Chai

[source,typescript]
----
import assert from 'assert';
import { expect } from 'chai';

describe('Comparación: assert vs chai', () => {
  const usuario = { id: 1, nombre: 'Juan' };
  
  it('verificar propiedad con assert nativo', () => {
    // Assert nativo
    assert.strictEqual(usuario.nombre, 'Juan');
    // Mensaje de error poco descriptivo:
    / AssertionError: 'Juan' === 'Ana'
  });
  
  it('verificar propiedad con chai', () => {
    // Chai
    expect(usuario.nombre, 'El nombre debe ser Juan')
      .to.equal('Juan');
    // Mensaje de error muy descriptivo
  });
  
  it('validar arrays con assert', () => {
    const items = [1, 2, 3];
    assert.ok(items.includes(2));
    // Error poco claro si falla
  });
  
  it('validar arrays con chai', () => {
    const items = [1, 2, 3];
    expect(items).to.include(2);
    // Error muy descriptivo
  });
  
  it('comparar objetos con assert', () => {
    const obj1 = { a: 1, b: 2 };
    const obj2 = { a: 1, b: 2 };
    assert.deepEqual(obj1, obj2);
  });
  
  it('comparar objetos con chai', () => {
    const obj1 = { a: 1, b: 2 };
    const obj2 = { a: 1, b: 2 };
    expect(obj1).to.deep.equal(obj2);
    // Más legible
  });
});
----

==== Tabla Resumen de Aserciones Avanzadas

[cols="1,2,2"]
====
| Característica | Assert Nativo | Chai

| *Validar excepción* | `assert.throws()` | `expect(() => fn()).to.throw()`
| *Validar promise rechazada* | `assert.rejects()` | Usar try/catch + expect
| *Mensaje personalizado* | Segundo parámetro | Segundo parámetro en expect
| *Validar estructura* | `assert.deepEqual()` | `expect(obj).to.deep.equal()`
| *Validar inclusión* | `assert.ok(arr.includes())` | `expect(arr).to.include()`
 *Validar tipo* | `assert.ok(typeof x === 'number')` | `expect(x).to.be.a('number')`
| *Legibilidad* | Media | Alta
====

==== Ejemplo Práctico Completo

[source,typescript]
----
import { expect } from 'chai';

interface Carrito {
  id: string;
  items: Array<{ id: number; nombre: string; precio: number; cantidad: number }>;
  calcularTotal(): number;
  agregarItem(item: any): void;
  eliminarItem(itemId: number): void;
}

class CarritoCompras implements Carrito {
  id = 'carrito-1';
  items: any[] = [];
  
  calcularTotal(): number {
    return this.items.reduce((total, item) => 
      total + (item.precio * item.cantidad), 0
    );
  }
  
  agregarItem(item: any): void {
    onst existe = this.items.find(i => i.id === item.id);
    if (existe) {
      existe.cantidad += item.cantidad;
    } else {
      this.items.push(item);
    }
  }
  
  eliminarItem(itemId: number): void {
    this.items = this.items.filter(i => i.id !== itemId);
  }
}

describe('Carrito de Compras - Assertions Avanzadas', () => {
  let carrito: Carrito;
  
  beforeEach(() => {
    carrito = new CarritoCompras();
  });
  
  it('debe inicializarse vacío', () => {
    expect(carrito.items)
      .to.be.an('array')
      .that.is.empty;
    
    expect(carrito.calcularTotal())
      .to.equal(0);
  });
  
  it('debe agregar item y calcular total', () => {
    const laptop = { id: 1, nombre: 'Laptop', precio: 1000, cantidad: 1 };
    
    carrito.agregarItem(laptop);
    
    expect(carrito.items)
      .to.have.lengthOf(1)
      .and.to.include(laptop);
    
    expect(carrito.calcularTotal())
      .to.equal(1000);
  });
  
  it('debe agregar múltiples items', () => {
    carrito.agregarItem({ id: 1, nombre: 'Laptop', precio: 1000, cantidad: 1 });
    carrito.agregarItem({ id: 2, nombre: 'Mouse', precio: 50, cantidad: 2 });
    
    expect(carrito.items)
      .to.have.lengthOf(2);
    
    expect(carrito.calcularTotal())
      .to.equal(1100); // (1000 * 1) + (50 * 2)
  });
  
  it('debe aumentar cantidad si item ya existe', () => {
    carrito.agregarItem({ id: 1, nombre: 'Laptop', precio: 1000, cantidad: 1 });
    carrito.agregarItem({ id: 1, nombre: 'Laptop', precio: 1000, cantidad: 1 });
    
    expect(carrito.items)
      .to.have.lengthOf(1);
    
    expect(carrito.items[0].cantidad)
      .to.equal(2);
    
    expect(carrito.calcularTotal())
      .to.equal(2000);
  });
  
  it('debe eliminar item del carrito', () => {
    carrito.agregarItem({ id: 1, nombre: 'Laptop', precio: 1000, cantidad: 1 });
    carrito.agregarItem({ id: 2, nombre: 'Mouse', precio: 50, cantidad: 1 });
    
    carrito.eliminarItem(1);
    
    expect(carrito.items)
      .to.have.lengthOf(1)
      .and.to.satisfy(
        items: any[]) => !items.some(i => i.id === 1),
        'No debe contener el item con id 1'
      );
    
    expect(carrito.calcularTotal())
      .to.equal(50);
  });
});
----

---

== Módulo 5: Testing de Funciones y Módulos

Este módulo cubre cómo escribir tests para funciones individuales, módulos completos, clases y objetos. Es el corazón del testing unitario.

=== 5.1 Tests Básicos Unitarios

==== Testing de Funciones Puras

Una función pura es aquella que siempre retorna el mismo resultado para los mismos parámetros, sin efectos secundarios.

.Características de funciones puras:
- No modifican estado externo
- No tienen dependencias externas
- Para los mismos inputs, siempre el mismo output
- Fáciles de testear

.Ejemplo de función pura:
[source,typescript]
----
// Función pura - fácil de testear
function sumar(a: number, b: number): number {
  return a + b;
}

function calcularDescuento(precio: number, porcentaje: number): number {
  const descuento = precio * (porcentaje / 100);
  return precio - descuento;
}

function validarEmail(email: string): boolean {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}
----

.Tests para funciones puras:
[source,typescript]
----
import { expect } from 'chai';

describe('Funciones Puras', () => {
  describe('sumar', () => {
    it('debe sumar dos números positivos', () => {
      expect(sumar(2, 3)).to.equal(5);
    });
    
    it('debe sumar números negativos', () => {
      expect(sumar(-5, 3)).to.equal(-2);
    });
    
    it('debe sumar ceros', () => {
      expect(sumar(0, 0)).to.equal(0);
    });
    
    it('debe ser conmutativa', () => {
      expect(sumar(5, 3)).to.equal(sumar(3, 5));
    });
  });
  
  describe('calcularDescuento', () => {
    it('debe calcular descuento del 10%', () => {
      expect(calcularDescuento(100, 10)).to.equal(90);
    });
    
    it('debe calcular descuento del 50%', () => {
      expect(calcularDescuento(200, 50)).to.equal(100);
    });
    
    it('debe retornar el mismo precio sin descuento', () => {
      expect(calcularDescuento(100, 0)).to.equal(100);
    });
  });
  
  describe('validarEmail', () => {
    it('debe aceptar emails válidos', () => {
      expect(validarEmail('usuario@example.com')).to.be.true;
      expect(validarEmail('juan.perez@empresa.co.uk')).to.be.true;
    });
    
    it('debe rechazar emails sin @', () => {
      expect(validarEmail('usuarioexample.com')).to.be.false;
    });
    
    it('debe rechazar emails sin dominio', () => {
      expect(validarEmail('usuario@')).to.be.false;
    });
  });
});
----

==== Testing con Parámetros Variables

Los tests deben verificar diferentes tipos de parámetros y casos borde.

[cols="1,2"]
====
| Tipo de Parámetro | Casos a Testear

| *Números* | Positivos, negativos, cero, decimales, NaN, Infinity
| *Strings* | Vacío, con espacios, especiales, muy largo
| *Arrays* | Vacío, un elemento, múltiples, con duplicados
| *Objetos* | Vacío, incompleto, extra keys, null
| *Booleanos* | true, false
| *null/undefined* | Ambos casos
====

.Eje=mplo: Testing exhaustivo
[source,typescript]
----
import { expect } from 'chai';

function dividir(a: number, b: number): number {
  f (b === 0) {
    throw new Error('No se puede dividir por cero');
  }
  return a / b;
}

function procesarArray(arr: any[]): number {
  if (!Array.isArray(arr)) {
    throw new Error('Param debe ser un array');
  }
  return arr.length;
}

describe('Testing con Parámetros Variables', () => {
  describe('dividir - números', () => {
    it('debe dividir enteros positivos', () => {
      expect(dividir(10, 2)).to.equal(5);
    });
    
    it('debe dividir decimales', () => {
      expect(dividir(7.5, 2.5)).to.equal(3);
    });
    
    it('debe manejar números negativos', () => {
      expect(dividir(-10, 2)).to.equal(-5);
      expect(dividir(10, -2)).to.equal(-5);
      expect(dividir(-10, -2)).to.equal(5);
    });
    
    it('debe lanzar error en división por cero', () => {
      expect(() => dividir(10, 0)).to.throw('No se puede dividir por cero');
    });
  });
  
  describe('procesarArray - arrays', () => {
    it('debe retornar longitud de array vacío', () => {
      expect(procesarArray([])).to.equal(0);
    });
    
    it('debe retornar longitud de array con elementos', () => {
      expect(procesarArray([1, 2, 3])).to.equal(3);
    });
    
    it('debe rechazar no-arrays', () => {
      expect(() => procesarArray(null as any)).to.throw();
      expect(() => procesarArray('string' as any)).to.throw();
      expect(() => procesarArray({} as any)).to.throw();
    });
  });
});
----

==== Testing de Valores de Retorno

Verifica que el valor retornado sea exacto y del tipo correcto.

.Ejemplo:
[source,typescript]
----
import { expect } from 'chai';

function obtenerUsuario(id: number): { id: number; nombre: string; activo: boolean } | null {
  f (id === 1) {
    return { id: 1, nombre: 'Juan', activo: true };
  }
  return null;
}

function procesarBatch(items: any[]): { exitosos: number; fallidos: number } {
  return {
    xitosos: items.filter(i => i.status === 'success').length,
    allidos: items.filter(i => i.status === 'error').length
  };
}

describe('Testing de Valores de Retorno', () => {
  it('debe retornar usuario con estructura correcta', () => {
    const usuario = obtenerUsuario(1);
    
    expect(usuario).to.not.be.null;
    expect(usuario).to.be.an('object');
    expect(usuario).to.have.all.keys('id', 'nombre', 'activo');
    expect(usuario?.id).to.be.a('number');
    expect(usuario?.nombre).to.be.a('string');
    expect(usuario?.activo).to.be.a('boolean');
  });
  
  it('debe retornar null para usuario no encontrado', () => {
    const usuario = obtenerUsuario(999);
    
    expect(usuario).to.be.null;
  });
  
  it('debe procesar batch correctamente', () => {
    const items = [
      { status: 'success' },
      { status: 'success' },
      { status: 'error' }
    ];
    
    const resultado = procesarBatch(items);
    
    expect(resultado).to.deep.equal({ exitosos: 2, fallidos: 1 });
    expect(resultado.exitosos).to.equal(2);
    expect(resultado.fallidos).to.equal(1);
    expect(resultado.exitosos + resultado.fallidos).to.equal(items.length);
  });
});
----

==== Testing de Tipos en TypeScript

TypeScript ayuda a validar tipos, pero la verificación en runtime también es importante.

.Ejemplo:
[source,typescript]
----
import { expect } from 'chai';

interface Producto {
  id: number;
  nombre: string;
  precio: number;
  stock: number;
}

function crearProducto(datos: any): Producto {
  if (!datos.id || !datos.nombre || !datos.precio) {
    throw new Error('Datos incompletos');
  }
  return {
    id: datos.id,
    nombre: datos.nombre,
    precio: datos.precio,
    stock: datos.stock || 0
  };
}

function generarSKU(producto: Producto): string {
  return `${producto.id}-${producto.nombre.toUpperCase().substring(0, 3)}`;
}

describe('Testing de Tipos en TypeScript', () => {
  it('debe crear producto con tipos correctos', () => {
    const producto = crearProducto({
      id: 1,
      nombre: 'Laptop',
      precio: 1000
    });
    
    expect(producto).to.be.instanceOf(Object);
    expect(producto.id).to.be.a('number');
    expect(producto.nombre).to.be.a('string');
    expect(producto.precio).to.be.a('number');
    expect(producto.stock).to.be.a('number');
  });
  
  it('debe lanzar error con datos incompletos', () => {
    expect(() => crearProducto({ nombre: 'Laptop' }))
      .to.throw('Datos incompletos');
  });
  
  it('debe generar SKU correctamente', () => {
    const producto: Producto = {
      id: 1,
      nombre: 'Laptop',
      precio: 1000,
      stock: 5
    };
    
    const sku = generarSKU(producto);
    
    expect(sku).to.be.a('string');
    expect(sku).to.include('1');
    expect(sku).to.include('LAP');
    expect(sku).to.equal('1-LAP');
  });
});
----

---

=== 5.2 Testing de Módulos

==== Testing de Exportaciones

Valida que un módulo exporte las funciones y variables correctas.

.Ejemplo: módulo math.ts
[source,typescript]
----
// src/math.ts
export function sumar(a: number, b: number): number {
  return a + b;
}

export function restar(a: number, b: number): number {
  return a - b;
}

export const PI = 3.14159;

export interface MathResult {
  resultado: number;
  timestamp: Date;
}

export function calcularAreaCirculo(radio: number): number {
  return PI * radio * radio;
}
----

.Test de exportaciones:
[source,typescript]
----
import { expect } from 'chai';
import * as math from '../src/math';

describe('Testing de Exportaciones', () => {
  it('debe exportar función sumar', () => {
    expect(math.sumar).to.be.a('function');
    expect(math.sumar(2, 3)).to.equal(5);
  });
  
  it('debe exportar función restar', () => {
    expect(math.restar).to.be.a('function');
    expect(math.restar(5, 2)).to.equal(3);
  });
  
  it('debe exportar constante PI', () => {
    expect(math.PI).to.be.a('number');
    expect(math.PI).to.equal(3.14159);
  });
  
  it('debe exportar interfaz MathResult', () => {
    const resultado: math.MathResult = {
      resultado: 5,
      timestamp: new Date()
    };
    expect(resultado).to.have.all.keys('resultado', 'timestamp');
  });
  
  it('debe usar PI en calcularAreaCirculo', () => {
    const area = math.calcularAreaCirculo(2);
    const esperado = math.PI * 2 * 2;
    expect(area).to.equal(esperado);
  });
});
----

==== Inyección de Dependencias

Facilita el testing al permitir pasar dependencias como parámetros.

.Ejemplo sin inyección (difícil de testear):
[source,typescript]
----
// Difícil de testear - depende de BaseDatos real
class RepositorioUsuarios {
  private db = new BaseDatos(); // Creado internamente
  
  obtener(id: number) {
    return this.db.query(`SELECT * FROM usuarios WHERE id = ${id}`);
  }
}
----

.Ejemplo con inyección (fácil de testear):
[source,typescript]
----
import { expect } from 'chai';

// Interfaz para abstracción
interface BaseDatos {
  query(sql: string): any;
}

// Clase que recibe la dependencia
class RepositorioUsuarios {
  constructor(private db: BaseDatos) {}
  
  obtener(id: number) {
    return this.db.query(`SELECT * FROM usuarios WHERE id = ${id}`);
  }
}

describe('Inyección de Dependencias', () => {
  it('debe obtener usuario usando BD de test', () => {
    // Mock/Stub de la BD
    const dbMock: BaseDatos = {
      query: (sql: string) => ({
        id: 1,
        nombre: 'Juan',
        email: 'juan@example.com'
      })
    };
    
    const repo = new RepositorioUsuarios(dbMock);
    const usuario = repo.obtener(1);
    
    expect(usuario).to.exist;
    expect(usuario.nombre).to.equal('Juan');
  });
  
  it('debe manejar usuario no encontrado', () => {
    const dbMock: BaseDatos = {
      query: () => null
    };
    
    const repo = new RepositorioUsuarios(dbMock);
    const usuario = repo.obtener(999);
    
    expect(usuario).to.be.null;
  });
});
----

==== Mocking de Módulos

A veces necesitas reemplazar un módulo completo por un mock.

.Ejemplo: módulo externo (email-service.ts)
[source,typescript]
----
// src/email-service.ts
export function enviarEmail(destinatario: string, asunto: string, cuerpo: string) {
  // Llama a API external...
  return { enviado: true, id: 'email-123' };
}

// src/notificador.ts
import * as emailService from './email-service';

export class Notificador {
  notifcar(usuario: { email: string; nombre: string }, mensaje: string) {
    const respuesta = emailService.enviarEmail(
      usuario.email,
      'Notificación',
      mensaje
    );
    return respuesta;
  }
}
----

.Test con módulo mockeado:
[source,typescript]
----
import { expect } from 'chai';
import * as emailService from '../src/email-service';
import { Notificador } from '../src/notificador';

describe('Mocking de Módulos', () => {
  it('debe notificar sin llamar servicio real', () => {
    // Reemplazar el módulo
    const emailMock = {
      enviarEmail: (dest: string, asunto: string, cuerpo: string) => {
        return { enviado: true, id: 'mock-123' };
      }
    };
    
    // Usar el mock
    const notificador = new Notificador();
    // En TypeScript real, usarías herramientas como sinon o jest
    
    const resultado = emailMock.enviarEmail(
      'usuario@example.com',
      'Notificación',
      'Contenido del email'
    );
    
    expect(resultado).to.exist;
    expect(resultado.enviado).to.be.true;
    expect(resultado.id).to.equal('mock-123');
  });
});
----

---

=== 5.3 Testing de Objetos y Clases

==== Testing de Métodos de Clase

Las clases tienen múltiples métodos que deben testearse individualmente.

.Ejemplo: Clase Carrito
[source,typescript]
----
export class Carrito {
  private items: Array<{ id: number; nombre: string; precio: number; cantidad: number }> = [];
  private impuesto: number = 0.16; // 16%
  
  agregarItem(id: number, nombre: string, precio: number, cantidad: number = 1): void {
    onst existe = this.items.find(i => i.id === id);
    
    if (existe) {
      existe.cantidad += cantidad;
    } else {
      this.items.push({ id, nombre, precio, cantidad });
    }
  }
  
  eliminarItem(id: number): void {
    this.items = this.items.filter(i => i.id !== id);
  }
  
  obtenerTotal(): number {
    const subtotal = this.items.reduce((sum, item) => 
      sum + (item.precio * item.cantidad), 0
    );
    return subtotal * (1 + this.impuesto);
  }
  
  obtenerSubtotal(): number {
    return this.items.reduce((sum, item) => 
      sum + (item.precio * item.cantidad), 0
    );
  }
  
  obtenerImpuesto(): number {
    return this.obtenerSubtotal() * this.impuesto;
  }
  
  limpiar(): void {
    this.items = [];
  }
  
  obtenerItems() {
    return [...this.items]; // Retorna copia
  }
}
----

.Tests para los métodos:
[source,typescript]
----
import { expect } from 'chai';
import { Carrito } from '../src/carrito';

describe('Clase Carrito - Métodos', () => {
  let carrito: Carrito;
  
  beforeEach(() => {
    carrito = new Carrito();
  });
  
  describe('agregarItem', () => {
    it('debe agregar un item al carrito', () => {
      carrito.agregarItem(1, 'Laptop', 1000);
      
      const items = carrito.obtenerItems();
      expect(items).to.have.lengthOf(1);
      expect(items[0].id).to.equal(1);
      expect(items[0].nombre).to.equal('Laptop');
      expect(items[0].cantidad).to.equal(1);
    });
    
    it('debe aumentar cantidad si item existe', () => {
      carrito.agregarItem(1, 'Laptop', 1000, 1);
      carrito.agregarItem(1, 'Laptop', 1000, 2);
      
      const items = carrito.obtenerItems();
      expect(items).to.have.lengthOf(1);
      expect(items[0].cantidad).to.equal(3);
    });
  });
  
  describe('eliminarItem', () => {
    it('debe eliminar item del carrito', () => {
      carrito.agregarItem(1, 'Laptop', 1000);
      carrito.agregarItem(2, 'Mouse', 50);
      
      carrito.eliminarItem(1);
      
      const items = carrito.obtenerItems();
      expect(items).to.have.lengthOf(1);
      expect(items[0].id).to.equal(2);
    });
  });
  
  describe('obtenerTotal', () => {
    it('debe calcular total con impuesto', () => {
      carrito.agregarItem(1, 'Laptop', 1000, 1);
      carrito.agregarItem(2, 'Mouse', 50, 2);
      
      const subtotal = 1000 + 100; // 1100
      const total = subtotal * 1.16; // 1276
      
      expect(carrito.obtenerTotal()).to.equal(total);
    });
  });
  
  describe('limpiar', () => {
    it('debe vaciar el carrito', () => {
      carrito.agregarItem(1, 'Laptop', 1000);
      carrito.limpiar();
      
      expect(carrito.obtenerItems()).to.be.empty;
    });
  });
});
----

==== Testing de Constructores

Valida que el constructor inicialice correctamente el objeto.

.Ejemplo:
[source,typescript]
----
export class Usuario {
  id: number;
  nombre: string;
  email: string;
  roles: string[];
  activo: boolean;
  fechaCreacion: Date;
  
  constructor(datos: {
    id: number;
    nombre: string;
    email: string;
    roles?: string[];
  }) {
    if (!datos.id || !datos.nombre || !datos.email) {
      throw new Error('Datos requeridos incompletos');
    }
    
    this.id = datos.id;
    this.nombre = datos.nombre;
    this.email = datos.email;
    this.roles = datos.roles || ['usuario'];
    this.activo = true;
    this.fechaCreacion = new Date();
  }
}
----

.Tests del constructor:
[source,typescript]
----
import { expect } from 'chai';
import { Usuario } from '../src/usuario';

describe('Usuario - Constructor', () => {
  it('debe crear usuario con datos válidos', () => {
    const usuario = new Usuario({
      id: 1,
      nombre: 'Juan',
      email: 'juan@example.com'
    });
    
    expect(usuario.id).to.equal(1);
    expect(usuario.nombre).to.equal('Juan');
    expect(usuario.email).to.equal('juan@example.com');
    expect(usuario.activo).to.be.true;
  });
  
  it('debe asignar rol por defecto', () => {
    const usuario = new Usuario({
      id: 1,
      nombre: 'Juan',
      email: 'juan@example.com'
    });
    
    expect(usuario.roles).to.deep.equal(['usuario']);
  });
  
  it('debe asignar roles personalizados', () => {
    const usuario = new Usuario({
      id: 1,
      nombre: 'Juan',
      email: 'juan@example.com',
      roles: ['admin', 'moderador']
    });
    
    expect(usuario.roles).to.deep.equal(['admin', 'moderador']);
  });
  
  it('debe crear fechaCreacion automáticamente', () => {
    const antes = new Date();
    const usuario = new Usuario({
      id: 1,
      nombre: 'Juan',
      email: 'juan@example.com'
    });
    const despues = new Date();
    
    expect(usuario.fechaCreacion.getTime())
      .to.be.greaterThanOrEqual(antes.getTime())
      .and.lessThanOrEqual(despues.getTime());
  });
  
  it('debe lanzar error si faltan datos requeridos', () => {
    expect(() => new Usuario({
      id: 0,
      nombre: '',
      email: 'juan@example.com'
    })).to.throw('Datos requeridos incompletos');
  });
});
----

==== Testing de Herencia

Valida que las clases hijas hereden correctamente de la clase padre.

.Ejemplo con herencia:
[source,typescript]
----
// Clase base
export class Persona {
  nombre: string;
  edad: number;
  
  constructor(nombre: string, edad: number) {
    this.nombre = nombre;
    this.edad = edad;
  }
  
  esMayorDeEdad(): boolean {
    return this.edad >= 18;
  }
}

// Clase hija
export class Empleado extends Persona {
  salario: number;
  departamento: string;
  
  constructor(nombre: string, edad: number, salario: number, departamento: string) {
    super(nombre, edad);
    this.salario = salario;
    this.departamento = departamento;
  }
  
  obtenerBono(): number {
    return this.salario * 0.1; // 10% de bono
  }
}
----

.Tests de herencia:
[source,typescript]
----
import { expect } from 'chai';
import { Persona } from '../src/persona';
import { Empleado } from '../src/empleado';

describe('Herencia - Persona y Empleado', () => {
  describe('Persona', () => {
    it('debe crear persona con datos válidos', () => {
      const persona = new Persona('Juan', 30);
      
      expect(persona.nombre).to.equal('Juan');
      expect(persona.edad).to.equal(30);
    });
    
    it('debe determinar si es mayor de edad', () => {
      const adulto = new Persona('Ana', 25);
      const menor = new Persona('Carlos', 15);
      
      expect(adulto.esMayorDeEdad()).to.be.true;
      expect(menor.esMayorDeEdad()).to.be.false;
    });
  });
  
  describe('Empleado - Herencia', () => {
    it('debe heredar propiedades de Persona', () => {
      const empleado = new Empleado('Juan', 30, 3000, 'IT');
      
      expect(empleado.nombre).to.equal('Juan');
      expect(empleado.edad).to.equal(30);
      expect(empleado).to.be.instanceOf(Persona);
    });
    
    it('debe tener propiedades propias de Empleado', () => {
      const empleado = new Empleado('Juan', 30, 3000, 'IT');
      
      expect(empleado.salario).to.equal(3000);
      expect(empleado.departamento).to.equal('IT');
    });
    
    it('debe heredar métodos de Persona', () => {
      const empleado = new Empleado('Juan', 30, 3000, 'IT');
      
      expect(empleado.esMayorDeEdad()).to.be.true;
    });
    
    it('debe tener sus propios métodos', () => {
      const empleado = new Empleado('Juan', 30, 3000, 'IT');
      
      expect(empleado.obtenerBono()).to.equal(300); // 3000 * 0.1
    });
  });
});
----

==== Testing de Propiedades

Valida que los getters, setters y propiedades funcionen correctamente.

.Ejemplo:
[source,typescript]
----
export class Cuenta {
  private saldo: number = 0;
  private movimientos: Array<{ tipo: 'deposito' | 'retiro'; monto: number; fecha: Date }> = [];
  
  constructor(saldoInicial: number = 0) {
    this.saldo = saldoInicial;
  }
  
  get obtenerSaldo(): number {
    return this.saldo;
  }
  
  depositar(monto: number): void {
    if (monto <= 0) {
      throw new Error('El monto debe ser positivo');
    }
    this.saldo += monto;
    this.movimientos.push({ tipo: 'deposito', monto, fecha: new Date() });
  }
  
  retirar(monto: number): void {
    if (monto > this.saldo) {
      throw new Error('Saldo insuficiente');
    }
    this.saldo -= monto;
    this.movimientos.push({ tipo: 'retiro', monto, fecha: new Date() });
  }
  
  obtenerMovimientos() {
    return [...this.movimientos];
  }
}
----

.Tests de propiedades:
[source,typescript]
----
import { expect } from 'chai';
import { Cuenta } from '../src/cuenta';

describe('Cuenta - Propiedades', () => {
  it('debe inicializar con saldo inicial', () => {
    const cuenta = new Cuenta(1000);
    
    expect(cuenta.obtenerSaldo).to.equal(1000);
  });
  
  it('debe inicializar sin saldo inicial', () => {
    const cuenta = new Cuenta();
    
    expect(cuenta.obtenerSaldo).to.equal(0);
  });
  
  describe('Getter obtenerSaldo', () => {
    it('debe retornar saldo actual', () => {
      const cuenta = new Cuenta(500);
      
      expect(cuenta.obtenerSaldo).to.equal(500);
    });
  });
  
  describe('método depositar', () => {
    it('debe aumentar el saldo', () => {
      const cuenta = new Cuenta(1000);
      cuenta.depositar(500);
      
      expect(cuenta.obtenerSaldo).to.equal(1500);
    });
    
    it('debe registrar movimiento', () => {
      const cuenta = new Cuenta();
      cuenta.depositar(200);
      
      const movimientos = cuenta.obtenerMovimientos();
      expect(movimientos).to.have.lengthOf(1);
      expect(movimientos[0].tipo).to.equal('deposito');
      expect(movimientos[0].monto).to.equal(200);
    });
    
    it('debe lanzar error con monto negativo', () => {
      const cuenta = new Cuenta();
      
      expect(() => cuenta.depositar(-100)).to.throw('El monto debe ser positivo');
    });
  });
  
  describe('método retirar', () => {
    it('debe disminuir el saldo', () => {
      const cuenta = new Cuenta(1000);
      cuenta.retirar(300);
      
      expect(cuenta.obtenerSaldo).to.equal(700);
    });
    
    it('debe lanzar error si saldo insuficiente', () => {
      const cuenta = new Cuenta(100);
      
      expect(() => cuenta.retirar(200)).to.throw('Saldo insuficiente');
    });
  });
});
----

==== Ejemplo Completo Integrado

[source,typescript]
----
// src/producto.ts
export class Producto {
  private id: number;
  private nombre: string;
  private precio: number;
  private stock: number;
  
  constructor(id: number, nombre: string, precio: number, stock: number = 0) {
    if (precio < 0 || stock < 0) {
      throw new Error('Precio y stock no pueden ser negativos');
    }
    this.id = id;
    this.nombre = nombre;
    this.precio = precio;
    this.stock = stock;
  }
  
  obtener() {
    return { id: this.id, nombre: this.nombre, precio: this.precio, stock: this.stock };
  }
  
  incrementarStock(cantidad: number): void {
    if (cantidad <= 0) throw new Error('Cantidad debe ser positiva');
    this.stock += cantidad;
  }
  
  decrementarStock(cantidad: number): void {
    if (cantidad > this.stock) throw new Error('Stock insuficiente');
    this.stock -= cantidad;
  }
  
  hayStock(cantidad: number = 1): boolean {
    return this.stock >= cantidad;
  }
  
  aplicarDescuento(porcentaje: number): number {
    if (porcentaje < 0 || porcentaje > 100) {
      throw new Error('Descuento debe estar entre 0 y 100');
    }
    return this.precio * (1 - porcentaje / 100);
  }
}
----

.Tests completos del Producto:
[source,typescript]
----
import { expect } from 'chai';
import { Producto } from '../src/producto';

describe('Producto - Tests Completos', () => {
  describe('Constructor', () => {
    it('debe crear producto con datos válidos', () => {
      const prod = new Producto(1, 'Laptop', 1000, 5);
      
      expect(prod.obtener()).to.deep.equal({
        id: 1,
        nombre: 'Laptop',
        precio: 1000,
        stock: 5
      });
    });
    
    it('debe validar precios negativos', () => {
      expect(() => new Producto(1, 'Laptop', -100, 5))
        .to.throw('Precio y stock no pueden ser negativos');
    });
  });
  
  describe('Manejo de Stock', () => {
    let producto: Producto;
    
    beforeEach(() => {
      producto = new Producto(1, 'Mouse', 50, 10);
    });
    
    it('debe incrementar stock', () => {
      producto.incrementarStock(5);
      
      expect(producto.obtener().stock).to.equal(15);
    });
    
    it('debe decrementar stock', () => {
      producto.decrementarStock(3);
      
      expect(producto.obtener().stock).to.equal(7);
    });
    
    it('debe verificar disponibilidad', () => {
      expect(producto.hayStock(5)).to.be.true;
      expect(producto.hayStock(15)).to.be.false;
    });
  });
  
  describe('Descuentos', () => {
    let producto: Producto;
    
    beforeEach(() => {
      producto = new Producto(1, 'Teclado', 100, 5);
    });
    
    it('debe aplicar descuento del 10%', () => {
      const precioConDescuento = producto.aplicarDescuento(10);
      
      expect(precioConDescuento).to.equal(90);
    });
    
    it('debe rechazar descuentos inválidos', () => {
      expect(() => producto.aplicarDescuento(-10))
        .to.throw('Descuento debe estar entre 0 y 100');
      
      expect(() => producto.aplicarDescuento(150))
        .to.throw('Descuento debe estar entre 0 y 100');
    });
  });
});
----

---

== Módulo 6: Mocks, Stubs y Spies

Los Mocks, Stubs y Spies son técnicas fundamentales para testear código que depende de otras funciones o servicios. Este módulo explora Sinon.js, la librería más popular para estas tareas.

=== 6.1 Sinon.js - Librería de Mocking

==== ¿Qué es Sinon.js?

Sinon.js es una librería que proporciona herramientas para crear y gestionar test doubles (dobles de prueba): spies, stubs y mocks.

.Instalación:
[source,bash]
----
npm install --save-dev sinon
npm install --save-dev @types/sinon  # Para TypeScript
----

==== Diferencia: Spies, Stubs y Mocks

[cols="1,2,3,2"]
====
| Herramienta | Propósito | Usa | Verifica

| *Spy* | Observar | Función original | Cómo se llamó
| *Stub* | Reemplazar | Implementación fake | Cómo se llamó + Control
| *Mock* | Afirmar | Implementación fake | Llamadas + Comportamiento
====

.Cuándo usar cada uno:
- **Spy**: Quieres ver cómo se utiliza una función sin cambiar su comportamiento
- **Stub**: Necesitas reemplazar una función con una versión controlada
- **=Mock**: Necesitas verificar que una función fue llamada de forma específica

---

=== 6.2 Spies (Espías)

Los spies rastrean llamadas a funciones sin modificar su comportamiento.

==== sinon.spy() - Crear un Spy

[source,typescript]
----
import sinon from 'sinon';
import { expect } from 'chai';

// Función a espiar
function enviarEmail(destinatario: string, asunto: string): void {
  console.log(`Email enviado a ${destinatario}: ${asunto}`);
}

describe('Sinon Spies - Tracking de Llamadas', () => {
  it('debe rastrear si una función fue llamada', () => {
    // Crear spy
    const spy = sinon.spy(enviarEmail);
    
    // Usar la función
    spy('usuario@example.com', 'Bienvenido');
    
    // Verificar
    expect(spy.called).to.be.true;
    expect(spy.callCount).to.equal(1);
    
    // Limpiar
    spy.restore();
  });
});
----

==== Rastrear Argumentos

Los spies permiten verificar con qué argumentos se llamó una función.

.Ejemplo:
[source,typescript]
----
import sinon from 'sinon';
import { expect } from 'chai';

function procesarOrden(orderId: number, cliente: string, monto: number): void {
  console.log(`Procesando orden ${orderId} de ${cliente} por $${monto}`);
}

describe('Spies - Validación de Argumentos', () => {
  let spy;
  
  beforeEach(() => {
    spy = sinon.spy(procesarOrden);
  });
  
  afterEach(() => {
    spy.restore();
  });
  
  it('debe capturar los argumentos de la llamada', () => {
    spy(123, 'Juan', 500);
    
    // Verificar llamada
    expect(spy.called).to.be.true;
    
    // Obtener argumentos de la primera llamada
    const args = spy.getCall(0).args;
    expect(args[0]).to.equal(123);
    expect(args[1]).to.equal('Juan');
    expect(args[2]).to.equal(500);
  });
  
  it('debe permitir verificación con calledWith', () => {
    spy(123, 'Juan', 500);
    
    // Sintaxis más limpia
    expect(spy.calledWith(123, 'Juan', 500)).to.be.true;
    expect(spy.calledWith(999, 'Ana', 100)).to.be.false;
  });
  
  it('debe rastrear múltiples llamadas', () => {
    spy(1, 'Juan', 100);
    spy(2, 'Ana', 200);
    spy(3, 'Carlos', 300);
    
    expect(spy.callCount).to.equal(3);
    
    // Verificar argumentos de cada llamada
    expect(spy.getCall(0).args[1]).to.equal('Juan');
    expect(spy.getCall(1).args[1]).to.equal('Ana');
    expect(spy.getCall(2).args[1]).to.equal('Carlos');
  });
  
  it('debe rastrear orden de llamadas', () => {
    spy(1, 'Juan', 100);
    spy(2, 'Ana', 200);
    
    expect(spy.firstCall.args[0]).to.equal(1);
    expect(spy.lastCall.args[0]).to.equal(2);
  });
});
----

==== Spying en Métodos de Objeto

Puedes crear spies sobre métodos de objetos existentes.

.Ejemplo:
[source,typescript]
----
import sinon from 'sinon';
import { expect } from 'chai';

class ServicioEmail {
  enviar(to: string, subject: string, body: string): { success: boolean } {
    console.log(`Enviando email a ${to}`);
    return { success: true };
  }
}

describe('Spies - Métodos de Objeto', () => {
  let servicio: ServicioEmail;
  let spy;
  
  beforeEach(() => {
    servicio = new ServicioEmail();
    spy = sinon.spy(servicio, 'enviar');
  });
  
  afterEach(() => {
    spy.restore();
  });
  
  it('debe rastrear llamadas a métodos', () => {
    servicio.enviar('usuario@example.com', 'Hola', 'Contenido');
    
    expect(spy.called).to.be.true;
    expect(spy.calledWith('usuario@example.com', 'Hola', 'Contenido')).to.be.true;
  });
  
  it('debe permitir múltiples spies simultáneamente', () => {
    const spy2 = sinon.spy(servicio, 'enviar');
    
    servicio.enviar('user1@example.com', 'Test', 'Body');
    servicio.enviar('user2@example.com', 'Test2', 'Body2');
    
    expect(spy.callCount).to.equal(2);
  });
});
----

==== Call Count y Call History

Información detallada sobre todas las llamadas.

.Tabla de propiedades útiles:
[cols="1,2"]
====
| Propiedad | Descripción

| `spy.called` | ¿Se llamó al menos una vez?
| `spy.callCount` | Número total de llamadas
| `spy.calledOnce` | ¿Se llamó exactamente una vez?
| `spy.calledTwice` | ¿Se llamó exactamente dos veces?
| `spy.calledThrice` | ¿Se llamó exactamente tres veces?
| `spy.notCalled` | ¿No se llamó nunca?
| `spy.firstCall` | Primera llamada (objeto Call)
| `spy.lastCall` | Última llamada (objeto Call)
| `s=py.getCall(n)` | Obtener n-ésima llamada
| `spy.getCalls()` | Todas las llamadas
====

.Ejemplo:
[source,typescript]
----
import sinon from 'sinon';
import { expect } from 'chai';

function notificar(mensaje: string): void {
  console.log(mensaje);
}

describe('Spies - Call History', () => {
  let spy;
  
  beforeEach(() => {
    spy = sinon.spy(notificar);
  });
  
  afterEach(() => {
    spy.restore();
  });
  
  it('debe verificar callCount', () => {
    spy('Mensaje 1');
    spy('Mensaje 2');
    spy('Mensaje 3');
    
    expect(spy.callCount).to.equal(3);
    expect(spy.calledThrice).to.be.true;
  });
  
  it('debe acceder a detalles de cada llamada', () => {
    spy('Primero');
    spy('Segundo');
    
    const calls = spy.getCalls();
    
    expect(calls).to.have.lengthOf(2);
    expect(calls[0].args[0]).to.equal('Primero');
    expect(calls[1].args[0]).to.equal('Segundo');
  });
});
----

---

=== 6.3 Stubs (Reemplazos)

Los stubs reemplazan funciones completamente, permitiendo controlar su comportamiento.

==== sinon.stub() - Crear un Stub

[source,typescript]
----
import sinon from 'sinon';
import { expect } from 'chai';

// Función a reemplazar
function obtenerTemperatura(ciudad: string): number {
  // En realidad llamaría a API
  throw new Error('No debe llamarse en test');
}

describe('Sinon Stubs - Reemplazos', () => {
  it('debe reemplazar función con stub', () => {
    // Crear stub que devuelve un valor específico
    const stub = sinon.stub().returns(25);
    
    const resultado = stub();
    
    expect(resultado).to.equal(25);
    expect(stub.called).to.be.true;
  });
});
----

==== Valores Retornados Personalizados

Los stubs pueden retornar diferentes valores según la llamada.

.Ejemplo:
[source,typescript]
----
import sinon from 'sinon';
import { expect } from 'chai';

class ServicioClima {
  obtenerTemperatura(ciudad: string): number {
    throw new Error('API externa');
  }
}

describe('Stubs - Valores Personalizados', () => {
  let stub;
  
  afterEach(() => {
    if (stub) stub.restore();
  });
  
  it('debe retornar valor específico', () => {
    stub = sinon.stub().returns(25);
    
    expect(stub()).to.equal(25);
    expect(stub.returned(25)).to.be.true;
  });
  
  it('debe retornar diferentes valores por llamada', () => {
    stub = sinon.stub()
      .onFirstCall().returns(20)
      .onSecondCall().returns(25)
      .onThirdCall().returns(30);
    
    expect(stub()).to.equal(20);  // Primera llamada
    expect(stub()).to.equal(25);  // Segunda llamada
    expect(stub()).to.equal(30);  // Tercera llamada
  });
  
  it('debe retornar valor según argumentos', () => {
    stub = sinon.stub()
      .withArgs('Madrid').returns(28)
      .withArgs('Barcelona').returns(25)
      .withArgs('Bilbao').returns(22);
    
    expect(stub('Madrid')).to.equal(28);
    expect(stub('Barcelona')).to.equal(25);
    expect(stub('Bilbao')).to.equal(22);
  });
});
----

==== Stub de Métodos de Objeto

Reemplazar métodos específicos de un objeto.

.Ejemplo:
[source,typescript]
----
import sinon from 'sinon';
import { expect } from 'chai';

class BaseDatos {
  query(sql: string): any {
    throw new Error('Conexión a DB real');
  }
}

class RepositorioUsuarios {
  constructor(private db: BaseDatos) {}
  
  obtener(id: number) {
    return this.db.query(`SELECT * FROM usuarios WHERE id = ${id}`);
  }
}

describe('Stubs - Métodos de Objeto', () => {
  let db: BaseDatos;
  let repo: RepositorioUsuarios;
  let stub;
  
  beforeEach(() => {
    db = new BaseDatos();
    repo = new RepositorioUsuarios(db);
  });
  
  afterEach(() => {
    if (stub) stub.restore();
  });
  
  it('debe stubear método de BD', () => {
    stub = sinon.stub(db, 'query').returns({
      id: 1,
      nombre: 'Juan',
      email: 'juan@example.com'
    });
    
    const usuario = repo.obtener(1);
    
    expect(usuario.nombre).to.equal('Juan');
    expect(stub.called).to.be.true;
  });
  
  it('debe retornar diferentes valores por argumento', () => {
    stub = sinon.stub(db, 'query')
      .withArgs('SELECT * FROM usuarios WHERE id = 1')
      .returns({ id: 1, nombre: 'Juan' })
      .withArgs('SELECT * FROM usuarios WHERE id = 2')
      .returns({ id: 2, nombre: 'Ana' });
    
    const usuario1 = repo.obtener(1);
    const usuario2 = repo.obtener(2);
    
    expect(usuario1.nombre).to.equal('Juan');
    expect(usuario2.nombre).to.equal('Ana');
  });
});
----

==== Lanzar Errores desde Stubs

Los stubs pueden simular errores.

.Ejemplo:
[source,typescript]
----
import sinon from 'sinon';
import { expect } from 'chai';

async function obtenerProducto(id: number) {
  // Llamaría a API
  throw new Error('No debe ejecutarse');
}

describe('Stubs - Lanzar Errores', () => {
  it('debe lanzar error desde stub', async () => {
    const stub = sinon.stub().throws(new Error('Producto no encontrado'));
    
    try {
      stub(999);
      throw new Error('Debería haber lanzado error');
    } catch (err) {
      expect(err.message).to.equal('Producto no encontrado');
    }
  });
  
  it('debe lanzar error según argumentos', () => {
    const stub = sinon.stub()
      .withArgs(999).throws(new Error('No encontrado'))
      .withArgs(1).returns({ id: 1, nombre: 'Laptop' });
    
    expect(() => stub(999)).to.throw('No encontrado');
    expect(stub(1).nombre).to.equal('Laptop');
  });
});
----

==== Reject de Promises

Los stubs pueden rechazar promises.

.Ejemplo:
[source,typescript]
----
import sinon from 'sinon';
import { expect } from 'chai';

describe('Stubs - Promise Rejection', () => {
  it('debe rechazar promise', async () => {
    const stub = sinon.stub()
      .rejects(new Error('Fallo en la operación'));
    
    try {
      await stub();
      throw new Error('Debería haber rechazado');
    } catch (err) {
      expect(err.message).to.equal('Fallo en la operación');
    }
  });
  
  it('debe resolver o rechazar según argumentos', async () => {
    const stub = sinon.stub()
      .withArgs(1).resolves({ id: 1, nombre: 'Laptop' })
      .withArgs(999).rejects(new Error('No encontrado'));
    
    const resultado = await stub(1);
    expect(resultado.nombre).to.equal('Laptop');
    
    try {
      await stub(999);
    } catch (err) {
      expect(err.message).to.equal('No encontrado');
    }
  });
});
----

---

=== 6.4 Mocks (Burlas)

Los mocks combinan la funcionalidad de stubs con aserciones integradas sobre cómo fueron llamados.

==== sinon.mock() - Crear un Mock

[source,typescript]
----
import sinon from 'sinon';
import { expect } from 'chai';

class RegistradorEventos {
  registrar(evento: string, datos: any): void {
    console.log(`Evento: ${evento}`, datos);
  }
}

describe('Sinon Mocks - Aserciones Integradas', () => {
  it('debe verificar expectativas de llamadas', () => {
    const registrador = new RegistradorEventos();
    const mock = sinon.mock(registrador);
    
    // Establecer expectativa
    mock.expects('registrar')
      .once()  // Debe llamarse una sola vez
      .withArgs('login', sinon.match({ usuarioId: 1 }));
    
    // Usar el objeto
    registrador.registrar('login', { usuarioId: 1 });
    
    // Verificar expectativas
    mock.verify();
  });
});
----

==== Expectativas de Mocks

Tabla de métodos de expectativas:

[cols="1,2"]
====
| Método | Descripción

| `.once()` | Debe llamarse exactamente una vez
| `.twice()` | Debe llamarse exactamente dos veces
| `.thrice()` | Debe llamarse exactamente tres veces
| `.exactly(n)` | Debe llamarse exactamente n veces
| `.atLeast(n)` | Debe llamarse al menos n veces
| `.atMost(n)` | Debe llamarse como máximo n veces
| `.withArgs(args)` | Debe llamarse con estos argumentos
| `.withExactArgs(args)` | Exactamente estos argumentos (sin variación)
| `.=returns(value)` | Retorna un valor específico
| `.throws(error)` | Lanza un error específico
| `.verify()` | Verifica que se cumplieron todas las expectativas
====

.Ejemplo completo:
[source,typescript]
----
import sinon from 'sinon';
import { expect } from 'chai';

class ServicioNotificaciones {
  enviar(tipo: string, destinatario: string, mensaje: string): void {}
  registrar(evento: string, datos: any): void {}
}

describe('Mocks - Expectativas', () => {
  let servicio: ServicioNotificaciones;
  let mock;
  
  beforeEach(() => {
    servicio = new ServicioNotificaciones();
  });
  
  afterEach(() => {
    if (mock) mock.restore();
  });
  
  it('debe verificar que se llamó con argumentos específicos', () => {
    mock = sinon.mock(servicio);
    
    mock.expects('enviar')
      .withArgs('email', 'usuario@example.com', 'Bienvenido')
      .once();
    
    servicio.enviar('email', 'usuario@example.com', 'Bienvenido');
    
    mock.verify();
  });
  
  it('debe verificar múltiples llamadas esperadas', () => {
    mock = sinon.mock(servicio);
    
    mock.expects('registrar').twice();
    mock.expects('enviar').atLeast(1);
    
    servicio.registrar('login', { usuarioId: 1 });
    servicio.registrar('logout', { usuarioId: 1 });
    servicio.enviar('email', 'user@example.com', 'Mensaje');
    
    mock.verify();
  });
  
  it('debe fallar si expectativas no se cumplen', () => {
    mock = sinon.mock(servicio);
    
    mock.expects('enviar').once();
    
    try {
      servicio.enviar('email', 'user@example.com', 'Msg 1');
      servicio.enviar('email', 'user@example.com', 'Msg 2'); // Segunda llamada!
      
      mock.verify();
      throw new Error('Debería haber fallado');
    } catch (err) {
      expect(err.message).to.include('expected');
    }
  });
});
----

==== Ejemplo Práctico Completo: Carrito de Compras

[source,typescript]
----
// src/carrito.ts
export class CarritoCompras {
  private items: any[] = [];
  
  constructor(
    private notificador: any,
    private baseDatos: any,
    private analizador: any
  ) {}
  
  agregarProducto(productoId: number, nombre: string, precio: number): void {
    this.items.push({ productoId, nombre, precio });
    this.notificador.notificar(`Producto ${nombre} agregado`);
  }
  
  completarCompra(): void {
    this.baseDatos.guardarPedido(this.items);
    this.analizador.rastrearCompra(this.items);
    this.notificador.notificar('Compra completada');
  }
}
----

.Tests con Spies, Stubs y Mocks:
[source,typescript]
----
import sinon from 'sinon';
import { expect } from 'chai';
import { CarritoCompras } from '../src/carrito';

describe('CarritoCompras - Spies, Stubs y Mocks', () => {
  let carrito: CarritoCompras;
  let notificador, baseDatos, analizador;
  let notificadorMock, baseDatasStub, analizadorSpy;
  
  beforeEach(() => {
    notificador = {
      notificar: (mensaje: string) => console.log(mensaje)
    };
    baseDatos = {
      guardarPedido: (items: any[]) => {}
    };
    analizador = {
      rastrearCompra: (items: any[]) => {}
    };
    
    carrito = new CarritoCompras(notificador, baseDatos, analizador);
  });
  
  afterEach(() => {
    if (notificadorMock) notificadorMock.restore();
    if (baseDatasStub) baseDatasStub.restore();
    if (analizadorSpy) analizadorSpy.restore();
  });
  
  describe('Usando Spies', () => {
    it('debe rastrear notificaciones', () => {
      analizadorSpy = sinon.spy(analizador, 'rastrearCompra');
      
      carrito.agregarProducto(1, 'Laptop', 1000);
      
      expect(analizadorSpy.called).to.be.false; // No se llama en agregar
    });
  });
  
  describe('Usando Stubs', () => {
    it('debe stubear BD para evitar guardarla', () => {
      baseDatasStub = sinon.stub(baseDatos, 'guardarPedido').returns(true);
      
      carrito.agregarProducto(1, 'Laptop', 1000);
      carrito.completarCompra();
      
      expect(baseDatasStub.called).to.be.true;
    });
  });
  
  describe('Usando Mocks', () => {
    it('debe verificar que notificador es llamado correctamente', () => {
      notificadorMock = sinon.mock(notificador);
      baseDatasStub = sinon.stub(baseDatos, 'guardarPedido');
      analizadorSpy = sinon.spy(analizador, 'rastrearCompra');
      
      notificadorMock.expects('notificar')
        .twice()
        .withArgs(sinon.match.string);
      
      carrito.agregarProducto(1, 'Laptop', 1000);
      carrito.completarCompra();
      
      notificadorMock.verify();
    });
  });
});
----

==== Cuándo Usar Cada Uno

[cols="1,2,3"]
====
| Herramienta | Cuándo Usar | Beneficio

| *Spy* | Monitorear función real | Verifica intera acciones sin interferir
| *Stub* | Reemplazar dependencia | Control total, aisla código de test
| *Mock* | Verificar comportamiento | Aserciones integradas, expresa intención
====

---

== Módulo 7: Testing de Código Asíncrono
=
Testing de código asincrónico requiere técnicas especiales que veremos en este módulo. Cubriremos los tres patrones principales: callbacks, promises y async/await, además de técnicas avanzadas como polling y retry.

=== 7.1 Callbacks

==== ¿Por qué es diferente testear callbacks?

El código sincrónico se ejecuta inmediatamente. El código asincrónico se ejecuta después de un tiempo indeterminado. Sin técnicas especiales, Mocha terminaría el test antes de que el callback se ejecute.

.Problema común:
[source,typescript]
----
import { expect } from 'chai';

function leerArchivo(ruta: string, callback: (err: any, datos: string) => void): void {
  // Simular lectura con delay
  setTimeout(() => {
    callback(null, 'Contenido del archivo');
  }, 100);
}

describe('Callbacks - Problema', () => {
  it('FALLA: No espera el callback', () => {
    let resultado: string;
    
    leerArchivo('archivo.txt', (err, datos) => {
      resultado = datos;
    });
    
    // Este test pasa porque la aserción sucede antes del callback
    // El resultado es undefined pero no se verifica
    expect(resultado).to.equal('Contenido del archivo'); // FALLA: resultado es undefined
  });
});
----

==== Solución: done Callback

Mocha permite pasar un parámetro `done` al callback del test. El test solo finaliza cuando `done()` se ejecuta.

.Ejemplo correcto:
[source,typescript]
----
import { expect } from 'chai';

function leerArchivo(ruta: string, callback: (err: any, datos: string) => void): void {
  setTimeout(() => {
    callback(null, 'Contenido del archivo');
  }, 100);
}

describe('Callbacks - done Parameter', () => {
  it('debe esperar callback antes de finalizar', (done) => {
    let resultado: string;
    
    leerArchivo('archivo.txt', (err, datos) => {
      resultado = datos;
      expect(resultado).to.equal('Contenido del archivo');
      done();  // Señala que el test termina aquí
    });
  });
});
----

==== Manejo de Errores con Callbacks

Los errores en callbacks deben pasarse a `done()`.

.Ejemplo:
[source,typescript]
----
import { expect } from 'chai';

function conectarBaseDatos(url: string, callback: (err: any, conexion?: any) => void): void {
  setTimeout(() => {
    f (url === 'válida') {
      callback(null, { conectado: true });
    } else {
      callback(new Error('URL inválida'));
    }
  }, 50);
}

describe('Callbacks - Error Handling', () => {
  it('debe pasar error a done()', (done) => {
    conectarBaseDatos('inválida', (err, conexion) => {
      try {
        expect(err).to.exist;
        expect(err.message).to.equal('URL inválida');
        done();
      } catch (e) {
        done(e);  // Pasar el error a done
      }
    });
  });
  
  it('debe manejar error correctamente', (done) => {
    conectarBaseDatos('válida', (err, conexion) => {
      try {
        expect(err).to.be.null;
        expect(conexion.conectado).to.be.true;
        done();
      } catch (e) {
        done(e);
      }
    });
  });
  
  it('debe fallar si callback lanza error sin try/catch', (done) => {
    conectarBaseDatos('válida', (err, conexion) => {
      expect(err).to.be.null;
      expect(conexion.conectado).to.be.true;
      done();
      // Si hubiera error, done() nunca se ejecutaría
    });
  });
});
----

==== Timeout en Callbacks

Mocha tiene timeout por defecto de 2000ms. Puede ser personalizado.

.Ejemplo:
[source,typescript]
----
import { expect } from 'chai';

function operacionLenta(callback: () => void): void {
  setTimeout(callback, 3000);  // Tarda 3 segundos
}

describe('Callbacks - Timeout', () => {
  it('falla si tard más que el timeout', (done) => {
    operacionLenta(() => {
      done();
    });
    // Falla: timeout 2000ms < operación 3000ms
  });
  
  it('personalizar timeout para test específico', function(done) {
    this.timeout(5000);  // 5 segundos solo para este test
    
    operacionLenta(() => {
      expect(true).to.be.true;
      done();
    });
  });
  
  it('aumentar timeout global', function(done) {
    this.timeout(10000);
    
    operacionLenta(() => {
      done();
    });
  });
  
  it('inhabilitar timeout', function(done) {
    this.timeout(0);  // Sin timeout
    
    operacionLenta(() => {
      done();
    });
  });
});
----

==== Ejemplo Práctico: Servicio de Email

[source,typescript]
----
// src/servicioEmail.ts
export class ServicioEmail {
  enviar(
    destinatario: string,
    asunto: string,
    cuerpo: string,
    callback: (err: any, resultado?: { id: string }) => void
  ): void {
    // Simular envío asincrónico
    setTimeout(() => {
      if (!destinatario.includes('@')) {
        callback(new Error('Email inválido'));
      } else {
        callback(null, { id: `email_${Date.now()}` });
      }
    }, 100);
  }
}
----

.Tests:
[source,typescript]
----
import { expect } from 'chai';
import { ServicioEmail } from '../src/servicioEmail';

describe('ServicioEmail - Callbacks', () => {
  let servicio: ServicioEmail;
  
  beforeEach(() => {
    servicio = new ServicioEmail();
  });
  
  it('debe enviar email válido', (done) => {
    servicio.enviar('usuario@example.com', 'Hola', 'Contenido', (err, resultado) => {
      try {
        expect(err).to.be.null;
        expect(resultado).to.exist;
        expect(resultado!.id).to.match(/^email_\d+$/);
        done();
      } catch (e) {
        done(e);
      }
    });
  });
  
  it('debe rechazar email inválido', (done) => {
    servicio.enviar('usuario-invalido', 'Hola', 'Contenido', (err, resultado) => {
      try {
        expect(err).to.exist;
        expect(err.message).to.equal('Email inválido');
        expect(resultado).to.be.undefined;
        done();
      } catch (e) {
        done(e);
      }
    });
  });
});
----

---

=== 7.2 Promises

==== Testing de Promises

Con Promises, no se necesita `done` callback. Solo retorna la promise.

.Ejemplo básico:
[source,typescript]
----
import { expect } from 'chai';

function obtenerDatos(id: number): Promise<{ id: number; nombre: string }> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (id > 0) {
        resolve({ id, nombre: 'Usuario' });
      } else {
        reject(new Error('ID inválido'));
      }
    }, 50);
  });
}

describe('Promises - Return Pattern', () => {
  it('debe retornar la promise para que Mocha la espere', () => {
    // Retornar promise directo
    return obtenerDatos(1).then(datos => {
      expect(datos.nombre).to.equal('Usuario');
    });
  });
  
  it('puede usar encadenamiento de promesas', () => {
    return obtenerDatos(5)
      .then(datos => {
        expect(datos.id).to.equal(5);
        return obtenerDatos(10);
      })
      .then(datos => {
        expect(datos.id).to.equal(10);
      });
  });
});
----

==== Manejo de Rechazos

Las promises rechazadas deben ser manejadas con `.catch()` o `.rejectedWith()`.

.Ejemplo:
[source,typescript]
----
import { expect } from 'chai';

function obtenerProducto(id: number): Promise<{ id: number; precio: number }> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (id > 0) {
        resolve({ id, precio: 99.99 });
      } else {
        reject(new Error('Producto no encontrado'));
      }
    }, 50);
  });
}

describe('Promises - Error Handling', () => {
  it('debe capturar rechazos con .catch()', () => {
    return obtenerProducto(-1)
      .then(() => {
        throw new Error('Debería haber rechazado');
      })
      .catch(err => {
        expect(err.message).to.equal('Producto no encontrado');
      });
  });
  
  it('debe verificar que rechaza correctamente', () => {
    return obtenerProducto(-1).then(
      () => {
        throw new Error('No debería resolver');
      },
      (err) => {
        expect(err.message).to.equal('Producto no encontrado');
      }
    );
  });
  
  it('debe usar rejectedWith con Chai', () => {
    return expect(obtenerProducto(-1)).to.be.rejectedWith('Producto no encontrado');
  });
});
----

==== Promise.all() y Promise.race()

Testing con múltiples promises simultáneamente.

.Ejemplo:
[source,typescript]
----
import { expect } from 'chai';

function obtenerUsuario(id: number): Promise<{ id: number; nombre: string }> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id, nombre: `Usuario ${id}` });
    }, Math.random() * 100);
  });
}

function obtenerCarrito(id: number): Promise<{ id: number; items: number }> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id, items: Math.random() * 10 | 0 });
    }, Math.random() * 100);
  });
}

describe('Promises - Promise.all()', () => {
  it('debe esperar todas las promises', () => {
    return Promise.all([
      obtenerUsuario(1),
      obtenerCarrito(1)
    ]).then(([usuario, carrito]) => {
      expect(usuario.nombre).to.equal('Usuario 1');
      expect(carrito.items).to.be.a('number');
    });
  });
  
  it('debe fallar si alguna promise falla', () => {
    const promeseFallida = Promise.reject(new Error('Fallo en BD'));
    
    return expect(
      Promise.all([obtenerUsuario(1), promeseFallida])
    ).to.be.rejected;
  });
});

describe('Promises - Promise.race()', () => {
  it('debe resolver con la primera promise que se completa', () => {
    return Promise.race([
      obtenerUsuario(1),
      obtenerCarrito(1)
    ]).then(resultado => {
      expect(resultado).to.exist;
      expect(resultado.id).to.equal(1);
    });
  });
  
  it('debe rechazar si primera promise se rechaza', () => {
    const promeseFallida = Promise.reject(new Error('Primer rechazo'));
    
    return expect(
      Promise.race([promeseFallida, obtenerUsuario(1)])
    ).to.be.rejected;
  });
});
----

==== Ejemplo Práctico: Cliente HTTP

[source,typescript]
----
// src/clienteHttp.ts
export class ClienteHttp {
  get(url: string): Promise<any> {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (url.startsWith('http')) {
          resolve({ status: 200, datos: { id: 1, nombre: 'Recurso' } });
        } else {
          reject(new Error('URL inválida'));
        }
      }, 50);
    });
  }
  
  post(url: string, datos: any): Promise<any> {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (url.startsWith('http') && datos) {
          resolve({ status: 201, id: Math.random() });
        } else {
          reject(new Error('Datos inválidos'));
        }
      }, 50);
    });
  }
}
----

.Tests:
[source,typescript]
----
import { expect } from 'chai';
import { ClienteHttp } from '../src/clienteHttp';

describe('ClienteHttp - Promises', () => {
  let cliente: ClienteHttp;
  
  beforeEach(() => {
    cliente = new ClienteHttp();
  });
  
  it('debe realizar GET y retornar datos', () => {
    return cliente.get('http://api.example.com/usuarios/1')
      .then(respuesta => {
        expect(respuesta.status).to.equal(200);
        expect(respuesta.datos.nombre).to.equal('Recurso');
      });
  });
  
  it('debe rechazar GET con URL inválida', () => {
    return expect(
      cliente.get('api-invalida')
    ).to.be.rejectedWith('URL inválida');
  });
  
  it('debe encadenar GET y POST', () => {
    return cliente.get('http://api.example.com/datos')
      .then(respuesta => {
        return cliente.post('http://api.example.com/crear', {
          nombre: respuesta.datos.nombre
        });
      })
      .then(crearRespuesta => {
        expect(crearRespuesta.status).to.equal(201);
        expect(crearRespuesta.id).to.be.a('number');
      });
  });
});
----

---

=== 7.3 Async/Await

==== Async/Await - La Forma Moderna

Async/await permite escribir código asincrónico que se parece a código sincrónico. Es el patrón preferido hoy.

.Ejemplo básico:
[source,typescript]
----
import { expect } from 'chai';

async function obtenerDatos(id: number): Promise<{ id: number; nombre: string }> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id, nombre: `Elemento ${id}` });
    }, 100);
  });
}

describe('Async/Await - Básico', () => {
  it('debe usar async/await', async () => {
    const datos = await obtenerDatos(5);
    
    expect(datos.id).to.equal(5);
    expect(datos.nombre).to.equal('Elemento 5');
  });
  
  it('puede encadenar múltiples awaits', async () => {
    const datos1 = await obtenerDatos(1);
    const datos2 = await obtenerDatos(2);
    const datos3 = await obtenerDatos(3);
    
    expect(datos1.id).to.equal(1);
    expect(datos2.id).to.equal(2);
    expect(datos3.id).to.equal(3);
  });
});
----

==== Manejo de Errores en Async/Await

Usar try/catch para manejar rechazos de promises.

.Ejemplo:
[source,typescript]
----
import { expect } from 'chai';

async function obtenerUsuario(id: number): Promise<{ nombre: string }> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (id > 0) {
        resolve({ nombre: `Usuario ${id}` });
      } else {
        reject(new Error('Usuario no encontrado'));
      }
    }, 50);
  });
}

describe('Async/Await - Try/Catch', () => {
  it('debe capturar errores con try/catch', async () => {
    try {
      await obtenerUsuario(-1);
      throw new Error('Debería haber lanzado error');
    } catch (err) {
      expect(err.message).to.equal('Usuario no encontrado');
    }
  });
  
  it('debe permitir manejo de ambos casos', async () => {
    try {
      const usuario = await obtenerUsuario(5);
      expect(usuario.nombre).to.equal('Usuario 5');
    } catch (err) {
      throw new Error('No debería fallar');
    }
  });
  
  it('debe esperar múltiples operaciones', async () => {
    try {
      const usuario1 = await obtenerUsuario(1);
      const usuario2 = await obtenerUsuario(2);
      const usuario3 = await obtenerUsuario(3);
      
      expect(usuario1.nombre).to.include('Usuario');
      expect(usuario2.nombre).to.include('Usuario');
      expect(usuario3.nombre).to.include('Usuario');
    } catch (err) {
      throw new Error('Todas deberían resolver');
    }
  });
});
----

==== Async/Await con Promise.all()

Ejecutar múltiples promises en paralelo es más eficiente.

.Ejemplo:
[source,typescript]
----
import { expect } from 'chai';

async function obtenerProducto(id: number): Promise<{ id: number; precio: number }> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id, precio: Math.random() * 1000 });
    }, Math.random() * 100);
  });
}

describe('Async/Await - Paralelo vs Secuencial', () => {
  it('secuencial: espera cada uno (más lento)', async () => {
    const inicio = Date.now();
    
    const prod1 = await obtenerProducto(1);
    const prod2 = await obtenerProducto(2);
    const prod3 = await obtenerProducto(3);
    
    const tiempoTotal = Date.now() - inicio;
    
    expect([prod1, prod2, prod3]).to.have.lengthOf(3);
    expect(tiempoTotal).to.be.greaterThan(200); // ~300ms si cada uno tarda ~100ms
  });
  
  it('paralelo: ejecuta en paralelo (más rápido)', async () => {
    const inicio = Date.now();
    
    const productos = await Promise.all([
      obtenerProducto(1),
      obtenerProducto(2),
      obtenerProducto(3)
    ]);
    
    const tiempoTotal = Date.now() - inicio;
    
    expect(productos).to.have.lengthOf(3);
    expect(tiempoTotal).to.be.lessThan(200); // ~100ms max
  });
});
----

==== Ejemplo Práctico: Procesamiento de Datos

[source,typescript]
----
// src/procesadorDatos.ts
export class ProcesadorDatos {
  async obtenerJSON(url: string): Promise<any> {
    // Simular fetch
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (url.includes('invalid')) {
          reject(new Error('URL no válida'));
        } else {
          resolve({ datos: [1, 2, 3, 4, 5] });
        }
      }, 50);
    });
  }
  
  async transformar(datos: any): Promise<number> {
    // Simular transformación
    return new Promise((resolve) => {
      setTimeout(() => {
        const suma = datos.datos.reduce((a: number, b: number) => a + b, 0);
        resolve(suma);
      }, 50);
    });
  }
  
  async procesar(url: string): Promise<number> {
    const respuesta = await this.obtenerJSON(url);
    const resultado = await this.transformar(respuesta);
    return resultado;
  }
}
----

.Tests:
[source,typescript]
----
import { expect } from 'chai';
import { ProcesadorDatos } from '../src/procesadorDatos';

describe('ProcesadorDatos - Async/Await', () => {
  let procesador: ProcesadorDatos;
  
  beforeEach(() => {
    procesador = new ProcesadorDatos();
  });
  
  it('debe obtener y transformar datos', async () => {
    const resultado = await procesador.procesar('http://api.example.com/datos');
    
    expect(resultado).to.equal(15); // 1+2+3+4+5
  });
  
  it('debe manejar errores en URL inválida', async () => {
    try {
      await procesador.procesar('http://invalid-url/datos');
      throw new Error('Debería haber rechazado');
    } catch (err) {
      expect(err.message).to.include('URL no válida');
    }
  });
  
  it('debe ejecutar múltiples procesamientos en paralelo', async () => {
    const resultados = await Promise.all([
      procesador.procesar('http://api.example.com/datos1'),
      procesador.procesar('http://api.example.com/datos2'),
      procesador.procesar('http://api.example.com/datos3')
    ]);
    
    expect(resultados).to.have.lengthOf(3);
    resultados.forEach(r => expect(r).to.equal(15));
  });
});
----

---

=== 7.4 Polling y Retry

==== Polling: Esperar Condiciones

A veces necesitas esperar hasta que una condición sea verdadera.

.Función de helper polling:
[source,typescript]
----
// src/polling.ts
export function polling(
  condicion: () => boolean | Promise<boolean>,
  intervalo: number = 100,
  timeout: number = 5000
): Promise<void> {
  const inicio = Date.now();
  
  return new Promise((resolve, reject) => {
    const verificar = async () => {
      try {
        const resultado = await Promise.resolve(condicion());
        
        if (resultado) {
          resolve();
        } else if (Date.now() - inicio > timeout) {
          reject(new Error(`Polling timeout after ${timeout}ms`));
        } else {
          setTimeout(verificar, intervalo);
        }
      } catch (err) {
        reject(err);
      }
    };
    
    verificar();
  });
}
----

.Ejemplo de uso:
[source,typescript]
----
import { expect } from 'chai';
import { polling } from '../src/polling';

class ServicioAsincrono {
  private estado: string = 'iniciando';
  
  iniciar(): void {
    setTimeout(() => {
      this.estado = 'listo';
    }, 300);
  }
  
  getEstado(): string {
    return this.estado;
  }
}

describe('Polling - Esperar Condiciones', () => {
  it('debe esperar hasta que servicio esté listo', async () => {
    const servicio = new ServicioAsincrono();
    servicio.iniciar();
    
    wait polling(() => servicio.getEstado() === 'listo', 50, 5000);
    
    expect(servicio.getEstado()).to.equal('listo');
  });
  
  it('debe timeout si condición no se cumple', async () => {
    const servicio = new ServicioAsincrono();
    // No llama iniciar(), nunca llegará a 'listo'
    
    try {
      wait polling(() => servicio.getEstado() === 'listo', 50, 500);
      throw new Error('Debería haber hecho timeout');
    } catch (err) {
      expect(err.message).to.include('timeout');
    }
  });
});
----

==== Retry: Reintentar Operaciones

A veces operaciones fallan temporalmente y deben reintentarse.

.Función retry:
[source,typescript]
----
// src/retry.ts
export async function retry<T>(
  fn: () => Promise<T>,
  maxIntentos: number = 3,
  intervalo: number = 100
): Promise<T> {
  let ultimoError: Error | null = null;
  
  for (let intento = 1; intento <= maxIntentos; intento++) {
    try {
      return await fn();
    } catch (err) {
      ultimoError = err;
      
      if (intento < maxIntentos) {
        // Esperar antes de reintentar (backoff exponencial opcional)
        await new Promise(resolve => setTimeout(resolve, intervalo * intento));
      }
    }
  }
  
  throw ultimoError || new Error('Retry falló');
}
----

.Ejemplo:
[source,typescript]
----
import { expect } from 'chai';
import { retry } from '../src/retry';

class ServicioInestable {
  private llamadas: number = 0;
  
  async operacion(): Promise<string> {
    this.llamadas++;
    
    if (this.llamadas < 3) {
      throw new Error('Fallo temporal');
    }
    
    return 'Éxito';
  }
}

describe('Retry - Reintentos', () => {
  it('debe reintentar hasta obtener éxito', async () => {
    const servicio = new ServicioInestable();
    
    const resultado = await retry(
      () => servicio.operacion(),
      5,
      50
    );
    
    expect(resultado).to.equal('Éxito');
    expect(servicio.llamadas).to.equal(3);
  });
  
  it('debe fallar si máximo intentos se agota', async () => {
    const servicio = new ServicioInestable();
    
    try {
      await retry(
        () => servicio.operacion(),
        2,  // Solo 2 intentos, necesita 3
        50
      );
      throw new Error('Debería haber fallado');
    } catch (err) {
      expect(err.message).to.include('Fallo temporal');
    }
  });
  
  it('debe usar backoff exponencial', async () => {
    let tiempos: number[] = [];
    let ultimoTiempo = Date.now();
    
    const servicio = new ServicioInestable();
    
    const resultado = await retry(
      async () => {
        const ahora = Date.now();
        tiempos.push(ahora - ultimoTiempo);
        ultimoTiempo = ahora;
        return servicio.operacion();
      },
      5,
      50
    );
    
    // Segundo intento debería tener delay, tercero mayor delay
    expect(tiempos[1]).to.be.greaterThan(50);
    expect(tiempos[2]).to.be.greaterThan(100);
  });
});
----

==== Timeout Personalizado

Control fino del timeout en operaciones asincrónicas.

.Función timeout:
[source,typescript]
----
// src/timeout.ts
export function conTimeout<T>(
  promise: Promise<T>,
  tiempoMs: number
): Promise<T> {
  return Promise.race([
    promise,
    new Promise<T>((_, reject) =>
      setTimeout(
        () => reject(new Error(`Operación timeout después de ${tiempoMs}ms`)),
        tiempoMs
      )
    )
  ]);
}
----

.Ejemplo:
[source,typescript]
----
import { expect } from 'chai';
import { conTimeout } from '../src/timeout';

function operacionLenta(duracion: number): Promise<string> {
  return new Promise(resolve => {
    setTimeout(() => resolve('Completado'), duracion);
  });
}

describe('Timeout - Control de Tiempo', () => {
  it('debe completarse antes del timeout', async () => {
    const resultado = await conTimeout(
      operacionLenta(100),
      1000  // 1 segundo de timeout
    );
    
    expect(resultado).to.equal('Completado');
  });
  
  it('debe fallar si excede timeout', async () => {
    try {
      await conTimeout(
        operacionLenta(1000),
        100  // 100ms timeout
      );
      throw new Error('Debería haber hecho timeout');
    } catch (err) {
      expect(err.message).to.include('timeout');
    }
  });
  
  it('puede usar en tests con this.timeout()', function(done) {
    this.timeout(5000);
    
    conTimeout(operacionLenta(200), 3000)
      .then(resultado => {
        expect(resultado).to.equal('Completado');
        done();
      })
      .catch(done);
  });
});
----

==== Ejemplo Integrado: Pipeline Asincrónico

[source,typescript]
----
// src/pipeline.ts
export class PipelineAsincrónico {
  async descargarDatos(url: string): Promise<any> {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({ id: 1, datos: [1, 2, 3] });
      }, 100);
    });
  }
  
  async procesar(datos: any): Promise<any> {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({ suma: datos.datos.reduce((a: number, b: number) => a + b, 0) });
      }, 100);
    });
  }
  
  async guardar(resultado: any): Promise<boolean> {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(true);
      }, 100);
    });
  }
  
  async ejecutar(url: string): Promise<boolean> {
    const datos = await this.descargarDatos(url);
    const resultado = await this.procesar(datos);
    return await this.guardar(resultado);
  }
}
----

.Tests:
[source,typescript]
----
import { expect } from 'chai';
import { PipelineAsincrónico } from '../src/pipeline';
import { retry } from '../src/retry';
import { conTimeout } from '../src/timeout';

describe('Pipeline Asincrónico - Integración', () => {
  let pipeline: PipelineAsincrónico;
  
  beforeEach(() => {
    pipeline = new PipelineAsincrónico();
  });
  
  it('debe ejecutar pipeline completo', async () => {
    const resultado = await pipeline.ejecutar('http://api.example.com/datos');
    expect(resultado).to.be.true;
  });
  
  it('debe ejecutar pipeline con timeout', async () => {
    const resultado = await conTimeout(
      pipeline.ejecutar('http://api.example.com/datos'),
      5000
    );
    expect(resultado).to.be.true;
  });
  
  it('debe reintentar si falla temporalmente', async () => {
    let intentos = 0;
    
    const resultado = await retry(
      async () => {
        intentos++;
        if (intentos < 2) throw new Error('Fallo temporal');
        return pipeline.ejecutar('http://api.example.com/datos');
      },
      3,
      50
    );
    
    expect(resultado).to.be.true;
    expect(intentos).to.equal(2);
  });
});
----

---

---

== Módulo 8: Fixtures y Setup

En tests reales, a menudo necesitas datos de prueba consistentes. Las fixtures son conjuntos de datos predefinidos que preparan el estado inicial para cada test. Este módulo cubre estrategias para preparar datos, mockear bases de datos y simular APIs.

=== 8.1 Preparación de Datos

==== ¿Qué son las Fixtures?

Las fixtures son datos conocidos y predefinidos que se usan como punto de partida para tests. Evitan perder tiempo creando datos en cada test.

.Problema sin fixtures:
[source,typescript]
----
import { expect } from 'chai';

class RepositorioUsuarios {
  private usuarios: any[] = [];
  
  agregar(usuario: any): number {
    usuario.id = this.usuarios.length + 1;
    this.usuarios.push(usuario);
    return usuario.id;
  }
  
  obtener(id: number): any {
    eturn this.usuarios.find(u => u.id === id);
  }
}

describe('RepositorioUsuarios - Sin Fixtures', () => {
  let repo: RepositorioUsuarios;
  
  beforeEach(() => {
    repo = new RepositorioUsuarios();
  });
  
  it('test 1: debe agregar usuario', () => {
    // Repetir esto en cada test es tedioso
    const id = repo.agregar({ nombre: 'Juan', email: 'juan@example.com', edad: 30 });
    expect(id).to.equal(1);
  });
  
  it('test 2: debe obtener usuario', () => {
    const id = repo.agregar({ nombre: 'Juan', email: 'juan@example.com', edad: 30 });
    const usuario = repo.obtener(id);
    expect(usuario.nombre).to.equal('Juan');
  });
  
  it('test 3: debe retornar undefined si no existe', () => {
    const usuario = repo.obtener(999);
    expect(usuario).to.be.undefined;
  });
});
----

==== Fixtures Estáticas

Fixtures son datos predefinidos que se reutilizan.

.Ejemplo:
[source,typescript]
----
import { expect } from 'chai';

class RepositorioUsuarios {
  private usuarios: any[] = [];
  
  agregar(usuario: any): number {
    usuario.id = (this.usuarios.length || 0) + 1;
    this.usuarios.push(usuario);
    return usuario.id;
  }
  
  obtener(id: number): any {
    eturn this.usuarios.find(u => u.id === id);
  }
  
  obtenerTodos(): any[] {
    return [...this.usuarios];
  }
}

// Fixtures - Datos predefinidos
const fictura_usuarios = {
  juan: { nombre: 'Juan', email: 'juan@example.com', edad: 30 },
  ana: { nombre: 'Ana', email: 'ana@example.com', edad: 28 },
  carlos: { nombre: 'Carlos', email: 'carlos@example.com', edad: 35 }
};

const fixture_productos = {
  laptop: { nombre: 'Laptop', precio: 1000, stock: 5 },
  mouse: { nombre: 'Mouse', precio: 25, stock: 100 },
  teclado: { nombre: 'Teclado', precio: 75, stock: 50 }
};

describe('RepositorioUsuarios - Con Fixtures', () => {
  let repo: RepositorioUsuarios;
  
  beforeEach(() => {
    repo = new RepositorioUsuarios();
    // Preparar fixtures
    repo.agregar(fictura_usuarios.juan);
    repo.agregar(fictura_usuarios.ana);
    repo.agregar(fictura_usuarios.carlos);
  });
  
  it('debe obtener usuario Juan', () => {
    const usuario = repo.obtener(1);
    expect(usuario.nombre).to.equal('Juan');
  });
  
  it('debe obtener usuario Ana', () => {
    const usuario = repo.obtener(2);
    expect(usuario.nombre).to.equal('Ana');
  });
  
  it('debe tener 3 usuarios en total', () => {
    const todos = repo.obtenerTodos();
    expect(todos).to.have.lengthOf(3);
  });
});
----

==== Factories: Generadores de Objetos

Las factories crean objetos de prueba con valores por defecto.

.Ejemplo:
[source,typescript]
----
import { expect } from 'chai';

interface Usuario {
  id?: number;
  nombre: string;
  email: string;
  edad: number;
  activo: boolean;
}

// Factory para crear usuarios
class UsuarioFactory {
  static crear(overrides?: Partial<Usuario>): Usuario {
    const usuario: Usuario = {
      nombre: 'Usuario Genérico',
      email: 'usuario@example.com',
      edad: 25,
      activo: true
    };
    
    return { ...usuario, ...overrides };
  }
  
  static crearLotes(cantidad: number, overrides?: Partial<Usuario>): Usuario[] {
    const usuarios: Usuario[] = [];
    for (let i = 0; i < cantidad; i++) {
      usuarios.push(
        this.crear({
          ...overrides,
          nombre: overrides?.nombre || `Usuario ${i + 1}`,
          email: overrides?.email || `usuario${i + 1}@example.com`
        })
      );
    }
    return usuarios;
  }
}

describe('UsuarioFactory - Generadores', () => {
  it('debe crear usuario con defaults', () => {
    const usuario = UsuarioFactory.crear();
    
    expect(usuario.nombre).to.equal('Usuario Genérico');
    expect(usuario.edad).to.equal(25);
    expect(usuario.activo).to.be.true;
  });
  
  it('debe crear usuario con overrides', () => {
    const usuario = UsuarioFactory.crear({
      nombre: 'Juan',
      edad: 30
    });
    
    expect(usuario.nombre).to.equal('Juan');
    expect(usuario.edad).to.equal(30);
    expect(usuario.email).to.equal('usuario@example.com'); // Default
  });
  
  it('debe crear múltiples usuarios', () => {
    const usuarios = UsuarioFactory.crearLotes(5);
    
    expect(usuarios).to.have.lengthOf(5);
    expect(usuarios[0].nombre).to.equal('Usuario 1');
    expect(usuarios[4].nombre).to.equal('Usuario 5');
  });
  
  it('debe crear lotes con overrides personalizados', () => {
    const usuarios = UsuarioFactory.crearLotes(3, { edad: 40 });
    
    expect(usuarios).to.have.lengthOf(3);
    usuarios.forEach(u => {
      expect(u.edad).to.equal(40);
    });
  });
});
----

==== Builders: Construcción Fluida

Los builders permiten construir objetos complejos paso a paso.

.Ejemplo:
[source,typescript]
----
import { expect } from 'chai';

interface Carrito {
  id: string;
  usuario: string;
  items: Array<{ productoId: number; cantidad: number; precio: number }>;
  descuento: number;
  estado: 'abierto' | 'procesando' | 'completado';
}

// Builder fluido para Carrito
class CarritoBuilder {
  private carrito: Carrito = {
    id: `carrito_${Date.now()}`,
    usuario: 'usuario_genérico',
    items: [],
    descuento: 0,
    estado: 'abierto'
  };
  
  conUsuario(usuario: string): CarritoBuilder {
    this.carrito.usuario = usuario;
    return this;
  }
  
  agregarItem(productoId: number, cantidad: number, precio: number): CarritoBuilder {
    this.carrito.items.push({ productoId, cantidad, precio });
    return this;
  }
  
  conDescuento(descuento: number): CarritoBuilder {
    this.carrito.descuento = descuento;
    return this;
  }
  
  enEstado(estado: Carrito['estado']): CarritoBuilder {
    this.carrito.estado = estado;
    return this;
  }
  
  construir(): Carrito {
    return { ...this.carrito };
  }
}

describe('CarritoBuilder - Construcción Fluida', () => {
  it('debe construir carrito complejo con fluent API', () => {
    const carrito = new CarritoBuilder()
      .conUsuario('juan@example.com')
      .agregarItem(1, 2, 99.99)  // Laptop x2
      .agregarItem(2, 1, 25.00)  // Mouse x1
      .conDescuento(10)           // 10% descuento
      .enEstado('procesando')
      .construir();
    
    expect(carrito.usuario).to.equal('juan@example.com');
    expect(carrito.items).to.have.lengthOf(2);
    expect(carrito.descuento).to.equal(10);
    expect(carrito.estado).to.equal('procesando');
  });
  
  it('debe construir carritos diferentes independientemente', () => {
    const carrito1 = new CarritoBuilder()
      .conUsuario('juan@example.com')
      .agregarItem(1, 1, 100)
      .construir();
    
    const carrito2 = new CarritoBuilder()
      .conUsuario('ana@example.com')
      .agregarItem(2, 2, 50)
      .agregarItem(3, 1, 75)
      .construir();
    
    expect(carrito1.usuario).to.equal('juan@example.com');
    expect(carrito1.items).to.have.lengthOf(1);
    
    expect(carrito2.usuario).to.equal('ana@example.com');
    expect(carrito2.items).to.have.lengthOf(2);
  });
});
----

==== Reset de Estado

Limpiar completamente el estado entre tests.

.Ejemplo:
[source,typescript]
----
import { expect } from 'chai';

class BaseDatos {
  private datos: Map<string, any[]> = new Map();
  
  insert(tabla: string, registro: any): void {
    if (!this.datos.has(tabla)) {
      this.datos.set(tabla, []);
    }
    this.datos.get(tabla)!.push(registro);
  }
  
  select(tabla: string): any[] {
    return this.datos.get(tabla) || [];
  }
  
  count(tabla: string): number {
    return (this.datos.get(tabla) || []).length;
  }
  
  // Limpiar base de datos
  reset(): void {
    this.datos.clear();
  }
}

describe('BaseDatos - Reset de Estado', () => {
  let db: BaseDatos;
  
  beforeEach(() => {
    db = new BaseDatos();
  });
  
  afterEach(() => {
    // Limpiar completamente
    db.reset();
  });
  
  it('debe insertar registro', () => {
    db.insert('usuarios', { id: 1, nombre: 'Juan' });
    expect(db.count('usuarios')).to.equal(1);
  });
  
  it('debe empezar limpio gracias a reset', () => {
    // Los datos del test anterior se limpiaron
    expect(db.count('usuarios')).to.equal(0);
    
    db.insert('usuarios', { id: 1, nombre: 'Ana' });
    expect(db.count('usuarios')).to.equal(1);
  });
  
  it('debe manejar múltiples tablas', () => {
    db.insert('usuarios', { id: 1 });
    db.insert('productos', { id: 1 });
    
    expect(db.count('usuarios')).to.equal(1);
    expect(db.count('productos')).to.equal(1);
  });
});
----

---

=== 8.2 Database Mocking

==== Mockear Conexiones de Base de Datos

No debería ejecutarse contra BD real en tests. Usar stubs de Sinon.

.Ejemplo:
[source,typescript]
----
import sinon from 'sinon';
import { expect } from 'chai';

class ConexionBD {
  conectar(): Promise<void> {
    throw new Error('No debería conectarse en test');
  }
}

class RepositorioProductos {
  constructor(private conexion: ConexionBD) {}
  
  async obtener(id: number): Promise<any> {
    await this.conexion.conectar();
    // Ejecutaría query en BD real
    return { id, nombre: 'Laptop' };
  }
}

describe('RepositorioProductos - BD Mocking', () => {
  let conexion: ConexionBD;
  let repo: RepositorioProductos;
  let stub: sinon.SinonStub;
  
  beforeEach(() => {
    conexion = new ConexionBD();
    repo = new RepositorioProductos(conexion);
  });
  
  afterEach(() => {
    if (stub) stub.restore();
  });
  
  it('debe obtener producto sin conectar a BD real', async () => {
    // Stub la conexión
    stub = sinon.stub(conexion, 'conectar').resolves();
    
    const producto = await repo.obtener(1);
    
    expect(producto.nombre).to.equal('Laptop');
    expect(stub.called).to.be.true;
  });
});
----

==== Database en Memoria

Usar una base de datos en memoria para tests rápidos.

.Ejemplo con Map simple:
[source,typescript]
----
import { expect } from 'chai';

// BD en memoria
class RepositorioEnMemoria<T extends { id: number }> {
  private datos = new Map<number, T>();
  private proximoId = 1;
  
  guardar(item: Omit<T, 'id'>): T {
    const id = this.proximoId++;
    const conId = { ...item, id } as T;
    this.datos.set(id, conId);
    return conId;
  }
  
  obtener(id: number): T | undefined {
    return this.datos.get(id);
  }
  
  obtenerTodos(): T[] {
    return Array.from(this.datos.values());
  }
  
  actualizar(id: number, actualizaciones: Partial<T>): T {
    const item = this.datos.get(id);
    if (!item) throw new Error('No encontrado');
    
    const actualizado = { ...item, ...actualizaciones } as T;
    this.datos.set(id, actualizado);
    return actualizado;
  }
  
  eliminar(id: number): boolean {
    return this.datos.delete(id);
  }
  
  limpiar(): void {
    this.datos.clear();
    this.proximoId = 1;
  }
}

interface Usuario {
  id: number;
  nombre: string;
  email: string;
}

describe('RepositorioEnMemoria - CRUD', () => {
  let repo: RepositorioEnMemoria<Usuario>;
  
  beforeEach(() => {
    repo = new RepositorioEnMemoria<Usuario>();
  });
  
  it('debe guardar y obtener usuario', () => {
    const usuario = repo.guardar({ nombre: 'Juan', email: 'juan@example.com' });
    
    expect(usuario.id).to.equal(1);
    expect(usuario.nombre).to.equal('Juan');
    
    const obtenido = repo.obtener(1);
    expect(obtenido).to.deep.equal(usuario);
  });
  
  it('debe incrementar IDs automáticamente', () => {
    const u1 = repo.guardar({ nombre: 'Juan', email: 'juan@example.com' });
    const u2 = repo.guardar({ nombre: 'Ana', email: 'ana@example.com' });
    const u3 = repo.guardar({ nombre: 'Carlos', email: 'carlos@example.com' });
    
    expect(u1.id).to.equal(1);
    expect(u2.id).to.equal(2);
    expect(u3.id).to.equal(3);
  });
  
  it('debe actualizar usuario', () => {
    repo.guardar({ nombre: 'Juan', email: 'juan@example.com' });
    
    const actualizado = repo.actualizar(1, { nombre: 'Juan Updated' });
    
    expect(actualizado.nombre).to.equal('Juan Updated');
    expect(actualizado.id).to.equal(1); // ID no cambia
  });
  
  it('debe eliminar usuario', () => {
    repo.guardar({ nombre: 'Juan', email: 'juan@example.com' });
    expect(repo.obtenerTodos()).to.have.lengthOf(1);
    
    const eliminado = repo.eliminar(1);
    
    expect(eliminado).to.be.true;
    expect(repo.obtenerTodos()).to.have.lengthOf(0);
  });
  
  it('debe limpiar completamente', () => {
    repo.guardar({ nombre: 'Juan', email: 'juan@example.com' });
    repo.guardar({ nombre: 'Ana', email: 'ana@example.com' });
    
    expect(repo.obtenerTodos()).to.have.lengthOf(2);
    
    repo.limpiar();
    
    expect(repo.obtenerTodos()).to.have.lengthOf(0);
  });
});
----

==== Transacciones en Tests

Simular comportamiento transaccional.

.Ejemplo:
[source,typescript]
----
import { expect } from 'chai';

class TransaccionBD {
  private datos: any[] = [];
  private snapshot: any[] = [];
  
  iniciar(): void {
    // Hacer snapshot del estado actual
    this.snapshot = JSON.parse(JSON.stringify(this.datos));
  }
  
  commit(): void {
    // Cambios persisten, limpiar snapshot
    this.snapshot = [];
  }
  
  rollback(): void {
    // Restaurar snapshot
    this.datos = JSON.parse(JSON.stringify(this.snapshot));
    this.snapshot = [];
  }
  
  insert(registro: any): void {
    this.datos.push(registro);
  }
  
  select(): any[] {
    return this.datos;
  }
}

describe('TransaccionBD - Rollback', () => {
  let txn: TransaccionBD;
  
  beforeEach(() => {
    txn = new TransaccionBD();
    txn.insert({ id: 1, valor: 100 });
  });
  
  it('debe commit cambios', () => {
    txn.iniciar();
    txn.insert({ id: 2, valor: 200 });
    
    expect(txn.select()).to.have.lengthOf(2);
    
    txn.commit();
    
    expect(txn.select()).to.have.lengthOf(2);
  });
  
  it('debe rollback cambios fallidos', () => {
    txn.iniciar();
    txn.insert({ id: 2, valor: 200 });
    txn.insert({ id: 3, valor: 300 });
    
    expect(txn.select()).to.have.lengthOf(3);
    
    txn.rollback();
    
    expect(txn.select()).to.have.lengthOf(1);
  });
});
----

---

=== 8.3 API Mocking

==== HTTP Mocking con Nock

Nock permite mockear requests HTTP sin hacer llamadas reales.

.Instalación:
[source,bash]
----
npm install --save-dev nock
npm install --save-dev @types/nock
----

.Ejemplo:
[source,typescript]
----
import nock from 'nock';
import { expect } from 'chai';

class ClienteAPI {
  async obtenerUsuario(id: number): Promise<any> {
    const respuesta = await fetch(`https://api.example.com/usuarios/${id}`);
    if (!respuesta.ok) throw new Error('No encontrado');
    return respuesta.json();
  }
  
  async crearUsuario(datos: any): Promise<any> {
    const respuesta = await fetch('https://api.example.com/usuarios', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(datos)
    });
    return respuesta.json();
  }
}

describe('ClienteAPI - Nock HTTP Mocking', () => {
  afterEach(() => {
    nock.cleanAll();
  });
  
  it('debe mockear GET request', async () => {
    // Preparar mock
    nock('https://api.example.com')
      .get('/usuarios/1')
      .reply(200, { id: 1, nombre: 'Juan' });
    
    const cliente = new ClienteAPI();
    const usuario = await cliente.obtenerUsuario(1);
    
    expect(usuario.nombre).to.equal('Juan');
  });
  
  it('debe mockear POST request', async () => {
    nock('https://api.example.com')
      .post('/usuarios', { nombre: 'Ana', email: 'ana@example.com' })
      .reply(201, { id: 2, nombre: 'Ana', email: 'ana@example.com' });
    
    const cliente = new ClienteAPI();
    const usuario = await cliente.crearUsuario({
      nombre: 'Ana',
      email: 'ana@example.com'
    });
    
    expect(usuario.id).to.equal(2);
  });
  
  it('debe mockear error 404', async () => {
    nock('https://api.example.com')
      .get('/usuarios/999')
      .reply(404, { error: 'No encontrado' });
    
    const cliente = new ClienteAPI();
    
    try {
      await cliente.obtenerUsuario(999);
      throw new Error('Debería haber fallado');
    } catch (err) {
      expect(err.message).to.include('No encontrado');
    }
  });
});
----

==== Fixture Files (Datos en Archivos)

Separar datos de prueba en archivos JSON.

.Estructura:
[source]
----
tests/
  fixtures/
    usuario-valido.json
    usuario-invalido.json
    productos.json
  mocks/
    api.test.ts
----

.fixtures/usuario-valido.json:
[source,json]
----
{
  "id": 1,
  "nombre": "Juan",
  "email": "juan@example.com",
  "activo": true
}
----

.fixtures/productos.json:
[source,json]
----
[
  { "id": 1, "nombre": "Laptop", "precio": 1000 },
  { "id": 2, "nombre": "Mouse", "precio": 25 },
  { "id": 3, "nombre": "Teclado", "precio": 75 }
]
----

.Uso en tests:
[source,typescript]
----
import * as fs from 'fs';
import * as path from 'path';
import { expect } from 'chai';

// Helper para cargar fixtures
function cargarFixture(nombre: string): any {
  const ruta = path.join(__dirname, 'fixtures', `${nombre}.json`);
  const contenido = fs.readFileSync(ruta, 'utf-8');
  return JSON.parse(contenido);
}

describe('API - Fixtures desde Archivos', () => {
  it('debe validar usuario desde fixture', () => {
    const usuario = cargarFixture('usuario-valido');
    
    expect(usuario.id).to.equal(1);
    expect(usuario.nombre).to.equal('Juan');
    expect(usuario.activo).to.be.true;
  });
  
  it('debe cargar múltiples productos', () => {
    const productos = cargarFixture('productos');
    
    expect(productos).to.have.lengthOf(3);
    expect(productos[0].nombre).to.equal('Laptop');
    expect(productos[1].precio).to.equal(25);
  });
});
----

==== Stub de Librerías HTTP

Usar Sinon para stubear librerías HTTP sin Nock.

.Ejemplo:
[source,typescript]
----
import sinon from 'sinon';
import { expect } from 'chai';
import axios from 'axios'; // Supongamos que usamos axios

class ServicioProductos {
  async obtenerProducto(id: number): Promise<any> {
    const respuesta = await axios.get(`/api/productos/${id}`);
    return respuesta.data;
  }
}

describe('ServicioProductos - Stub de Axios', () => {
  let stub: sinon.SinonStub;
  
  afterEach(() => {
    if (stub) stub.restore();
  });
  
  it('debe obtener producto mediante axios stub', async () => {
    stub = sinon.stub(axios, 'get').resolves({
      data: { id: 1, nombre: 'Laptop', precio: 1000 }
    });
    
    const servicio = new ServicioProductos();
    const producto = await servicio.obtenerProducto(1);
    
    expect(producto.nombre).to.equal('Laptop');
    expect(stub.calledWith('/api/productos/1')).to.be.true;
  });
  
  it('debe manejar error de axios', async () => {
    const error = new Error('Conexión rechazada');
    stub = sinon.stub(axios, 'get').rejects(error);
    
    const servicio = new ServicioProductos();
    
    try {
      await servicio.obtenerProducto(999);
      throw new Error('Debería haber fallado');
    } catch (err) {
      expect(err.message).to.equal('Conexión rechazada');
    }
  });
});
----

==== Ejemplo Integrado: E-commerce

[source,typescript]
----
// src/ecommerce.ts
export class ServicioEcommerce {
  constructor(
    private repositorioProductos: any,
    private clienteAPI: any
  ) {}
  
  async procesarCompra(usuarioId: number, productoIds: number[]): Promise<any> {
    // Obtener usuario de API
    const usuario = await this.clienteAPI.obtenerUsuario(usuarioId);
    
    // Obtener productos del repositorio
    const productos = await Promise.all(
      productoIds.map(id => this.repositorioProductos.obtener(id))
    );
    
    // Calcular total
    const total = productos.reduce((s: number, p: any) => s + p.precio, 0);
    
    return {
      usuario: usuario.nombre,
      productos: productos.length,
      total
    };
  }
}
----

.Tests completos:
[source,typescript]
----
import sinon from 'sinon';
import nock from 'nock';
import { expect } from 'chai';
import { ServicioEcommerce } from '../src/ecommerce';

describe('ServicioEcommerce - Integración Fixtures', () => {
  let servicio: ServicioEcommerce;
  let repositorio: any;
  let clienteAPI: any;
  
  beforeEach(() => {
    // Repositorio en memoria
    repositorio = {
      obtener: async (id: number) => {
        const productos: any = {
          1: { id: 1, nombre: 'Laptop', precio: 1000 },
          2: { id: 2, nombre: 'Mouse', precio: 25 },
          3: { id: 3, nombre: 'Teclado', precio: 75 }
        };
        return productos[id];
      }
    };
    
    // Mock de API HTTP
    clienteAPI = {
      obtenerUsuario: async (id: number) => {
        return { id, nombre: 'Juan' };
      }
    };
    
    servicio = new ServicioEcommerce(repositorio, clienteAPI);
  });
  
  afterEach(() => {
    nock.cleanAll();
  });
  
  it('debe procesar compra completa', async () => {
    const result = await servicio.procesarCompra(1, [1, 2]);
    
    expect(result.usuario).to.equal('Juan');
    expect(result.productos).to.equal(2);
    expect(result.total).to.equal(1025);
  });
  
  it('debe manejar múltiples compras', async () => {
    const compra1 = await servicio.procesarCompra(1, [1]);
    const compra2 = await servicio.procesarCompra(2, [2, 3]);
    
    expect(compra1.total).to.equal(1000);
    expect(compra2.total).to.equal(100);
  });
});
----

---

---

== Módulo 9: Reporters y Salida

Los reporters en Mocha controlan cómo se muestran los resultados de los tests. Desde output simple en terminal hasta reportes JSON complejos. Este módulo explora los reporters nativos, cómo crear personalizados y configurar la salida.

=== 9.1 Reporters Nativos

Mocha incluye varios reporters listos para usar.

==== Elegir un Reporter

.Sintaxis:
[source,bash]
----
mocha --reporter <nombre>
----

.Reporters disponibles:
[cols="1,2"]
====
| Reporter | Descripción

| `spec` | Formato jerárquico detallado (por defecto)
| `dot` | Puntos verdes/rojos, muy compacto
| `tap` | Test Anything Protocol para herramientas CI
| `json` | JSON puro para procesamiento
| `json-stream` | JSON línea por línea
| `nyan` | ASCII art (lúdico)
| `markdown` | Output en formato Markdown
| `min` | Mínimo, solo resumen
| `l=anding` | Animación de "landing"
====

==== Spec Reporter (Por Defecto)

Es el más legible. Muestra estructura jerárquica con checkmarks y cross marks.

.Ejemplo de output:
[source]
----
  Calculadora
    ✓ debe sumar dos números
    ✓ debe restar dos números
    ✓ debe multiplicar dos números
    ✗ debe dividir por cero correctamente
    
  4 passing (15ms)
  1 failing
----

.Ejecutar con spec reporter:
[source,bash]
----
mocha --reporter spec
npx mocha tests/**/*.test.ts --require ts-node/register --reporter spec
----

==== Dot Reporter

Muy compacto. Un punto por test: verde si pasa, rojo si falla.

.Ejemplo de output:
[source]
----
  .....✖.

  8 passing
  1 failing
----

.Ejecutar:
[source,bash]
----
mocha --reporter dot
----

==== JSON Reporter

Perfecto para procesamiento automático y herramientas CI/CD.

.Ejemplo:
[source,bash]
----
mocha --reporter json > results.json
----

.Contenido de results.json:
[source,json]
----
{
  "stats": {
    "tests": 9,
    "passes": 8,
    "failures": 1,
    "pending": 0,
    "skipped": 0,
    "duration": 15
  },
  "tests": [
    {
      "title": "debe sumar dos números",
      "fullTitle": "Calculadora debe sumar dos números",
      "state": "passed",
      "duration": 2
    },
    {
      "title": "debe multiplicar por cero",
      "fullTitle": "Calculadora debe multiplicar por cero",
      "state": "failed",
      "duration": 5,
      "err": {
        "message": "expected 0 to equal 1"
      }
    }
  ]
}
----

.Procesar JSON en terminal:
[source,bash]
----
mocha --reporter json | jq '.stats'
mocha --reporter json | jq '.tests[] | select(.state == "failed")'
----

==== TAP Reporter

TAP (Test Anything Protocol) para herramientas CI estándar.

.Ejemplo de output:
[source]
----
1..9
ok 1 - Calculadora debe sumar dos números
ok 2 - Calculadora debe restar dos números
ok 3 - Calculadora debe multiplicar dos números
not ok 4 - Calculadora debe dividir correctamente
  ---
  message: expected 0 to equal 1
  ...
ok 5 - Calculadora debe obtener raíz cuadrada
----

.Ejecutar:
[source,bash]
----
mocha --reporter tap > results.tap
----

==== Markdown Reporter

Genera output en formato Markdown.

.Ejemplo:
[source,bash]
----
mocha --reporter markdown > results.md
----

.Contenido generado:
[source,markdown]
----
# Mocha Tests

## Passing

- ✓ Calculadora debe sumar dos números
- ✓ Calculadora debe restar dos números
- ✓ Calculadora debe multiplicar dos números

## Failing

### 1) Calculadora debe dividir correctamente
  expected 0 to equal 1
----

==== Configurar Reporter Predeterminado

.En .mocharc.json:
[source,json]
----
{
  "reporter": "spec",
  "require": ["ts-node/register"],
  "spec": "tests/**/*.test.ts"
}
----

.En .mocharc.js:
[source,javascript]
----
module.exports = {
  reporter: 'dot',
  reporterOptions: {
    reportDir: './test-results'
  }
};
----

---

=== 9.2 Reporters Personalizados

==== Estructura de un Reporter Personalizado

Un reporter es una clase que extiende de EventEmitter y responde a eventos de Mocha.

.Eventos principales:
[cols="1,2"]
====
| Evento | Se dispara cuando...

| `start` | Comienzan todos los tests
| `suite` | Comienza un suite
| `test` | Comienza un test
| `pass` | Un test pasó
| `fail` | Un test falló
| `pending` | Un test está pendiente
| `end` | Finalizan todos los tests
====

.Ejemplo básico:
[source,typescript]
----
// reporters/miReporter.ts
import { EventEmitter } from 'events';

export class MiReporter extends EventEmitter {
  constructor(runner: any) {
    super();
    
    let testCount = 0;
    let passCount = 0;
    let failCount = 0;
    
    runner.on('test', () => {
      testCount++;
    });
    
    runner.on('pass', (test: any) => {
      passCount++;
      console.log(`✓ ${test.title}`);
    });
    
    runner.on('fail', (test: any, err: any) => {
      failCount++;
      console.log(`✗ ${test.title}: ${err.message}`);
    });
    
    runner.on('end', () => {
      console.log(`\n${passCount}/${testCount} tests pasaron`);
      if (failCount > 0) {
        console.log(`${failCount} tests fallaron`);
      }
    });
  }
}

// Exportar como función (Mocha espera así)
module.exports = MiReporter;
----

.Usar el reporter personalizado:
[source,bash]
----
mocha --reporter ./reporters/miReporter.ts tests/**/*.test.ts
----

==== Reporter con Estadísticas Detalladas

[source,typescript]
----
// reporters/estadisticasReporter.ts
import { EventEmitter } from 'events';
import * as chalk from 'chalk'; // npm install chalk

export class EstadisticasReporter extends EventEmitter {
  private tests: any[] = [];
  private passIds: number[] = [];
  private failIds: number[] = [];
  private estadisticasPorSuite: Map<string, any> = new Map();
  private suiteCurrent: string[] = [];
  
  constructor(runner: any) {
    super();
    
    runner.on('suite', (suite: any) => {
      if (suite.title) {
        this.suiteCurrent.push(suite.title);
      }
    });
    
    runner.on('suite end', (suite: any) => {
      if (suite.title) {
        this.suiteCurrent.pop();
      }
    });
    
    runner.on('test', (test: any) => {
      test.id = this.tests.length;
      this.tests.push(test);
    });
    
    runner.on('pass', (test: any) => {
      this.passIds.push(test.id);
      const suitePath = this.suiteCurrent.join(' > ');
      console.log(chalk.green(`  ✓ ${test.title}`));
    });
    
    runner.on('fail', (test: any, err: any) => {
      this.failIds.push(test.id);
      const suitePath = this.suiteCurrent.join(' > ');
      console.log(chalk.red(`  ✗ ${test.title}`));
      console.log(chalk.red(`    ${err.message}`));
    });
    
    runner.on('end', () => {
      const total = this.tests.length;
      const passed = this.passIds.length;
      const failed = this.failIds.length;
      const porcentaje = total > 0 ? ((passed / total) * 100).toFixed(2) : 0;
      
      onsole.log('\n' + chalk.bold('=== RESUMEN DE ESTADÍSTICAS ==='));
      console.log(chalk.green(`Pasando: ${passed}`));
      console.log(chalk.red(`Fallando: ${failed}`));
      console.log(chalk.blue(`Total: ${total}`));
      console.log(chalk.yellow(`Tasa de éxito: ${porcentaje}%`));
    });
  }
}

module.exports = EstadisticasReporter;
----

==== Reporter JSON Personalizado

Generar JSON con formato personalizado.

[source,typescript]
----
// reporters/jsonPersonalizadoReporter.ts
import { EventEmitter } from 'events';
import * as fs from 'fs';

export class JSONPersonalizadoReporter extends EventEmitter {
  private resultados: any = {
    timestamp: new Date().toISOString(),
    suites: [],
    tests: [],
    statistics: {
      total: 0,
      passed: 0,
      failed: 0,
      pending: 0
    }
  };
  
  private suiteCurrent: string[] = [];
  
  constructor(runner: any, options?: any) {
    super();
    
    const outputFile = options?.reporterOptions?.outputFile || 'test-results.json';
    
    runner.on('test', (test: any) => {
      this.resultados.statistics.total++;
    });
    
    runner.on('pass', (test: any) => {
      this.resultados.statistics.passed++;
      this.resultados.tests.push({
        title: test.title,
        fullTitle: test.fullTitle(),
        state: 'passed',
        duration: test.duration
      });
    });
    
    runner.on('fail', (test: any, err: any) => {
      this.resultados.statistics.failed++;
      this.resultados.tests.push({
        title: test.title,
        fullTitle: test.fullTitle(),
        state: 'failed',
        duration: test.duration,
        error: {
          message: err.message,
          stack: err.stack
        }
      });
    });
    
    runner.on('pending', (test: any) => {
      this.resultados.statistics.pending++;
      this.resultados.tests.push({
        title: test.title,
        fullTitle: test.fullTitle(),
        state: 'pending'
      });
    });
    
    runner.on('end', () => {
      fs.writeFileSync(outputFile, JSON.stringify(this.resultados, null, 2));
      console.log(`\nResultados guardados en: ${outputFile}`);
    });
  }
}

module.exports = JSONPersonalizadoReporter;
----

.Usar con opciones:
[source,bash]
----
mocha --reporter ./reporters/jsonPersonalizadoReporter.ts \
  --reporter-options outputFile=resultados.json
----

==== Reporter HTML

Generar reporte HTML visual.

[source,typescript]
----
// reporters/htmlReporter.ts
import { EventEmitter } from 'events';
import * as fs from 'fs';

export class HTMLReporter extends EventEmitter {
  private html = '';
  private tests: any[] = [];
  
  constructor(runner: any, options?: any) {
    super();
    
    const outputFile = options?.reporterOptions?.outputFile || 'test-report.html';
    
    runner.on('test', (test: any) => {
      test.id = this.tests.length;
      this.tests.push(test);
    });
    
    runner.on('pass', (test: any) => {
      this.tests[test.id].state = 'passed';
    });
    
    runner.on('fail', (test: any, err: any) => {
      this.tests[test.id].state = 'failed';
      this.tests[test.id].error = err.message;
    });
    
    runner.on('end', () => {
      const html = this.generarHTML();
      fs.writeFileSync(outputFile, html);
      console.log(`\nReporte HTML guardado en: ${outputFile}`);
    });
  }
  
  private generarHTML(): string {
    onst passed = this.tests.filter(t => t.state === 'passed').length;
    onst failed = this.tests.filter(t => t.state === 'failed').length;
    const total = this.tests.length;
    
    let testHTML = '';
    for (const test of this.tests) {
      onst icon = test.state === 'passed' ? '✓' : '✗';
      onst color = test.state === 'passed' ? 'green' : 'red';
      
      testHTML += `
        tr style="background-color: ${color === 'green' ? '#e8f5e9' : '#ffebee'}">
          <td>${icon}</td>
          <td>${test.title}</td>
          <td>${test.state}</td>
          <td>${test.duration || 0}ms</td>
          ${test.error ? `<td><code>${test.error}</code></td>` : '<td>—</td>'}
        </tr>
      `;
    }
    
    return `
      <!DOCTYPE html>
      <html>
        <head>
          <title>Mocha Test Report</title>
          <style>
            body { font-family: Arial, sans-serif; margin: 20px; }
            .stats { display: flex; gap: 20px; margin-bottom: 20px; }
            .stat { padding: 10px 20px; border-radius: 5px; }
            .passed { background-color: #c8e6c9; }
            .failed { background-color: #ffcdd2; }
            .total { background-color: #bbdefb; }
            table { border-collapse: collapse; width: 100%; }
            th, td { border: 1px solid #ddd; padding: 10px; text-align: left; }
            th { background-color: #f5f5f5; font-weight: bold; }
          </style>
        </head>
        <body>
          <h1>Test Report</h1>
          <div class="stats">
            <div class="stat passed">Pasando: <strong>${passed}</strong></div>
            <div class="stat failed">Fallando: <strong>${failed}</strong></div>
            <div class="stat total">Total: <strong>${total}</strong></div>
          </div>
          <table>
            <thead>
              <tr>
                <th>Estado</th>
                <th>Test</th>
                <th>Resultado</th>
                <th>Duración</th>
                <th>Detalles</th>
              </tr>
            </thead>
            <tbody>
              ${testHTML}
            </tbody>
          </table>
        </body>
      </html>
    `;
  }
}

module.exports = HTMLReporter;
----

---

=== 9.3 Configuración de Salida

==== Colores en Output

Mocha detecta automáticamente si la terminal soporta colores. Puede forzarse:

.Con línea de comandos:
[source,bash]
----
mocha --colors                    # Forzar colores
mocha --no-colors                 # Sin colores
mocha --reporter spec --colors    # Especificar reporter + colores
----

.En .mocharc.json:
[source,json]
----
{
  "reporter": "spec",
  "colors": true,
  "require": ["ts-node/register"]
}
----

==== Verbosidad de Output

Controlar cuánta información se muestra.

.Ejemplo básico (sin verbosidad):
[source]
----
  5 passing
----

.Con --reporter spec (verbose):
[source]
----
  Calculadora
    ✓ debe sumar dos números (2ms)
    ✓ debe restar dos números (1ms)
    ✓ debe multiplicar dos números (1ms)
----

.Cambiar verbosidad manualmente:
[source,bash]
----
mocha --reporter min           # Mínimo, solo resumen
mocha --reporter spec          # Detallado
mocha --reporter tap           # TAP format (otro nivel de verbosidad)
----

==== Controlar Salida Estándar

Capturar stdout/stderr en tests:

[source,typescript]
----
import { expect } from 'chai';
import * as sinon from 'sinon';

describe('Output Capture', () => {
  it('debe capturar console.log', () => {
    const logStub = sinon.stub(console, 'log');
    
    console.log('Mensaje importante');
    
    expect(logStub.calledWith('Mensaje importante')).to.be.true;
    
    logStub.restore();
  });
  
  it('debe capturar console.error', () => {
    const errorStub = sinon.stub(console, 'error');
    
    console.error('Error detectado');
    
    expect(errorStub.called).to.be.true;
    
    errorStub.restore();
  });
});
----

==== Configurar Opciones del Reporter

.En .mocharc.json:
[source,json]
----
{
  "reporter": "spec",
  "reporterOptions": {
    "reportDir": "./test-results",
    "reportFilename": "index.html"
  },
  "colors": true,
  "slow": 300,
  "timeout": 5000
}
----

.En línea de comandos:
[source,bash]
----
mocha \
  --reporter spec \
  --reporter-options reportDir=./reports \
  --slow 300 \
  --timeout 5000
----

==== Ejemplo Integrado: Reporter Completo

[source,typescript]
----
// reporters/completoReporter.ts
import { EventEmitter } from 'events';
import * as fs from 'fs';
import * as path from 'path';

export class ReporterCompleto extends EventEmitter {
  private resultados: any = {
    timestamp: new Date().toISOString(),
    environment: {
      node: process.version,
      platform: process.platform
    },
    tests: [],
    statistics: {
      total: 0,
      passed: 0,
      failed: 0,
      pending: 0,
      duration: 0
    }
  };
  
  private inicioTotal: number = Date.now();
  private testActual: any;
  
  constructor(runner: any, options?: any) {
    super();
    
    const outputDir = options?.reporterOptions?.outputDir || './test-results';
    const outputFile = path.join(outputDir, 'report.json');
    
    // Crear directorio si no existe
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    runner.on('test', (test: any) => {
      this.testActual = {
        title: test.title,
        fullTitle: test.fullTitle(),
        startTime: Date.now()
      };
      this.resultados.statistics.total++;
    });
    
    runner.on('pass', (test: any) => {
      this.resultados.statistics.passed++;
      this.testActual.state = 'passed';
      this.testActual.duration = Date.now() - this.testActual.startTime;
      this.resultados.tests.push(this.testActual);
      console.log(`✓ ${test.title} (${this.testActual.duration}ms)`);
    });
    
    runner.on('fail', (test: any, err: any) => {
      this.resultados.statistics.failed++;
      this.testActual.state = 'failed';
      this.testActual.duration = Date.now() - this.testActual.startTime;
      this.testActual.error = {
        message: err.message,
        stack: err.stack
      };
      this.resultados.tests.push(this.testActual);
      console.log(`✗ ${test.title}`);
      console.log(`  ${err.message}`);
    });
    
    runner.on('pending', (test: any) => {
      this.resultados.statistics.pending++;
      console.log(`⊘ ${test.title} (pendiente)`);
    });
    
    runner.on('end', () => {
      this.resultados.statistics.duration = Date.now() - this.inicioTotal;
      
      // Guardar JSON
      fs.writeFileSync(outputFile, JSON.stringify(this.resultados, null, 2));
      
      // Mostrar resumen
      this.mostrarResumen();
      
      console.log(`\nReporte completo guardado en: ${outputFile}`);
    });
  }
  
  private mostrarResumen(): void {
    const { passed, failed, total, duration } = this.resultados.statistics;
    const porcentaje = total > 0 ? ((passed / total) * 100).toFixed(2) : 0;
    
    console.log('\n' + '='.repeat(50));
    console.log('RESUMEN DE TESTS');
    console.log('='.repeat(50));
    console.log(`Total:     ${total}`);
    console.log(`Pasado:    ${passed}`);
    console.log(`Fallido:   ${failed}`);
    console.log(`Duracion:  ${duration}ms`);
    console.log(`Exito:     ${porcentaje}%`);
    console.log('='.repeat(50));
  }
}

module.exports = ReporterCompleto;
----

.Usar:
[source,bash]
----
mocha --reporter ./reporters/completoReporter.ts \
  --reporter-options outputDir=./test-results
----

.Salida esperada:
[source]
----
✓ Calculadora debe sumar (2ms)
✓ Calculadora debe restar (1ms)
✗ Calculadora debe dividir
  expected 0 to equal 1

=================================================
RESUMEN DE TESTS
=================================================
Total:     3
Pasado:    2
Fallido:   1
Duracion:  45ms
Exito:     66.67%
=================================================

Reporte completo guardado en: ./test-results/report.json
----

---

---

== Módulo 10: Code Coverage

Code coverage mide qué porcentaje del código ha sido ejecutado durante los tests. Es una métrica importante para identificar código no probado y mejorar la calidad de los tests.

=== 10.1 Nyc - Istanbul Coverage Tool

==== ¿Qué es Code Coverage?

Code coverage responde: "¿Qué porcentaje de mi código ha sido ejecutado durante los tests?"

.Tipos de coverage:
[cols="1,2,2"]
====
| Tipo | Qué mide | Ejemplo

| *Statement* | % de sentencias ejecutadas | `const x = 5;` se ejecutó
| *Branch* | % de caminos condicionales | `if (x > 5)` se evaluó true y false
| *Function* | % de funciones llamadas | `sumar()` fue invocada
| *Line* | % de líneas ejecutadas | Línea 42 se ejecutó
====

==== Instalación de NYC

NYC =(New York Coverage) es una herramienta basada en Istanbul para medir coverage.

.Instalación:
[source,bash]
----
npm install --save-dev nyc
npm install --save-dev @types/istanbul-lib-coverage
----

==== Configuración de NYC

.En .mocharc.json:
[source,json]
----
{
  "reporter": "spec",
  "require": ["ts-node/register"],
  "spec": "tests/**/*.test.ts",
  "nyc": {
    "reporter": ["text", "html", "json"],
    "extension": [".ts"],
    "exclude": [
      "tests/**",
      "node_modules/**"
    ],
    "branches": 80,
    "lines": 80,
    "functions": 80,
    "statements": 80
  }
}
----

.O crear .nycrc.json separado:
[source,json]
----
{
  "all": true,
  "include": ["src/**/*.ts"],
  "exclude": [
    "src/**/*.test.ts",
    "src/**/*.spec.ts",
    "src/**/index.ts",
    "node_modules/**"
  ],
  "reporter": [
    "text",
    "text-summary",
    "html",
    "json",
    "lcov"
  ],
  "report-dir": "./coverage",
  "branches": 80,
  "lines": 80,
  "functions": 80,
  "statements": 80
}
----

==== Ejecutar Tests con Coverage

.Comando básico:
[source,bash]
----
nyc mocha
----

.Comando en package.json:
[source,json]
----
{
  "scripts": {
    "test": "mocha",
    "test:coverage": "nyc mocha",
    "test:coverage:report": "nyc report --reporter=html"
  }
}
----

.Ejecutar:
[source,bash]
----
npm run test:coverage
npm run test:coverage:report  # Genera reporte HTML
----

==== Ejemplo Práctico: Coverage en Acción

.Código a testear:
[source,typescript]
----
// src/calculadora.ts
export class Calculadora {
  sumar(a: number, b: number): number {
    return a + b;
  }
  
  restar(a: number, b: number): number {
    return a - b;
  }
  
  multiplicar(a: number, b: number): number {
    return a * b;
  }
  
  dividir(a: number, b: number): number {
    f (b === 0) {
      throw new Error('No se puede dividir por cero');
    }
    return a / b;
  }
  
  raizCuadrada(n: number): number {
    if (n < 0) {
      throw new Error('No se puede calcular raíz de número negativo');
    }
    return Math.sqrt(n);
  }
}
----

.Tests incompletos (bajo coverage):
[source,typescript]
----
import { expect } from 'chai';
import { Calculadora } from '../src/calculadora';

describe('Calculadora - Coverage Bajo', () => {
  let calc: Calculadora;
  
  beforeEach(() => {
    calc = new Calculadora();
  });
  
  it('debe sumar dos números', () => {
    expect(calc.sumar(2, 3)).to.equal(5);
  });
  
  it('debe restar dos números', () => {
    expect(calc.restar(5, 3)).to.equal(2);
  });
  // Solo test para sumar y restar
  // Multiplicar, dividir y raizCuadrada no están testeados!
});
----

.Coverage report:
[source]
----
------------|---------|----------|---------|---------|-------------------
File        |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Lines
------------|---------|----------|---------|---------|-------------------
All files   |    40    |    20    |    40    |    40    |
 calculadora|    40    |    20    |    40    |    40    |
  .ts       |          |          |          |          | 13,16,19,22,25
------------|---------|----------|---------|---------|-------------------

Solo 40% de statements cubiertos!
----

==== Generar Reportes HTML

NYC genera reportes HTML detallados automáticamente.

.Ejecutar coverage con HTML:
[source,bash]
----
nyc --reporter=html mocha
open coverage/index.html  # En macOS
# O navega manualmente a coverage/index.html
----

.El reporte HTML muestra:
- Porcentaje de coverage por archivo
- Código resaltado: líneas verdes (cubiertas), rojas (no cubiertas)
- Estadísticas detalladas
- Tendencia de coverage

==== Configurar Thresholds (Límites)

Establecer límites de coverage mínimos requeridos.

.En .nycrc.json:
[source,json]
----
{
  "branches": 80,        // Mínimo 80% branch coverage
  "lines": 80,           // Mínimo 80% line coverage
  "functions": 80,       // Mínimo 80% function coverage
  "statements": 80       // Mínimo 80% statement coverage
}
----

.En package.json:
[source,json]
----
{
  "scripts": {
    "test:coverage": "nyc --branches 80 --lines 80 --functions 80 mocha"
  }
}
----

Si el coverage es menor al umbral, nyc falla:

[source,bash]
----
$ npm run test:coverage
ERROR: Coverage for lines (40%) does not meet threshold (80%)
Coverage for statements (40%) does not meet threshold (80%)
----

---

=== 10.2 Análisis de Coverage

==== Statement Coverage

Mide si cada sentencia ha sido ejecutada.

.Ejemplo:
[source,typescript]
----
export function procesarPedido(monto: number): string {
  const impuesto = monto * 0.21;        // Sentencia 1
  const total = monto + impuesto;        // Sentencia 2
  
  if (total > 1000) {                    // Sentencia 3 (rama)
    return 'Envío gratis';               // Sentencia 4
  } else {
    return 'Envío: $10';                 // Sentencia 5
  }
}

describe('Statement Coverage', () => {
  it('debe procesar monto bajo', () => {
    const resultado = procesarPedido(100);
    expect(resultado).to.equal('Envío: $10');
    // Ejecuta: sentencias 1, 2, 3, 5
    // NO ejecuta: sentencia 4
    // Coverage: 4/5 = 80% statements
  });
});
----

==== Branch Coverage

Mide si todas las ramas condicionales se ejecutan.

.Ejemplo:
[source,typescript]
----
export function validarEdad(edad: number): string {
  if (edad < 0) {
    return 'Edad inválida';      // Rama 1
  } else if (edad < 18) {
    return 'Menor de edad';      // Rama 2
  } else if (edad >= 65) {
    return 'Jubilado';           // Rama 3
  } else {
    return 'Adulto activo';      // Rama 4
  }
}

describe('Branch Coverage - Incompleto', () => {
  it('debe rechazar edad negativa', () => {
    expect(validarEdad(-5)).to.equal('Edad inválida');
  });
  
  it('debe detectar menor de edad', () => {
    expect(validarEdad(16)).to.equal('Menor de edad');
  });
  
  // Falta rama para edad >= 65
  // Falta rama para adulto (18-64)
  // Branch coverage: 2/4 = 50%
});

describe('Branch Coverage - Completo', () => {
  it('debe rechazar edad negativa', () => {
    expect(validarEdad(-5)).to.equal('Edad inválida');
  });
  
  it('debe detectar menor de edad', () => {
    expect(validarEdad(16)).to.equal('Menor de edad');
  });
  
  it('debe detectar jubilado', () => {
    expect(validarEdad(70)).to.equal('Jubilado');
  });
  
  it('debe detectar adulto activo', () => {
    expect(validarEdad(40)).to.equal('Adulto activo');
  });
  
  // Todas las ramas ejecutadas
  // Branch coverage: 4/4 = 100%
});
----

==== Function Coverage

Mide si cada función ha sido invocada al menos una vez.

.Ejemplo:
[source,typescript]
----
export class Servicio {
  saludar(): string {
    return 'Hola';
  }
  
  despedir(): string {
    return 'Adiós';
  }
  
  ayuda(): string {
    return 'Ayuda disponible';
  }
}

describe('Function Coverage - Incompleto', () => {
  const servicio = new Servicio();
  
  it('debe saludar', () => {
    expect(servicio.saludar()).to.equal('Hola');
  });
  
  // Falta llamar a despedir() y ayuda()
  // Function coverage: 1/3 = 33%
});

describe('Function Coverage - Completo', () => {
  const servicio = new Servicio();
  
  it('debe saludar', () => {
    expect(servicio.saludar()).to.equal('Hola');
  });
  
  it('debe despedir', () => {
    expect(servicio.despedir()).to.equal('Adiós');
  });
  
  it('debe mostrar ayuda', () => {
    expect(servicio.ayuda()).to.equal('Ayuda disponible');
  });
  
  // Todas las funciones invocadas
  // Function coverage: 3/3 = 100%
});
----

==== Line Coverage

Mide si cada línea de código ha sido ejecutada.

.Ejemplo:
[source,typescript]
----
export function procesarDatos(datos: any[]): any[] {
  const filtrados = datos.filter(d => d.activo);  // Línea 2
  const mapeados = filtrados.map(d => ({           // Línea 3
    ...d,
    procesado: true
  }));
  return mapeados;                                  // Línea 6
}

describe('Line Coverage', () => {
  it('debe procesar datos no vacíos', () => {
    const resultado = procesarDatos([
      { id: 1, activo: true },
      { id: 2, activo: false }
    ]);
    expect(resultado).to.have.lengthOf(1);
  });
  
  // Todas las líneas ejecutadas: 2, 3, 6
  // Line coverage: 3/3 = 100%
});
----

==== Leer Reportes de Coverage

.Estructura de salida text:
[source]
----
====== Coverage summary =======
Statements   : XX.XX% ( X/X )
Branches     : XX.XX% ( X/X )
Functions    : XX.XX% ( X/X )
Lines        : XX.XX% ( X/X )
====================================
----

.Visualizar con reportes:
[source,bash]
----
nyc report --reporter=text-summary   # Resumen en terminal
nyc report --reporter=text           # Detallado en terminal
nyc report --reporter=html           # HTML interactivo
open coverage/index.html
----

---

=== 10.3 Mejora de Coverage

==== Identificar Código No Cubierto

El reporte HTML muestra exactamente qué líneas no están cubiertas.

.Ejemplo de código:
[source,typescript]
----
// src/usuario.ts
export class Usuario {
  constructor(
    public nombre: string,
    public email: string,
    public edad: number
  ) {}
  
  esAdulto(): boolean {
    return this.edad >= 18;  // Cubierta
  }
  
  esJubilado(): boolean {
    return this.edad >= 65;  // NO cubierta
  }
  
  email_valido(): boolean {
    return this.email.includes('@');  // NO cubierta
  }
}

// tests/usuario.test.ts
import { expect } from 'chai';
import { Usuario } from '../src/usuario';

describe('Usuario', () => {
  it('debe verificar si es adulto', () => {
    const usuario = new Usuario('Juan', 'juan@example.com', 25);
    expect(usuario.esAdulto()).to.be.true;
  });
  
  // Falta test para esJubilado()
  // Falta test para emailValido()
});
----

.NYC report mostraría:
[source]
----
File         |  % Stmts | % Branch | % Funcs | % Lines
usuario.ts   |   66.67  |   50     |   66.67 |   66.67
Uncovered    |          |          |         | 13, 17
----

==== Estrategia: Edge Cases

Agregar tests para casos extremos.

.Ejemplo mejorado:
[source,typescript]
----
describe('Usuario - Mejorado', () => {
  it('debe verificar si es adulto', () => {
    const mayor = new Usuario('Juan', 'juan@example.com', 25);
    expect(mayor.esAdulto()).to.be.true;
    
    const menor = new Usuario('Ana', 'ana@example.com', 16);
    expect(menor.esAdulto()).to.be.false;
  });
  
  it('debe verificar si es jubilado', () => {
    const jubilado = new Usuario('Carlos', 'carlos@example.com', 70);
    expect(jubilado.esJubilado()).to.be.true;
    
    const noJubilado = new Usuario('Juan', 'juan@example.com', 30);
    expect(noJubilado.esJubilado()).to.be.false;
  });
  
  it('debe validar email', () => {
    const conEmail = new Usuario('Juan', 'juan@example.com', 25);
    expect(conEmail.email_valido()).to.be.true;
    
    const sinEmail = new Usuario('Ana', 'ana-invalid', 28);
    expect(sinEmail.email_valido()).to.be.false;
  });
  
  // Ahora: Statement: 100%, Branch: 100%, Function: 100%
});
----

==== Estrategia: Error Paths

Testear caminos de error.

.Código con errores:
[source,typescript]
----
export function dividir(a: number, b: number): number {
  if (!Number.isFinite(a) || !Number.isFinite(b)) {
    throw new Error('Argumentos invalidos');  // Error path
  }
  
  f (b === 0) {
    throw new Error('División por cero');     // Error path
  }
  
  return a / b;  // Happy path
}

describe('Dividir - Sin Errores', () => {
  it('debe dividir correctamente', () => {
    expect(dividir(10, 2)).to.equal(5);
  });
  // No cubre error paths!
});

describe('Dividir - Con Errores Cubiertos', () => {
  it('debe dividir correctamente', () => {
    expect(dividir(10, 2)).to.equal(5);
  });
  
  it('debe lanzar error si denominador es cero', () => {
    expect(() => dividir(10, 0)).to.throw('División por cero');
  });
  
  it('debe lanzar error si argumentos inválidos', () => {
    expect(() => dividir(NaN, 5)).to.throw('Argumentos invalidos');
    expect(() => dividir(5, Infinity)).to.throw('Argumentos invalidos');
  });
  
  // Ahora 100% coverage
});
----

==== Coverage Goals: Definir Objetivos Realistas

No siempre es posible (ni deseable) alcanzar 100% coverage.

.Estrategia recomendada:
[cols="1,2,3"]
====
| Tipo de código | Coverage | Razón

| Lógica crítica | 90-100% | Errores aquí son costosos
| Servicios | 80-90% | Comportamiento importante
| Utilidades | 80-90% | Cobertura razonable
| UI/Controllers | 70-80% | Cambios frecuentes
| Código generado | <50% | Costo-beneficio bajo
====

.Configurar thresholds reales:
[sou=rce,json]
----
{
  "all": true,
  "branches": 80,
  "lines": 85,
  "functions": 80,
  "statements": 85,
  "check-coverage": true,
  "per-file": true
}
----

==== Exclusiones: Código a No Cubrir

A veces es razonable excluir código del coverage.

.Excluir archivos específicos:
[source,json]
----
{
  "exclude": [
    "src/generated/**",
    "src/migrations/**",
    "src/**/*.mock.*",
    "src/**/*.d.ts"
  ]
}
----

.Excluir líneas en código:
[source,typescript]
----
export function log(mensaje: string): void {
  /* istanbul ignore next */  // Ignorar siguiente línea
  console.log(mensaje);
}

export function apiCall(): Promise<any> {
  /* istanbul ignore if */  // Ignorar rama if
  f (process.env.NODE_ENV === 'test') {
    return Promise.resolve({ data: 'mock' });
  }
  
  return fetch('/api/endpoint');
}
----

==== Ejemplo Integrado: Mejora de Coverage

.Código inicial:
[source,typescript]
----
// src/producto.ts
export class Producto {
  constructor(
    public id: number,
    public nombre: string,
    public precio: number,
    public stock: number
  ) {}
  
  aplicarDescuento(porcentaje: number): number {
    if (porcentaje < 0 || porcentaje > 100) {
      throw new Error('Descuento inválido');
    }
    return this.precio * (1 - porcentaje / 100);
  }
  
  comprar(cantidad: number): boolean {
    if (cantidad > this.stock) {
      return false;
    }
    this.stock -= cantidad;
    return true;
  }
  
  reponerStock(cantidad: number): void {
    if (cantidad <= 0) {
      throw new Error('Cantidad debe ser positiva');
    }
    this.stock += cantidad;
  }
}
----

.Tests iniciales (bajo coverage):
[source,typescript]
----
import { expect } from 'chai';
import { Producto } from '../src/producto';

describe('Producto - Coverage Inicial', () => {
  let producto: Producto;
  
  beforeEach(() => {
    producto = new Producto(1, 'Laptop', 1000, 5);
  });
  
  it('debe aplicar descuento válido', () => {
    const precioConDesc = producto.aplicarDescuento(10);
    expect(precioConDesc).to.equal(900);
  });
  
  it('debe comprar si hay stock', () => {
    const resultado = producto.comprar(2);
    expect(resultado).to.be.true;
    expect(producto.stock).to.equal(3);
  });
  
  // Coverage: ~50% (faltan tests para)
  // - Descuento inválido (negativo)
  // - Descuento inválido (>100)
  // - Compra sin stock
  // - ReponerStock
});
----

.Tests mejorados (alto coverage):
[source,typescript]
----
describe('Producto - Coverage Completo', () => {
  let producto: Producto;
  
  beforeEach(() => {
    producto = new Producto(1, 'Laptop', 1000, 5);
  });
  
  describe('aplicarDescuento', () => {
    it('debe aplicar descuento válido', () => {
      expect(producto.aplicarDescuento(10)).to.equal(900);
      expect(producto.aplicarDescuento(50)).to.equal(500);
      expect(producto.aplicarDescuento(0)).to.equal(1000);
      expect(producto.aplicarDescuento(100)).to.equal(0);
    });
    
    it('debe lanzar error para descuento negativo', () => {
      expect(() => producto.aplicarDescuento(-1))
        .to.throw('Descuento inválido');
    });
    
    it('debe lanzar error para descuento > 100', () => {
      expect(() => producto.aplicarDescuento(101))
        .to.throw('Descuento inválido');
    });
  });
  
  describe('comprar', () => {
    it('debe comprar si hay stock sufficient', () => {
      const resultado = producto.comprar(2);
      expect(resultado).to.be.true;
      expect(producto.stock).to.equal(3);
    });
    
    it('debe comprar cantidad exacta del stock', () => {
      const resultado = producto.comprar(5);
      expect(resultado).to.be.true;
      expect(producto.stock).to.equal(0);
    });
    
    it('debe fallar si stock insufficient', () => {
      const resultado = producto.comprar(10);
      expect(resultado).to.be.false;
      expect(producto.stock).to.equal(5); // Sin cambios
    });
  });
  
  describe('reponerStock', () => {
    it('debe reponer stock positivo', () => {
      producto.reponerStock(3);
      expect(producto.stock).to.equal(8);
    });
    
    it('debe lanzar error para cantidad cero', () => {
      expect(() => producto.reponerStock(0))
        .to.throw('Cantidad debe ser positiva');
    });
    
    it('debe lanzar error para cantidad negativa', () => {
      expect(() => producto.reponerStock(-5))
        .to.throw('Cantidad debe ser positiva');
    });
  });
  
  // Coverage: ~99% (casi perfecto)
});
----

.Ejecutar y ver mejora:
[source,bash]
----
$ npm run test:coverage

====== Coverage summary =======
Statements   : 98.00% ( 49/50 )
Branches     : 95.00% ( 19/20 )
Functions    : 100.00% ( 4/4 )
Lines        : 98.00% ( 49/50 )
====================================
----

---

---

== Módulo 11: Testing de APIs REST

Testing de APIs REST es fundamental en aplicaciones modernas. Este módulo cubre Supertest, la librería estándar para hacer assertions en HTTP requests/responses. Veremos desde requests básicos hasta flujos complejos multi-endpoint.

=== 11.1 Supertest - HTTP Assertions

==== ¿Qué es Supertest?

Supertest es un librería que simplifica testing de aplicaciones HTTP. Proporciona una API fluida para hacer requests y validar respuestas sin necesidad de un servidor ejecutándose.

==== Instalación

.Instalación básica:
[source,bash]
----
npm install --save-dev supertest
npm install --save-dev @types/supertest
----

.Dependencias típicas para una API:
[source,bash]
----
npm install express
npm install --save-dev @types/express
npm install --save-dev @types/node
npm install --save-dev ts-node
npm install --save-dev typescript
----

==== API Básica para Testear

.Crear aplicación Express simple (src/api.ts):
[source,typescript]
----
import express, { Express, Request, Response } from 'express';

export function crearApp(): Express {
  const app = express();
  
  // Middleware
  app.use(express.json());
  
  // Rutas
  app.get('/health', (req: Request, res: Response) => {
    res.status(200).json({ status: 'ok' });
  });
  
  app.get('/usuarios/:id', (req: Request, res: Response) => {
    const { id } = req.params;
    
    if (!id || isNaN(parseInt(id))) {
      return res.status(400).json({ error: 'ID inválido' });
    }
    
    f (id === '1') {
      return res.status(200).json({
        id: 1,
        nombre: 'Juan',
        email: 'juan@example.com'
      });
    }
    
    res.status(404).json({ error: 'Usuario no encontrado' });
  });
  
  return app;
}
----

==== Request Builder - Estructura Básica

Supertest utiliza un patrón builder para construir y enviar requests.

.Estructura básica:
[source,typescript]
----
import request from 'supertest';
import { expect } from 'chai';
import { crearApp } from '../src/api';

describe('API - Request Builder', () => {
  let app;
  
  beforeEach(() => {
    app = crearApp();
  });
  
  it('debe hacer GET request básico', () => {
    return request(app)
      .get('/health')                    // 1. Método HTTP + ruta
      .expect(200)                       // 2. Assertion de status
      .then(respuesta => {               // 3. Acceso a respuesta
        expect(respuesta.body.status)
          .to.equal('ok');
      });
  });
});
----

==== Response Assertions

Tabla de assertions comunes:

[cols="1,2"]
====
| Método | Qué valida

| `.expect(status)` | Status HTTP (200, 404, 500, etc.)
| `.expect(status, body)` | Status y body exacto
| `.expect(campo, valor)` | Propiedad del response body
| `.expect(fn)` | Custom assertion function
====

.Ejemplos:
[source,typescript]
----
import request from 'supertest';
import { expect } from 'chai';
import { crearApp } from '../src/api';

describe('Response Assertions', () => {
  let app;
  
  beforeEach(() => {
    app = crearApp();
  });
  
  it('debe validar status code 200', () => {
    return request(app)
      .get('/health')
      .expect(200);  // Solo status
  });
  
  it('debe validar status y body exacto', () => {
    return request(app)
      .get('/health')
      .expect(200, { status: 'ok' });  // Status + body completo
  });
  
  it('debe validar propiedad específica', () => {
    return request(app)
      .get('/health')
      .expect('Content-Type', /json/);  // Validar header
  });
  
  it('debe usar custom assertion', () => {
    return request(app)
      .get('/usuarios/1')
      .expect(res => {
        expect(res.body.nombre).to.equal('Juan');
        expect(res.body.email).to.include('@');
      });
  });
});
----

==== Status Codes y Headers

Validar status y headers HTTP.

.Tabla de status comunes:
[cols="1,2"]
====
| Status | Significado

| 200 | OK - Éxito
| 201 | Created - Recurso creado
| 204 | No Content - Éxito sin body
| 400 | Bad Request - Datos inválidos
| 401 | Unauthorized - Falta autenticación
| 403 | Forbidden - Sin permisos
| 404 | Not Found - Recurso no existe
| 500 | Server Error - Error del servidor
====

.Ejemplos:
[source,typescript]
----
import request from 'supertest';
import { expect } from 'chai';
import { crearApp } from '../src/api';

describe('Status Codes y Headers', () => {
  let app;
  
  beforeEach(() => {
    app = crearApp();
  });
  
  it('debe retornar 200 en health check', () => {
    return request(app)
      .get('/health')
      .expect(200)
      .expect('Content-Type', /json/);
  });
  
  it('debe retornar 404 para usuario no encontrado', () => {
    return request(app)
      .get('/usuarios/999')
      .expect(404)
      .expect(res => {
        expect(res.body.error).to.equal('Usuario no encontrado');
      });
  });
  
  it('debe retornar 400 para ID inválido', () => {
    return request(app)
      .get('/usuarios/abc')
      .expect(400)
      .expect('Content-Type', /json/);
  });
  
  it('debe validar headers específicos', () => {
    return request(app)
      .get('/health')
      .expect(200)
      .expect('Content-Type', 'application/json; charset=utf-8')
      .expect('X-Powered-By', /express/i)  // Regex también funciona
      .expect(res => {
        expect(res.headers['content-length']).to.exist;
      });
  });
});
----

---

=== 11.2 Testing de Endpoints

==== API Completa para Tests

.API con CRUD completo (src/api-completa.ts):
[source,typescript]
----
import express, { Express, Request, Response } from 'express';

interface Producto {
  id: number;
  nombre: string;
  precio: number;
  stock: number;
}

export function crearAppProductos(): Express {
  const app = express();
  app.use(express.json());
  
  let productos: Producto[] = [
    { id: 1, nombre: 'Laptop', precio: 1000, stock: 5 },
    { id: 2, nombre: 'Mouse', precio: 25, stock: 100 }
  ];
  let proximoId = 3;
  
  // GET todos
  app.get('/productos', (req: Request, res: Response) => {
    res.status(200).json(productos);
  });
  
  // GET uno
  app.get('/productos/:id', (req: Request, res: Response) => {
    onst producto = productos.find(p => p.id === parseInt(req.params.id));
    if (!producto) {
      return res.status(404).json({ error: 'No encontrado' });
    }
    res.status(200).json(producto);
  });
  
  // POST crear
  app.post('/productos', (req: Request, res: Response) => {
    const { nombre, precio, stock } = req.body;
    
    if (!nombre || !precio) {
      return res.status(400).json({ error: 'Campos requeridos' });
    }
    
    const nuevo: Producto = {
      id: proximoId++,
      nombre,
      precio,
      stock: stock || 0
    };
    
    productos.push(nuevo);
    res.status(201).json(nuevo);
  });
  
  // PUT actualizar
  app.put('/productos/:id', (req: Request, res: Response) => {
    onst producto = productos.find(p => p.id === parseInt(req.params.id));
    if (!producto) {
      return res.status(404).json({ error: 'No encontrado' });
    }
    
    producto.nombre = req.body.nombre || producto.nombre;
    producto.precio = req.body.precio || producto.precio;
    producto.stock = req.body.stock !== undefined ? req.body.stock : producto.stock;
    
    res.status(200).json(producto);
  });
  
  // DELETE
  app.delete('/productos/:id', (req: Request, res: Response) => {
    onst index = productos.findIndex(p => p.id === parseInt(req.params.id));
    f (index === -1) {
      return res.status(404).json({ error: 'No encontrado' });
    }
    
    const eliminado = productos.splice(index, 1);
    res.status(200).json(eliminado[0]);
  });
  
  return app;
}
----

==== GET Requests

Testing de GET sin parámetros y con parámetros.

.Ejemplos:
[source,typescript]
----
import request from 'supertest';
import { expect } from 'chai';
import { crearAppProductos } from '../src/api-completa';

describe('GET Requests', () => {
  let app;
  
  beforeEach(() => {
    app = crearAppProductos();
  });
  
  it('debe obtener todos los productos', () => {
    return request(app)
      .get('/productos')
      .expect(200)
      .expect(res => {
        expect(res.body).to.be.an('array');
        expect(res.body).to.have.lengthOf.at.least(1);
        expect(res.body[0]).to.have.property('id');
        expect(res.body[0]).to.have.property('nombre');
      });
  });
  
  it('debe obtener producto específico por ID', () => {
    return request(app)
      .get('/productos/1')
      .expect(200)
      .expect(res => {
        expect(res.body.id).to.equal(1);
        expect(res.body.nombre).to.equal('Laptop');
        expect(res.body.precio).to.equal(1000);
      });
  });
  
  it('debe retornar 404 para producto no existente', () => {
    return request(app)
      .get('/productos/999')
      .expect(404)
      .expect(res => {
        expect(res.body.error).to.equal('No encontrado');
      });
  });
  
  it('debe manejar GET con query params', function() {
    // Si la API soportara filtros: GET /productos?nombre=Laptop&maxPrecio=2000
    return request(app)
      .get('/productos')
      .query({ nombre: 'Laptop' })
      .expect(200);
  });
});
----

==== POST Requests

Crear nuevos recursos y validar respuestas.

.Ejemplos:
[source,typescript]
----
import request from 'supertest';
import { expect } from 'chai';
import { crearAppProductos } from '../src/api-completa';

describe('POST Requests', () => {
  let app;
  
  beforeEach(() => {
    app = crearAppProductos();
  });
  
  it('debe crear nuevo producto', () => {
    return request(app)
      .post('/productos')
      .send({
        nombre: 'Teclado',
        precio: 75,
        stock: 50
      })
      .expect(201)
      .expect(res => {
        expect(res.body.id).to.exist;
        expect(res.body.nombre).to.equal('Teclado');
        expect(res.body.precio).to.equal(75);
        expect(res.body.stock).to.equal(50);
      });
  });
  
  it('debe crear producto sin stock (default 0)', () => {
    return request(app)
      .post('/productos')
      .send({
        nombre: 'Monitor',
        precio: 300
      })
      .expect(201)
      .expect(res => {
        expect(res.body.stock).to.equal(0);
      });
  });
  
  it('debe rechazar POST sin campos requeridos', () => {
    return request(app)
      .post('/productos')
      .send({
        nombre: 'Incompleto'
        // Falta precio
      })
      .expect(400)
      .expect(res => {
        expect(res.body.error).to.equal('Campos requeridos');
      });
  });
  
  it('debe rechazar POST con body vacío', () => {
    return request(app)
      .post('/productos')
      .send({})
      .expect(400);
  });
  
  it('debe validar tipos de datos', () => {
    return request(app)
      .post('/productos')
      .send({
        nombre: 'Producto',
        precio: 'no-es-numero'  // Error!
      })
      .expect(400);
  });
});
----

==== PUT/PATCH Requests

Actualizar recursos existentes.

.Ejemplos:
[source,typescript]
----
import request from 'supertest';
import { expect } from 'chai';
import { crearAppProductos } from '../src/api-completa';

describe('PUT Requests', () => {
  let app;
  
  beforeEach(() => {
    app = crearAppProductos();
  });
  
  it('debe actualizar producto existente', () => {
    return request(app)
      .put('/productos/1')
      .send({
        nombre: 'Laptop Mejorada',
        precio: 1200
      })
      .expect(200)
      .expect(res => {
        expect(res.body.id).to.equal(1);
        expect(res.body.nombre).to.equal('Laptop Mejorada');
        expect(res.body.precio).to.equal(1200);
      });
  });
  
  it('debe actualizar solo campo especificado', () => {
    return request(app)
      .put('/productos/2')
      .send({
        stock: 200
      })
      .expect(200)
      .expect(res => {
        expect(res.body.nombre).to.equal('Mouse'); // Sin cambios
        expect(res.body.stock).to.equal(200);
      });
  });
  
  it('debe retornar 404 para producto inexistente', () => {
    return request(app)
      .put('/productos/999')
      .send({ nombre: 'Test' })
      .expect(404);
  });
});
----

==== DELETE Requests

Eliminar recursos.

.Ejemplos:
[source,typescript]
----
import request from 'supertest';
import { expect } from 'chai';
import { crearAppProductos } from '../src/api-completa';

describe('DELETE Requests', () => {
  let app;
  
  beforeEach(() => {
    app = crearAppProductos();
  });
  
  it('debe eliminar producto existente', () => {
    return request(app)
      .delete('/productos/2')
      .expect(200)
      .expect(res => {
        expect(res.body.id).to.equal(2);
        expect(res.body.nombre).to.equal('Mouse');
      });
  });
  
  it('debe verificar que producto fue eliminado', () => {
    // Primero eliminar
    return request(app)
      .delete('/productos/1')
      .expect(200)
      .then(() => {
        // Luego intentar obtener
        return request(app)
          .get('/productos/1')
          .expect(404);
      });
  });
  
  it('debe retornar 404 para delete inexistente', () => {
    return request(app)
      .delete('/productos/999')
      .expect(404);
  });
});
----

==== Headers y Autenticación

Testing con headers custom y autenticación.

.API con autenticación:
[source,typescript]
----
import express, { Express, Request, Response, NextFunction } from 'express';

export function crearAppConAuth(): Express {
  const app = express();
  app.use(express.json());
  
  // Middleware de autenticación
  const verificarToken = (req: Request, res: Response, next: NextFunction) => {
    const token = req.headers['authorization']?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ error: 'Token requerido' });
    }
    
    if (token !== 'valid-token-123') {
      return res.status(403).json({ error: 'Token inválido' });
    }
    
    next();
  };
  
  app.get('/datos-publicos', (req: Request, res: Response) => {
    res.json({ data: 'Pública' });
  });
  
  app.get('/datos-privados', verificarToken, (req: Request, res: Response) => {
    res.json({ data: 'Privada', user: 'admin' });
  });
  
  return app;
}
----

.Tests:
[source,typescript]
----
import request from 'supertest';
import { expect } from 'chai';
import { crearAppConAuth } from '../src/api-auth';

describe('Headers y Autenticación', () => {
  let app;
  
  beforeEach(() => {
    app = crearAppConAuth();
  });
  
  it('debe acceder a endpoint público sin token', () => {
    return request(app)
      .get('/datos-publicos')
      .expect(200)
      .expect(res => {
        expect(res.body.data).to.equal('Pública');
      });
  });
  
  it('debe rechazar endpoint privado sin token', () => {
    return request(app)
      .get('/datos-privados')
      .expect(401)
      .expect(res => {
        expect(res.body.error).to.equal('Token requerido');
      });
  });
  
  it('debe rechazar token inválido', () => {
    return request(app)
      .get('/datos-privados')
      .set('Authorization', 'Bearer invalid-token')
      .expect(403)
      .expect(res => {
        expect(res.body.error).to.equal('Token inválido');
      });
  });
  
  it('debe acceder a endpoint privado con token válido', () => {
    return request(app)
      .get('/datos-privados')
      .set('Authorization', 'Bearer valid-token-123')
      .expect(200)
      .expect(res => {
        expect(res.body.data).to.equal('Privada');
        expect(res.body.user).to.equal('admin');
      });
  });
  
  it('debe enviar múltiples headers', () => {
    return request(app)
      .get('/datos-privados')
      .set('Authorization', 'Bearer valid-token-123')
      .set('X-Custom-Header', 'valor')
      .set('Content-Type', 'application/json')
      .expect(200);
  });
});
----

---

=== 11.3 Testing de Flujos Complejos

==== Chaining de Requests

Ejecutar múltiples requests secuencialmente y usar datos del primero en el segundo.

.Ejemplo: Crear producto, luego obtenerlo, luego actualizar, luego eliminar:
[source,typescript]
----
import request from 'supertest';
import { expect } from 'chai';
import { crearAppProductos } from '../src/api-completa';

describe('Chaining de Requests - Flujo CRUD Completo', () => {
  let app;
  let productoId: number;
  
  beforeEach(() => {
    app = crearAppProductos();
  });
  
  it('debe ejecutar flujo completo: Create -> Read -> Update -> Delete', () => {
    // 1. CREATE
    return request(app)
      .post('/productos')
      .send({
        nombre: 'Nuevo Producto',
        precio: 500,
        stock: 10
      })
      .expect(201)
      .then(res => {
        productoId = res.body.id;
        expect(res.body.nombre).to.equal('Nuevo Producto');
        
        // 2. READ
        return request(app)
          .get(`/productos/${productoId}`)
          .expect(200);
      })
      .then(res => {
        expect(res.body.id).to.equal(productoId);
        
        // 3. UPDATE
        return request(app)
          .put(`/productos/${productoId}`)
          .send({
            nombre: 'Producto Actualizado',
            precio: 600
          })
          .expect(200);
      })
      .then(res => {
        expect(res.body.nombre).to.equal('Producto Actualizado');
        expect(res.body.precio).to.equal(600);
        
        // 4. DELETE
        return request(app)
          .delete(`/productos/${productoId}`)
          .expect(200);
      })
      .then(res => {
        expect(res.body.id).to.equal(productoId);
        
        // 5. VERIFY DELETED
        return request(app)
          .get(`/productos/${productoId}`)
          .expect(404);
      });
  });
});
----

==== Datos Dependientes

Usar datos de una respuesta en la siguiente request.

.API de Usuarios con Órdenes:
[source,typescript]
----
import express, { Express, Request, Response } from 'express';

interface Usuario {
  id: number;
  nombre: string;
  email: string;
}

interface Orden {
  id: number;
  usuarioId: number;
  producto: string;
  monto: number;
}

export function crearAppOrdenes(): Express {
  const app = express();
  app.use(express.json());
  
  let usuarios: Usuario[] = [
    { id: 1, nombre: 'Juan', email: 'juan@example.com' }
  ];
  let ordenes: Orden[] = [];
  let proximoUsuarioId = 2;
  let proximaOrdenId = 1;
  
  // Crear usuario
  app.post('/usuarios', (req: Request, res: Response) => {
    const usuario: Usuario = {
      id: proximoUsuarioId++,
      nombre: req.body.nombre,
      email: req.body.email
    };
    usuarios.push(usuario);
    res.status(201).json(usuario);
  });
  
  // Crear orden para usuario
  app.post('/usuarios/:usuarioId/ordenes', (req: Request, res: Response) => {
    const usuarioId = parseInt(req.params.usuarioId);
    onst usuario = usuarios.find(u => u.id === usuarioId);
    
    if (!usuario) {
      return res.status(404).json({ error: 'Usuario no encontrado' });
    }
    
    const orden: Orden = {
      id: proximaOrdenId++,
      usuarioId,
      producto: req.body.producto,
      monto: req.body.monto
    };
    
    ordenes.push(orden);
    res.status(201).json(orden);
  });
  
  // Obtener órdenes del usuario
  app.get('/usuarios/:usuarioId/ordenes', (req: Request, res: Response) => {
    const usuarioId = parseInt(req.params.usuarioId);
    onst ordenesUsuario = ordenes.filter(o => o.usuarioId === usuarioId);
    res.status(200).json(ordenesUsuario);
  });
  
  return app;
}
----

.Tests con datos dependientes:
[source,typescript]
----
import request from 'supertest';
import { expect } from 'chai';
import { crearAppOrdenes } from '../src/api-ordenes';

describe('Datos Dependientes - Flujo Usuario + Órdenes', () => {
  let app;
  let usuarioId: number;
  let ordenIds: number[] = [];
  
  beforeEach(() => {
    app = crearAppOrdenes();
  });
  
  it('debe crear usuario y agregar múltiples órdenes', () => {
    // 1. Crear usuario (necesitamos su ID)
    return request(app)
      .post('/usuarios')
      .send({
        nombre: 'Ana García',
        email: 'ana@example.com'
      })
      .expect(201)
      .then(res => {
        usuarioId = res.body.id;
        expect(usuarioId).to.exist;
        
        // 2. Crear primera orden (usando ID del usuario)
        return request(app)
          .post(`/usuarios/${usuarioId}/ordenes`)
          .send({
            producto: 'Laptop',
            monto: 1000
          })
          .expect(201);
      })
      .then(res => {
        ordenIds.push(res.body.id);
        expect(res.body.usuarioId).to.equal(usuarioId);
        
        // 3. Crear segunda orden
        return request(app)
          .post(`/usuarios/${usuarioId}/ordenes`)
          .send({
            producto: 'Mouse',
            monto: 25
          })
          .expect(201);
      })
      .then(res => {
        ordenIds.push(res.body.id);
        
        // 4. Verificar que usuario tiene 2 órdenes
        return request(app)
          .get(`/usuarios/${usuarioId}/ordenes`)
          .expect(200);
      })
      .then(res => {
        expect(res.body).to.have.lengthOf(2);
        expect(res.body[0].producto).to.equal('Laptop');
        expect(res.body[1].producto).to.equal('Mouse');
      });
  });
  
  it('debe fallar al crear orden para usuario inexistente', () => {
    return request(app)
      .post('/usuarios/999/ordenes')
      .send({
        producto: 'Test',
        monto: 100
      })
      .expect(404);
  });
});
----

==== Estado Compartido Entre Tests

Mantener estado entre múltiples tests.

.Ejemplo con inicialización y limpieza:
[source,typescript]
----
import request from 'supertest';
import { expect } from 'chai';
import { crearAppOrdenes } from '../src/api-ordenes';

describe('Estado Compartido - Suite Integration', () => {
  let app;
  let usuarioId: number;
  let ordenId: number;
  
  beforeEach(() => {
    app = crearAppOrdenes();
  });
  
  // Test 1: Setup - crear usuario
  it('debe crear usuario inicial', () => {
    return request(app)
      .post('/usuarios')
      .send({
        nombre: 'Usuario Test',
        email: 'test@example.com'
      })
      .expect(201)
      .then(res => {
        usuarioId = res.body.id;
      });
  });
  
  // Test 2: Usar usuario del test anterior
  it('debe crear orden para usuario existente', () => {
    // usuarioId ya existe del test anterior
    return request(app)
      .post(`/usuarios/${usuarioId}/ordenes`)
      .send({
        producto: 'Monitor',
        monto: 300
      })
      .expect(201)
      .then(res => {
        ordenId = res.body.id;
        expect(res.body.usuarioId).to.equal(usuarioId);
      });
  });
  
  // Test 3: Usar orden del test anterior
  it('debe obtener orden creada', () => {
    return request(app)
      .get(`/usuarios/${usuarioId}/ordenes`)
      .expect(200)
      .then(res => {
        onst miOrden = res.body.find((o: any) => o.id === ordenId);
        expect(miOrden).to.exist;
        expect(miOrden.producto).to.equal('Monitor');
      });
  });
});
----

==== Ejemplo Integrado: E-commerce Completo

API completa con múltiples endpoints interconectados.

[source,typescript]
----
import request from 'supertest';
import { expect } from 'chai';
import { crearAppOrdenes } from '../src/api-ordenes';

describe('E-commerce - Flujo Completo de Compra', () => {
  let app;
  
  beforeEach(() => {
    app = crearAppOrdenes();
  });
  
  it('debe completar flujo de compra: usuario -> carrito -> orden', () => {
    let usuarioId: number;
    let ordenId: number;
    
    // 1. Registrar nuevo usuario
    return request(app)
      .post('/usuarios')
      .send({
        nombre: 'Cliente Premium',
        email: 'premium@example.com'
      })
      .expect(201)
      .then(res => {
        usuarioId = res.body.id;
        
        // 2. Primera orden
        return request(app)
          .post(`/usuarios/${usuarioId}/ordenes`)
          .send({
            producto: 'Laptop Gaming',
            monto: 2000
          })
          .expect(201);
      })
      .then(res => {
        ordenId = res.body.id;
        
        // 3. Segunda orden
        return request(app)
          .post(`/usuarios/${usuarioId}/ordenes`)
          .send({
            producto: 'Monitor 4K',
            monto: 800
          })
          .expect(201);
      })
      .then(res => {
        // 4. Listar todas las órdenes del usuario
        return request(app)
          .get(`/usuarios/${usuarioId}/ordenes`)
          .expect(200);
      })
      .then(res => {
        expect(res.body).to.have.lengthOf(2);
        const montoTotal = res.body.reduce((sum: number, o: any) => sum + o.monto, 0);
        expect(montoTotal).to.equal(2800);
      });
  });
  
  it('debe validar operaciones concurrentes', () => {
    let usuarioId: number;
    
    return request(app)
      .post('/usuarios')
      .send({
        nombre: 'Usuario Ocupado',
        email: 'ocupado@example.com'
      })
      .expect(201)
      .then(res => {
        usuarioId = res.body.id;
        
        // Crear 3 órdenes en paralelo
        return Promise.all([
          request(app)
            .post(`/usuarios/${usuarioId}/ordenes`)
            .send({ producto: 'Libro', monto: 20 })
            .expect(201),
          request(app)
            .post(`/usuarios/${usuarioId}/ordenes`)
            .send({ producto: 'Pen', monto: 5 })
            .expect(201),
          request(app)
            .post(`/usuarios/${usuarioId}/ordenes`)
            .send({ producto: 'Notebook', monto: 10 })
            .expect(201)
        ]);
      })
      .then(responses => {
        expect(responses).to.have.lengthOf(3);
        responses.forEach((res, index) => {
          expect(res.body.id).to.exist;
        });
      });
  });
});
----

---

---

== Módulo 12: Buenas Prácticas

Este módulo cubre patrones y convenciones que hacen tus tests mantenibles, legibles y efectivos a largo plazo. La calidad del código de tests es tan importante como la del código de producción.

=== 12.1 Estructura de Tests

==== Organización de Archivos

Estructura recomendada de un proyecto con tests:

[source]
----
proyecto/
├── src/
│   ├── calculadora.ts
│   ├── usuario.ts
│   ├── carrito.ts
│   └── utils.ts
├── tests/
│   ├── unit/
│   │   ├── calculadora.test.ts
│   │   ├── usuario.test.ts
│   │   ├── carrito.test.ts
│   │   └── utils.test.ts
│   ├── integration/
│   │   ├── carrito-producto.test.ts
│   │   └── usuario-autenticacion.test.ts
│   ├── fixtures/
│   │   ├── usuarios.json
│   │   └── productos.json
│   └── helpers/
│       ├── test-utils.ts
│       └── mock-data.ts
├── package.json
├── tsconfig.json
└── .mocharc.json
----

**Principios de organización:**

- **Por tipo de test**: unit, integration, e2e en carpetas separadas
- **Espejo de estructura src**: Tests en estructura similar a src para fácil navegación
- **Helpers y fixtures centralizados**: Reutilizar código de test
- **Naming consistente**: `archivo.test.ts` o `archivo.spec.ts`

==== Convenciones de Naming

Nombres claros hacen tests auto-documentados.

.Malas prácticas:
[source,typescript]
----
describe('Calc', () => {
  it('works', () => {
    // ¿Qué calcula? ¿Qué debería hacer?
  });
  
  it('test1', () => {
    // ¿Cuál es el case?
  });
  
  it('should work with stuff', () => {
    // "stuff" es muy vago
  });
});
----

.Buenas prácticas:
[source,typescript]
----
describe('Calculadora', () => {
  describe('sumar', () => {
    it('debe retornar suma de dos números positivos', () => {
      const resultado = calc.sumar(2, 3);
      expect(resultado).to.equal(5);
    });
    
    it('debe manejar números negativos', () => {
      const resultado = calc.sumar(-5, 3);
      expect(resultado).to.equal(-2);
    });
    
    it('debe retornar 0 cuando ambos son 0', () => {
      const resultado = calc.sumar(0, 0);
      expect(resultado).to.equal(0);
    });
  });
});
----

**Convenciones:**

[cols="1,2"]
====
| Patrón | Ejemplo

| Describe | Nombre de clase/función: `describe('Calculadora', ...)`
| It/Test | Comportamiento esperado: `it('debe sumar números positivos', ...)`
| Archivo | `calculadora.test.ts` (plural: tests, singular: test okay)
| Variables | `usuarioValido`, `respuestaConError`, `datosMock`
====

==== DRY (Don't Repeat Yourself) en Tests

Refa=ctorizar código duplicado en helpers.

.Ejemplo de duplicación:
[source,typescript]
----
describe('Usuario - DRY Malo', () => {
  it('debe validar nombre', () => {
    const usuario = {
      nombre: 'Juan',
      email: 'juan@example.com',
      edad: 30,
      ciudad: 'Madrid',
      activo: true
    };
    expect(usuario.nombre).to.equal('Juan');
  });
  
  it('debe validar email', () => {
    const usuario = {
      nombre: 'Ana',
      email: 'ana@example.com',
      edad: 28,
      ciudad: 'Barcelona',
      activo: true
    };
    expect(usuario.email).to.include('@');
  });
  
  it('debe validar edad', () => {
    const usuario = {
      nombre: 'Carlos',
      email: 'carlos@example.com',
      edad: 35,
      ciudad: 'Valencia',
      activo: true
    };
    expect(usuario.edad).to.be.greaterThan(0);
  });
  // Repetición innecesaria!
});
----

.Refactorizado con helper:
[source,typescript]
----
// tests/helpers/usuario-fixtures.ts
export const crearUsuarioBase = (overrides = {}) => ({
  nombre: 'Usuario Default',
  email: 'usuario@example.com',
  edad: 25,
  ciudad: 'Madrid',
  activo: true,
  ...overrides
});

// tests/unit/usuario.test.ts
describe('Usuario - DRY Bueno', () => {
  it('debe validar nombre', () => {
    const usuario = crearUsuarioBase({ nombre: 'Juan' });
    expect(usuario.nombre).to.equal('Juan');
  });
  
  it('debe validar email', () => {
    const usuario = crearUsuarioBase({ email: 'ana@example.com' });
    expect(usuario.email).to.include('@');
  });
  
  it('debe validar edad', () => {
    const usuario = crearUsuarioBase({ edad: 35 });
    expect(usuario.edad).to.be.greaterThan(0);
  });
  // Mucho más limpio!
});
----

==== Single Responsibility: Un Test, Una Cosa

Cada test debe verificar una única funcionalidad.

.Mal: Multiple assertions sin relación:
[source,typescript]
----
it('debe procesar carrito completo', () => {
  const carrito = new Carrito();
  
  // Testing agregar item
  carrito.agregar({ id: 1, nombre: 'Laptop', precio: 1000 });
  expect(carrito.items.length).to.equal(1);
  expect(carrito.items[0].nombre).to.equal('Laptop');
  
  // Testing calcular total
  expect(carrito.obtenerTotal()).to.equal(1000);
  
  // Testing aplicar descuento
  carrito.aplicarDescuento(10);
  expect(carrito.descuentoAplicado).to.be.true;
  expect(carrito.obtenerTotal()).to.equal(900);
  
  // Testing vaciar carrito
  carrito.vaciar();
  expect(carrito.items.length).to.equal(0);
});
// Un test que hace demasiado!
----

.Bien: Tests separados y enfocados:
[source,typescript]
----
describe('Carrito', () => {
  let carrito: Carrito;
  
  beforeEach(() => {
    carrito = new Carrito();
  });
  
  describe('agregar items', () => {
    it('debe agregar un item al carrito', () => {
      carrito.agregar({ id: 1, nombre: 'Laptop', precio: 1000 });
      expect(carrito.items).to.have.lengthOf(1);
    });
    
    it('debe almacenar datos del item correctamente', () => {
      carrito.agregar({ id: 1, nombre: 'Laptop', precio: 1000 });
      expect(carrito.items[0].nombre).to.equal('Laptop');
    });
  });
  
  describe('calcular total', () => {
    it('debe retornar total sin descuento', () => {
      carrito.agregar({ id: 1, nombre: 'Laptop', precio: 1000 });
      expect(carrito.obtenerTotal()).to.equal(1000);
    });
  });
  
  describe('aplicar descuento', () => {
    it('debe aplicar descuento porcentual', () => {
      carrito.agregar({ id: 1, nombre: 'Laptop', precio: 1000 });
      carrito.aplicarDescuento(10);
      expect(carrito.obtenerTotal()).to.equal(900);
    });
  });
  
  describe('vaciar', () => {
    it('debe eliminar todos los items', () => {
      carrito.agregar({ id: 1, nombre: 'Laptop', precio: 1000 });
      carrito.vaciar();
      expect(carrito.items).to.have.lengthOf(0);
    });
  });
});
// Cada test verifica una cosa!
----

---

=== 12.2 Escritura de Tests Efectivos

==== One Assertion Per Test

Un test debe tener idealmente una sola assertion (verificación).

.Anti-patrón: Múltiples assertions:
[source,typescript]
----
it('debe hacer muchas cosas', () => {
  const resultado = sumar(2, 3);
  
  expect(resultado).to.equal(5);              // Assertion 1
  expect(typeof resultado).to.equal('number'); // Assertion 2
  expect(resultado).to.be.greaterThan(0);     // Assertion 3
  
  // Si falla la primera, nunca se ejecuta la segunda
  // Es confuso saber cuál falló exactamente
});
----

.Patrón correcto: Una assertion principal por test:
[source,typescript]
----
describe('sumar', () => {
  it('debe retornar resultado numérico correcto', () => {
    const resultado = sumar(2, 3);
    expect(resultado).to.equal(5);
  });
  
  it('debe retornar dato de tipo number', () => {
    const resultado = sumar(2, 3);
    expect(typeof resultado).to.equal('number');
  });
  
  it('debe retornar valor positivo', () => {
    const resultado = sumar(2, 3);
    expect(resultado).to.be.greaterThan(0);
  });
});
----

**Ventajas:**
- Claridad: Sé exactamente qué falló
- Mantenibilidad: Tests fáciles de modificar
- Reusabilidad: Un error no oculta otros

==== Nombres Descriptivos

Los nombres deben explicar qué se está testando y qué se espera.

.Malos nombres:
[source,typescript]
----
it('works', () => {});
it('test', () => {});
it('should work', () => {});
it('edge case', () => {});
it('error test', () => {});
----

.Buenos nombres (auto-documentados):
[source,typescript]
----
it('debe retornar el doble del número ingresado', () => {});
it('debe lanzar error cuando parámetro es null', () => {});
it('debe ignorar espacios en blanco al validar email', () => {});
it('debe retornar lista vacía cuando no hay resultados', () => {});
it('debe incrementar contador después de cada llamada', () => {});
----

Formula útil: `"debe [acción] cuando [condición]"`

[cols="1,2"]
====
| Patrón | Ejemplo

| Valor positivo | "debe retornar suma correcta"
| Valor negativo | "debe lanzar error para entrada inválida"
| Límite | "debe manejar strings vacíos"
| Lado efecto | "debe actualizar base de datos"
| Performance | "debe completarse en menos de 100ms"
====

==== AAA Pattern: Arrange, Act, Assert

El patrón AAA estructura tests claramente en tres fases.

.Estructura:
[source,typescript]
----
it('debe calcular descuento correctamente', () => {
  // ARRANGE (Preparación)
  const precioOriginal = 100;
  const porcentajeDescuento = 10;
  const precioEsperado = 90;
  
  // ACT (Acción)
  const precioConDescuento = aplicarDescuento(
    precioOriginal, 
    porcentajeDescuento
  );
  
  // ASSERT (Verificación)
  expect(precioConDescuento).to.equal(precioEsperado);
});
----

.Ejemplo complejo:
[source,typescript]
----
class RepositorioUsuarios {
  private usuarios: any[] = [];
  
  guardar(usuario: any): void {
    this.usuarios.push(usuario);
  }
  
  obtenerPorEmail(email: string): any {
    eturn this.usuarios.find(u => u.email === email);
  }
}

describe('RepositorioUsuarios - AAA Pattern', () => {
  it('debe guardar y recuperar usuario por email', () => {
    // ARRANGE
    const repo = new RepositorioUsuarios();
    const usuarioNuevo = {
      nombre: 'Juan',
      email: 'juan@example.com',
      edad: 30
    };
    
    // ACT
    repo.guardar(usuarioNuevo);
    const usuarioRecuperado = repo.obtenerPorEmail('juan@example.com');
    
    // ASSERT
    expect(usuarioRecuperado).to.deep.equal(usuarioNuevo);
    expect(usuarioRecuperado.nombre).to.equal('Juan');
  });
  
  it('debe retornar undefined si email no existe', () => {
    // ARRANGE
    const repo = new RepositorioUsuarios();
    
    // ACT
    const resultado = repo.obtenerPorEmail('inexistente@example.com');
    
    // ASSERT
    expect(resultado).to.be.undefined;
  });
});
----

==== Evitar Dependencias Entre Tests

Tests deben ser independientes. Uno no debe requeri del estado de otro.

.Mal: Tests dependientes (frágil):
[source,typescript]
----
let contador = 0;

describe('Contador - Dependencias', () => {
  it('test 1: debe incrementar', () => {
    contador++;
    expect(contador).to.equal(1);
    // El test 2 depende de este resultado!
  });
  
  it('test 2: debe valer 1', () => {
    // Solo pasa si test 1 pasó antes
    expect(contador).to.equal(1);
  });
  
  it('test 3: debe decrementar', () => {
    contador--;
    // Si test 2 no corrió, esto falla!
    expect(contador).to.equal(0);
  });
});
// Orden de ejecución afecta resultados!
----

.Bien: Tests independientes (robusto):
[source,typescript]
----
class Contador {
  private valor = 0;
  
  incrementar(): void {
    this.valor++;
  }
  
  decrementar(): void {
    this.valor--;
  }
  
  obtenerValor(): number {
    return this.valor;
  }
}

describe('Contador - Independencia', () => {
  let contador: Contador;
  
  beforeEach(() => {
    contador = new Contador();  // Reset para cada test!
  });
  
  it('debe comenzar en 0', () => {
    expect(contador.obtenerValor()).to.equal(0);
  });
  
  it('debe incrementar de forma independiente', () => {
    contador.incrementar();
    expect(contador.obtenerValor()).to.equal(1);
  });
  
  it('debe decrementar de forma independiente', () => {
    contador.decrementar();
    expect(contador.obtenerValor()).to.equal(-1);
  });
});
// Cada test funciona solo, sin dependencias!
----

---

=== 12.3 Mantenimiento de Tests

==== Tests Como Documentación

Bien escritos, los tests describen cómo usar el código.

.Ejemplo: Tests = Documentación viva
[source,typescript]
----
/**
 * Tests de Calculadora - Ejemplos de uso
 */
describe('Calculadora', () => {
  let calc: Calculadora;
  
  beforeEach(() => {
    calc = new Calculadora();
  });
  
  describe('constructor', () => {
    it('puede inicializar con valor inicial', () => {
      const calc2 = new Calculadora(10);
      expect(calc2.obtenerValor()).to.equal(10);
    });
    
    it('comienza en 0 si no se especifica', () => {
      expect(calc.obtenerValor()).to.equal(0);
    });
  });
  
  describe('sumar()', () => {
    it('suma un número al valor actual', () => {
      calc.sumar(5);
      expect(calc.obtenerValor()).to.equal(5);
    });
    
    it('permite encadenamiento: calc.sumar(5).sumar(3)', () => {
      calc.sumar(5).sumar(3);
      expect(calc.obtenerValor()).to.equal(8);
    });
  });
  
  describe('restar()', () => {
    it('resta un número del valor actual', () => {
      calc.sumar(10).restar(3);
      expect(calc.obtenerValor()).to.equal(7);
    });
  });
  
  describe('limpiar()', () => {
    it('reinicia el valor a 0', () => {
      calc.sumar(50).limpiar();
      expect(calc.obtenerValor()).to.equal(0);
    });
  });
  
  describe('snapshot', () => {
    it('guarda estado actual para comparación posterior', () => {
      calc.sumar(10).snapshot();
      calc.sumar(5);
      expect(calc.obtenerSnapshot()).to.equal(10);
    });
  });
});
// README innecesario: Los tests muestran todo!
----

==== Refactoring de Tests

Mantener tests limpios a medida que evoluciona el código.

.Antes: Tests desordenados
[source,typescript]
----
describe('Validador', () => {
  it('email validation', () => {
    const v = new Validador();
    const result = v.emailValido('test@example.com');
    expect(result).to.be.true;
    const result2 = v.emailValido('invalid-email');
    expect(result2).to.be.false;
    const result3 = v.emailValido('');
    expect(result3).to.be.false;
  });
  
  it('telefono', () => {
    const v = new Validador();
    expect(v.telefonoValido('123-456-7890')).to.be.true;
    expect(v.telefonoValido('abc')).to.be.false;
  });
});
----

.Después: Tests refactorizados
[source,typescript]
----
describe('Validador', () => {
  let validador: Validador;
  
  beforeEach(() => {
    validador = new Validador();
  });
  
  describe('emailValido()', () => {
    it('debe retornar true para email válido', () => {
      expect(validador.emailValido('test@example.com')).to.be.true;
    });
    
    it('debe retornar false para email sin @', () => {
      expect(validador.emailValido('invalid-email')).to.be.false;
    });
    
    it('debe retornar false para email vacío', () => {
      expect(validador.emailValido('')).to.be.false;
    });
  });
  
  describe('telefonoValido()', () => {
    it('debe retornar true para teléfono válido', () => {
      expect(validador.telefonoValido('123-456-7890')).to.be.true;
    });
    
    it('debe retornar false para teléfono inválido', () => {
      expect(validador.telefonoValido('abc')).to.be.false;
    });
  });
});
----

==== Deprecación de Tests

A veces es necesario eliminar tests obsoletos.

.Proceso correcto:
[source,typescript]
----
describe('Calculadora', () => {
  // MARCAR COMO DEPRECATED
  it.skip('cálculo antiguo (deprecado en v2.0)', () => {
    // Mantener test pero no ejecutar
    expect(true).to.be.true;
  });
  
  // NUEVO TEST QUE REEMPLAZA
  it('cálculo mejorado en v2.0', () => {
    const calc = new Calculadora();
    expect(calc.sumar(2, 3)).to.equal(5);
  });
});

// O comentar con contexto:
/*
it('función antigua - removida en v3.0', () => {
  // DEPRECATED: Use newFunction() en su lugar
  // expect(oldFunction()).to.equal(5);
});
*/
----

==== Test Gardening: Mantenimiento Regular

Mantener suites de tests saludables.

.Checklist de mantenimiento:
[source]
----
□ Ejecutar todos los tests regularmente
□ Eliminar tests duplicados
□ Actualizar tests cuando cambia implementación
□ Aumentar coverage para nuevo código
□ Revisar tests lentos (>500ms)
□ Limpiar mocks/stubs sin usar
□ Refactorizar describe/it muy anidados
□ Actualizar fixtures obsoletas
□ Revisar tests con muchas variables
□ Documentar tests complejos
----

.Ejemplo de gardening:
[source,bash]
----
# Encontrar tests muy lentos
mocha --reporter json | jq '.tests[] | select(.duration > 500)'

# Encuentra tests duplicados
grep -r "it('debe" tests/ | sort | uniq -d

# Ver coverage y encontrar huecos
nyc mocha && open coverage/index.html

# Limpiar tests marcados como skip
grep -r "it.skip" tests/ | wc -l

# Refactorizar si hay muchos describes anidados
grep -c "describe(" tests/archivo.test.ts
----

.Script de verificación anual:
[source,json]
----
{
  "scripts": {
    "test:garden": "npm run test:coverage && npm run test:slow && npm run test:grep-skip",
    "test:slow": "mocha --reporter json | jq '.tests[] | select(.duration > 500)'",
    "test:grep-skip": "grep -r 'it.skip\\|it.only\\|describe.skip\\|describe.only' tests/"
  }
}
----

---

== Módulo 13: Debugging y Troubleshooting de Tests

Técnicas para diagnosticar y resolver problemas en tests fallidos.

=== 13.1 Técnicas de Debug

==== console.log() Debugging

La forma más simple pero efectiva de debuggear.

.Ejemplo:
[source,typescript]
----
import { expect } from 'chai';

function procesarDatos(datos: any[]): number {
  console.log('Datos ingresados:', datos);  // Debug 1
  const filtrados = datos.filter(d => d.activo);
  console.log('Después de filtrar:', filtrados);  // Debug 2
  const suma = filtrados.reduce((s, d) => s + d.valor, 0);
  console.log('Suma calculada:', suma);  // Debug 3
  return suma;
}

describe('procesarDatos - Debug', () => {
  it('debe sumar valores de datos activos', () => {
    const datos = [
      { valor: 10, activo: true },
      { valor: 20, activo: false },
      { valor: 30, activo: true }
    ];
    
    const resultado = procesarDatos(datos);
    // Output:
    // Datos ingresados: [ ... ]
    // Después de filtrar: [ ... ]
    // Suma calculada: 40
    
    expect(resultado).to.equal(40);
  });
});

// Ejecutar: mocha --reporter spec (muestra console.log)
----

==== VSCode Debugger

Debuggear tests directamente en VSCode.

.Crear .vscode/launch.json:
[source,json]
----
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Mocha Tests",
      "program": "${workspaceFolder}/node_modules/.bin/mocha",
      "args": [
        "tests/**/*.test.ts",
        "--require",
        "ts-node/register"
      ],
      "console": "integratedTerminal",
      "internalConsoleOptions": "neverOpen"
    }
  ]
}
----

.Uso:
1. Abrir test file
2. Click en números de línea para agregar breakpoints
3. Presionar F5 para iniciar debug
4. Pausa en breakpoints, inspecciona variables

==== Mocha --grep para Tests Específicos

Ejecutar solo ciertos tests para debuggear.

.Sintaxis:
[source,bash]
----
# Ejecutar tests que coinciden con patrón
mocha --grep "sumar"
mocha --grep "debe.*positivo"
mocha --grep "^Calculadora"

# Usar regex
mocha --grep "debe (sumar|restar)"

# Case insensitive
mocha --grep "SUMA" -i
----

.Ejemplo:
[source,bash]
----
describe('Calculadora', () => {
  describe('sumar', () => {
    it('debe sumar números positivos', () => {});
    it('debe sumar números negativos', () => {});
  });
  
  describe('restar', () => {
    it('debe restar correctamente', () => {});
  });
});

# Ejecutar solo tests de sumar:
$ mocha --grep "sumar"
# Output:
# Calculadora
#   sumar
#     ✓ debe sumar números positivos
#     ✓ debe sumar números negativos
#   2 passing
----

==== it.only() para Aislamiento

Ejecutar solo un test para debuggear.

.Ejemplo:
[source,typescript]
----
describe('Carrito', () => {
  it('debe agregar item', () => {
    // ...
  });
  
  it.only('debe calcular total (DEBUGGEANDO)', () => {
    const carrito = new Carrito();
    carrito.agregar({ precio: 100 });
    console.log('Total:', carrito.total);
    expect(carrito.total).to.equal(100);
  });
  
  it('debe aplicar descuento', () => {
    // No se ejecuta mientras hay .only
  });
});

// Ejecutar: mocha
// Solo ejecuta el test con .only
----

⚠️ **Importante**: Siempre remover `.only()` antes de commit!

==== Mocha --bail para Parar en Primer Error

Útil cuando múltiples tests fallan.

[source,bash]
----
mocha --bail          # Detener en primer fallo
mocha --bail tests/unit/calculadora.test.ts  # En archivo específico
----

---

=== 13.2 Análisis de Errores Comunes

==== Error: "expected X to equal Y"

Test de igualdad fallido.

.Diagnostic:
[source,typescript]
----
it('debe retornar suma correcta', () => {
  const resultado = sumar(2, 3);
  expect(resultado).to.equal(5);
  
  // Error: expected 4 to equal 5
  // Posibles causas:
  // 1. Lógica en la función es incorrecta
  // 2. Argumentos pasados al test son diferentes
  // 3. Tipo de dato es incorrecto (4 vs '4')
});

// Solution: Verificar
console.log('Resultado:', resultado, typeof resultado);  // Debug
expect(resultado).to.equal(5);
----

==== Error: "Cannot read property X of undefined"

Accediendo a propiedad de null/undefined.

.Diagnostic:
[source,typescript]
----
it('debe obtener usuario', () => {
  const usuario = obtenerUsuario(1);
  expect(usuario.nombre).to.equal('Juan');
  
  // Error: Cannot read property 'nombre' of undefined
  // usuario es undefined!
});

// Solution:
console.log('Usuario:', usuario);  // ¿Es undefined?
expect(usuario).to.exist;           // Verificar primero
if (usuario) {
  expect(usuario.nombre).to.equal('Juan');
}
----

==== Error: "Timeout of 2000ms exceeded"

Test tarda más que timeout.

.Diagnostic:
[source,typescript]
----
it('debe completar operación', () => {
  // Operación lenta sin await
  operacionAsincronica();  // ¡Falta await!
  expect(resultado).to.equal(true);
  
  // Error: Timeout of 2000ms exceeded
});

// Solution:
it('debe completar operación', async () => {
  await operacionAsincronica();  // Agregar await
  expect(resultado).to.equal(true);
});

// O aumentar timeout:
it('debe completar operación', function() {
  this.timeout(5000);
  return operacionAsincronica();
});
----

==== Error: "AssertionError: expected false to be true"

Assertion boolean fallida.

.Diagnostic:
[source,typescript]
----
it('debe validar email', () => {
  const valido = validarEmail('invalid@');
  expect(valido).to.be.true;
  
  // Error: expected false to be true
  // La función retorna false pero esperamos true
});

// Solution: Verificar lógica de validación
console.log('ValidarEmail retorna:', validarEmail('invalid@'));
// O verificar que el email es válido en realidad
----

---

=== 13.3 Estrategias de Troubleshooting

==== Test Red-Green-Refactor

Si un test falla inesperadamente, usar TDD al revés:

1. **RED**: Entender por qué falla
2. **GREEN**: Fix minimal para pasar
3. **REFACTOR**: Limpiar

.Ejemplo:
[source,typescript]
----
// Test RED: Falla
it('debe calcular IVA correctamente', () => {
  const resultado = calcularIVA(100);  // 100 * 0.21 = 21
  expect(resultado).to.equal(21);
  // Error: expected undefined to equal 21
});

// Función incompleta
function calcularIVA(monto: number) {
  // No hace nada!
}

// GREEN: Fix simple
function calcularIVA(monto: number) {
  return monto * 0.21;  // Solo lo necesario
}

// REFACTOR: Mejorar
function calcularIVA(monto: number, tasa: number = 0.21): number {
  if (monto < 0) throw new Error('Monto debe ser positivo');
  return Math.round(monto * tasa * 100) / 100;  // Redondeo correcto
}

// Test ahora pasa con más robustez
----

==== Crear Test Mínimo Reproducible

Si un test falla, crear versión mínima que reproduzca error.

.Ejemplo: Test complejo que falla
[source,typescript]
----
it('debe procesar pedido con múltiples items y validaciones', () => {
  const pedido = new Pedido();
  pedido.agregar(producto1);
  pedido.agregar(producto2);
  const desc = pedido.aplicarDescuento(0.1);
  const impuesto = pedido.calcularImpuesto();
  const total = pedido.obtenerTotal();
  
  expect(total).to.equal(expectedValue);
  // ¿Cuál parte falla exactamente?
});

// Versión mínima reproducible:
it('debe obtener total correcto (MÍNIMO)', () => {
  const pedido = new Pedido();
  pedido.agregar({ precio: 100 });
  
  const total = pedido.obtenerTotal();
  expect(total).to.equal(100);
  // Mucho más fácil de debuggear
});
----

==== Usar describe.only() y it.only() Estratégicamente

[source,typescript]
----
describe.only('Carrito', () => {
  // Solo ejecutar tests de Carrito, no otros describes
  
  describe('agregar', () => {
    it.only('debe agregar un item', () => {
      // Ejecutar solo este test
    });
    
    it('debe agregar múltiples items', () => {
      // No se ejecuta
    });
  });
});
----

---

== Módulo 14: Integración con Herramientas

Integración de tests con CI/CD y herramientas de desarrollo.

=== 14.1 CI/CD Pipelines

==== GitHub Actions

Ejecutar tests automáticamente en cada push.

.Crear .github/workflows/tests.yml:
[source,yaml]
----
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [14.x, 16.x, 18.x]
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v2
      with:
        node-version: ${{ matrix.node-version }}
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run tests
      run: npm test
    
    - name: Generate coverage report
      run: npm run test:coverage
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v2
      with:
        files: ./coverage/lcov.info
----

==== GitLab CI

Alternativa a GitHub Actions.

..gitlab-ci.yml:
[source,yaml]
----
stages:
  - test
  - coverage

test:
  stage: test
  image: node:16
  script:
    - npm ci
    - npm test
  artifacts:
    reports:
      junit: test-results.xml
    paths:
      - coverage/

coverage:
  stage: coverage
  image: node:16
  script:
    - npm ci
    - npm run test:coverage
  coverage: '/Lines\s:.*?(\d+\%)/'
----

==== Validación de Coverage

Fallar build si coverage es bajo.

.En GitHub Actions:
[source,yaml]
----
- name: Check coverage threshold
  run: npm run test:coverage -- --check-coverage --lines 80
  # Falla si lines coverage < 80%
----

.En package.json:
[source,json]
----
{
  "scripts": {
    "test:ci": "nyc --check-coverage --lines 80 mocha"
  }
}
----

---

=== 14.2 Pre-commit Hooks

==== Husky + Lint-Staged

Ejecutar tests antes de commit.

.Instalación:
[source,bash]
----
npm install husky lint-staged --save-dev
npx husky install
npx husky add .husky/pre-commit "npx lint-staged"
----

.Configurar package.json:
[source,json]
----
{
  "lint-staged": {
    "src/**/*.ts": [
      "eslint --fix",
      "npm test -- --testPathPattern=$(git diff --cached --name-only | grep -E '\.ts$' | head -1)"
    ],
    "tests/**/*.ts": [
      "mocha --grep $(basename $(git diff --cached --name-only | grep -E '\.test.ts$'))"
    ]
  }
}
----

.Flujo:
1. Hacer cambios en código
2. `git add .`
3. `git commit -m "fix: bug en calculadora"`
4. Husky ejecuta pre-commit hook
5. Lint-staged corre linters y tests
6. Si pasa, commit se ejecuta
7. Si falla, commit se cancela

---

=== 14.3 NPM Scripts Útiles

==== Development Scripts

[source,json]
----
{
  "scripts": {
    "test": "mocha",
    "test:watch": "mocha --watch --watch-extensions ts",
    "test:debug": "mocha --inspect-brk",
    "test:grep": "mocha --grep",
    "test:unit": "mocha tests/unit/**/*.test.ts",
    "test:integration": "mocha tests/integration/**/*.test.ts",
    "test:coverage": "nyc mocha",
    "test:coverage:report": "nyc report --reporter=html && open coverage/index.html"
  }
}
----

.Uso:
[source,bash]
----
npm test                    # Ejecutar todos
npm run test:watch        # Modo watch
npm run test:debug        # Debugger
npm run test:coverage     # Con coverage
npm run test:unit         # Solo unit tests
npm run test:grep "sumar" # Filter por patrón
----

==== Performance Scripts

[source,json]
----
{
  "scripts": {
    "test:slow": "mocha --reporter json | jq '.tests[] | select(.duration > 500) | {title: .title, duration: .duration}'",
    "test:slowest": "mocha --reporter json | jq '.tests | sort_by(.duration) | reverse | .[0:10]'",
    "test:quick": "mocha --reporter min"
  }
}
----

.Uso:
[source,bash]
----
npm run test:slow    # Tests > 500ms
npm run test:slowest # Top 10 más lentos
npm run test:quick   # Output mínimo
----

==== CI/CD Scripts

[source,json]
----
{
  "scripts": {
    "test:ci": "nyc --check-coverage --lines 80 mocha --reporter json --reporter-options outputFile=test-results.json",
    "test:ci:coverage": "nyc report --reporter=lcov --reporter=text-summary",
    "test:report": "mocha --reporter html --reporter-options reportDir=./reports"
  }
}
----

---

== Recursos Adicionales
- Documentación oficial: https://mochajs.org/
- Chai assertions: https://www.chaijs.com/
- Sinon mocking: https://sinonjs.org/
- Nyc coverage: https://github.com/istanbuljs/nyc
- Supertest: https://github.com/visionmedia/supertest


